<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些前端知识</title>
    <link href="/2023/05/06/FrontEnd/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/05/06/FrontEnd/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="vue">Vue</h2><p>Vue 借鉴了 AngulaJS 的模块化开发和 React 的虚拟 Dom ，所谓虚拟 Dom就是把 Dom 操作放到内存中执行</p><h3 id="基础知识">基础知识</h3><p>SoC 关注度分离原则</p><h3 id="自定义事件分发">自定义事件分发</h3><blockquote><p>this.$emit('事件名', [参数])</p></blockquote><h3 id="计算属性">计算属性</h3><p>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约系统开销。</p><h3 id="双向绑定">双向绑定</h3><h4 id="下拉框的特殊处理">下拉框的特殊处理</h4><p>针对 iOS 用户，需要加一个“请选择”的默认选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;vue&quot;</span>&gt;<br>    下拉框:<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span> &gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>选中的值: &#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#vue&#x27;</span>，</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="模板传参绑定">模板传参绑定</h4><p>模板 qinjiang 绑定了 #app 的 items 字段，同时使用 for循环去读取每一个 item 的值，并将这个值传递给模板 qinjiang 的 props 中的qin 字段，并在列表中显示出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">qinjiang</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:qin</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">qinjiang</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn,jsdelivr,net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;qinjiang&quot;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;qin&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;li&gt;(&#123;qin&#125;&#125;&lt;/li&gt;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">items</span>: [<span class="hljs-string">&quot;Java&quot;</span>,<span class="hljs-string">&quot;Linux&quot;</span>,<span class="hljs-string">&quot;前端&quot;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="rimraf">rimraf</h3><p>npm install rimraf -g rimraf</p>]]></content>
    
    
    <categories>
      
      <category>FrontEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FrontEnd</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud 学习笔记</title>
    <link href="/2023/04/10/DistributedSystem/MicroService/Nacos%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/04/10/DistributedSystem/MicroService/Nacos%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="nacos">Nacos</h1><p>Nacos 组件可以用于服务注册中心、配置中心。</p><h2 id="临时实例与非临时实例">临时实例与非临时实例</h2><p>由于 Nacos 支持集群管理，因此底层使用 Raft 协议来完成分布式功能。在Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式。</p><p>对于非临时实例，Nacos采用主动检测模式，当非临时实例心跳不正常时不会被剔除。同时对于非临时实例的变更，Nacos采用主动消息推送，服务列表更新更加及时。</p><h3id="如何将一个实例声明为非临时实例">如何将一个实例声明为非临时实例？</h3><p>通过在所要声明的非临时实例配置文件中加入以下配置即可：</p><blockquote><p>spring.cloud.nacos.discovery.ephemeral=false</p></blockquote><p>当值为 false 时表示为非临时实例，默认为 true。</p><h2 id="配置文件">配置文件</h2><h3 id="配置文件优先级">配置文件优先级</h3><blockquote><p>服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置</p></blockquote><p>其中 profile 代表环境名</p><h1 id="feign">Feign</h1><p>Nacos 组件可以用于服务之间的远程调用，是 Spring CloudNetflix组件中的一个轻量级 Restful 的 HTTP 服务客户端。Feign有以下功能：</p><ul><li>封装了 Ribbon 实现负载均衡；</li><li>封装了 RestTemplate 实现 HTTP 请求的发起，以实现远程服务调用。</li></ul><h1 id="spring-cloud-gateway">Spring Cloud Gateway</h1><p>SpringCloud Gateway 基于 Spring 5.0，Spring Boot 2.0 和 ProjectReactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API路由管理方式，目标是替代 <strong>Zuul</strong>。</p><p>SpringCloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux框架底层则使用了高性能的 Reactor 模式通信框架 Netty，同时基于 Filter链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p><h2 id="filter">Filter</h2><p>Filter 过滤器功能如下：</p><ul><li>负责对路由的请求或响应做加工处理，比如添加消息头；</li><li>配置在路由下的过滤器只对当前路由的请求生效；<ul><li>也可以通过 defaultFilters 添加默认过滤器</li></ul></li></ul><h3 id="全局过滤器-globalfilter">全局过滤器 GlobalFilter</h3>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
      <category>MicroService</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次项目数据恢复记录</title>
    <link href="/2023/04/06/Misc/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    <url>/2023/04/06/Misc/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>实验室的师兄师姐好几年前曾经开发了一个类似于在线靶场的项目，用于老板的本科生课程实践部分。这个老项目简单来说的逻辑就是：提供一个web界面，用户可以通过这个界面注册登录并加入课程，由课程助教每周发布对应的CTF 题目，题目由后端启动对应的 docker容器提供给学生交互，根据题目内容在对应的容器中获取 flag并提交完成作业。</p><p>这个项目大概在 2018年完成，而后在实验室物理服务器上运行了一段时间，并向本科生提供服务。中间经历过代码重构、网站被攻击、物理服务器宕机、实验室断电等一系列问题后，终于在2020年左右迁移到学院与华为云合作的云平台上。本以为在云端的加持下，项目可以平稳运行。没想到在2023 年 4 月 3 号还是出现了问题...</p><h2 id="问题发生">问题发生</h2><p>2023 年 4 月 3 日晚上，助教群突然反映服务器 IP没法正常访问，网站访问为白页，起初以为是正常的服务器抽风，于是在云平台重启云主机，但始终停留在CentOS 的开机页面。等到 4号上午助教反应依旧没法正常启动主机，当时就意识到问题的严重性。</p><blockquote><p>这里插一句，因为这个项目实际上没有人维护，之前维护的学姐也只给当时负责制作题目和课程助教的我扔了一个大概5 GB的压缩包，里面包含了从项目立项到我入学的所有历史代码和文档，是名副其实的“屎山”。因为是“屎山”加上实验室课题组之间跨度过大，因此没有一个正经的运维人员，数据备份也是随缘进行。</p></blockquote><p>当时让助教联系华为那边的工程师看看他们有什么办法，大概搞了一上午得到的结论是：没有办法。下午被老板一个微信叫到办公室，就开始加入到恢复项目的队伍中。</p><h2 id="确定问题">确定问题</h2><p>一开始是和助教进行一对一对线，助教负责在中间传递工程师和我的对话。那边的意思是只能恢复文件数据，主机肯定是开不了机了。同时将根目录下的数据全部挂载到另一台主机上，提供了一个ssh 连接。</p><p>仔细分析了一下，由于这个主机上主要保存了四大部分：后端代码、前端代码、数据库中间件、题目docker镜像。其中前后端代码在我当助教时因为对这种压缩包版本控制嗤之以鼻，已经git存在云端。当时刚入学时需要我们进行题目镜像的制作，因此有一台备用服务器上面有题目docker镜像。到目前为止，可以确定的是我们似乎只失去了数据库中的文件。</p><p>但是由于工程师将我们的数据进行了恢复，所以情况还是比较乐观的。</p><p>那么问题就简化为了：<strong>如何从 Unix 文件结构中找到我们需要的MySQL 的数据，并迁移到另一台可以运行 MySQL 的服务器上？</strong></p><h2 id="解决问题">解决问题</h2><p>等到确定最终问题已经下午六点了，通过云平台的克隆模式，将备用服务器克隆了一下准备进行尝试。</p><p>由于备用服务器使用的 MySQL版本和主服务器版本一致，这减轻了不少工作量。我的初步猜想是只要找到 MySQL存储数据的文件夹，直接将里面的内容替换为我们恢复的数据即可。通过查阅资料了解到MySQL 存储数据的位置在 <code>/var/lib/mysql</code> 目录下。因为仅仅使用MySQL 而没有分析过 MySQL 目录结构，一度担心 MySQL会根据不同的服务器对数据进行加密。后来也没细想，直接使用<code>scp</code> 从工程师提供的 IP中复制已宕机的服务器中对应的数据，直接进行了替换。</p><p>替换后启动 MySQL 一直报错，启动 systemctl start mysqld 提示 Error: 13(权限不够)，想了半天才想到直接梭哈：</p><blockquote><p>chmod 777 /var/lib/mysql</p></blockquote><p>或者可以直接</p><blockquote><p>chown -R mysql /var/lib/mysql</p></blockquote><p>没想到运行起来之后还真的就正常提供服务了。（后面查阅资料后，才感谢备用服务器的MySQL 表结构和主服务器一致）</p><p>将前后端部署到新服务器上后，web端恢复正常运行，可以正常访问网站。</p><h2 id="后记">后记</h2><p>半夜助教又反馈：访问倒是能访问了，但是学生找到 flag后提交一直显示答案错误。后来第二天我又一次打开那坨文档，排查错误点，还是没什么不对的地方。算了干脆去查日志，找到了一个没有被任何文档提及的配置，修改后部署，答案正确。</p><h2 id="后后记">后后记</h2><p>又过了一天，助教反映：忘记密码模块有问题，学生收不到重置密码的邮件。。。。</p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程常见问题</title>
    <link href="/2023/04/02/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/02/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="inetsocketaddress">InetSocketAddress</h2><p>前段时间在使用 Netty开发服务器时想在通信建立时加一个日志，用于打印连接过来的客户端信息（IP和 Port），但是发现建立连接的过程很慢，于是有了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">socketAddress</span> <span class="hljs-operator">=</span> (InetSocketAddress) ctx.channel().remoteAddress();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hostName</span> <span class="hljs-operator">=</span> socketAddress.getHostName();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> String.valueOf(socketAddress.getPort());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime();<br>    log.info(<span class="hljs-string">&quot;客户端通道已经建立完成, 客户端 IP: &#123;&#125;，Port: &#123;&#125;, 用时 &#123;&#125; ms&quot;</span>, hostName, port, endTime - startTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看控制台发现获取信息竟然用了 7000+ ms。</p><blockquote><p>2023-04-02 19:52:44.300 INFO 96712 --- [ntLoopGroup-3-1]o.l.xxx.netty.handler.ServerMsgHandler : 客户端通道已经建立完成, 客户端IP: xxx.xxx.xxx.xxx，Port: xxxxx, 用时 7518 ms</p></blockquote><p>去查了一下才了解到 InetSocketAddress 的 getHostName()方法进行一个反向主机名查找，这个方法调用的性能取决于 JVM和目标主机的域名服务器之间的网络性能，也就是说这个方法引发了一个系统调用执行反向查找。如果仅仅是想获取客户端的IP 可以通过以下方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取远程 IP</span><br><span class="hljs-type">String</span> <span class="hljs-variable">hostName</span> <span class="hljs-operator">=</span> socketAddress.getAddress().getHostAddress();<br><span class="hljs-comment">// 获取远程 Port</span><br><span class="hljs-type">String</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> String.valueOf(socketAddress.getPort());<br></code></pre></td></tr></table></figure><h2 id="netty-的-lengthfieldbasedframedecoder-使用">Netty 的LengthFieldBasedFrameDecoder 使用</h2><p>LengthFieldBasedFrameDecoder 是 netty解决拆包粘包问题的一个重要的类，主要结构就是 header + body结构。我们只需要传入正确的参数就可以发送和接收正确的数据。下面我们就具体了解一下这几个参数的意义。先来看一下LengthFieldBasedFrameDecoder主要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maxFrameLength,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> lengthFieldOffset, <span class="hljs-type">int</span> lengthFieldLength,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> lengthAdjustment, <span class="hljs-type">int</span> initialBytesToStrip)</span><br></code></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>maxFrameLength：最大帧长度。也就是可以接收的数据的最大长度。如果超过，此次数据会被丢弃；</li><li>lengthFieldOffset：长度域偏移。就是说数据开始的几个字节可能不是表示数据长度，需要后移几个字节才是长度域；</li><li>lengthFieldLength：长度域字节数。用几个字节来表示数据长度；</li><li>lengthAdjustment：数据长度修正。因为长度域指定的长度可以是 header +body 的整个长度，也可以只是 body 的长度。如果表示 header + body的整个长度，那么我们需要修正数据长度；<ul><li>默认值为 0</li></ul></li><li>initialBytesToStrip：跳过的字节数。如果你需要接收 header + body的所有数据，此值就是 0 ，如果你只想接收 body 数据，那么需要跳过 header所占用的字节数。<ul><li>可以通过这个字段来只传递数据段</li></ul></li></ul><h2 id="netty-中-channelhandler-并发安全分析">Netty 中 ChannelHandler并发安全分析</h2><p>如果 ChannelHandler是非共享的，则它就是线程安全的，原因：当链路完成初始化会创建ChannelPipeline ，每个 channel 对应一个 ChannelPipeline 实例，业务的ChannelHandler 会被实例化并加入 ChannelPipeline 中执行，由于某个 Channel只能被特定的 NioEventLoop 线程执行，因此 ChannelHandler不会被并发调用，不用考虑线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ch.pipeline().addLast(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoThreadSecurityClientHandler</span>()<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果只初始化一次业务 ChannelHandler ，然后加到多个 Channel 的ChannelPipeline ，由于不同的 Channel 可能绑定不同的 NioEventLoop线程，这样 ChannelHandler 就可能被多个 I/O线程访问，存在并发访问风险了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">clientHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoHandler</span>();<br>b.group(group)<br>    .channel(NioSocketChannel.class)<br>    .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br>    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            ch.pipeline().addLast(clientHandler);<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>如果某个 ChannelHandler 需要全局共享，则通过 Sharable注解就可以被添加到多个 ChannelPipeline 。</p><p>当 ChannelHandler 被添加到多个 ChannelPipeline，就会面临多线程并发访问问题，需要 ChannelHandler保证自身的线程安全，例如通过原子类、读写锁等方式对数据做并发保护。如果加锁，可能会阻塞NioEventLoop 线程，所以 Sharable 注解的 ChannelHandler 要慎用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈字符串匹配问题</title>
    <link href="/2023/03/31/Algorithm/%E8%B0%88%E4%B8%80%E8%B0%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/31/Algorithm/%E8%B0%88%E4%B8%80%E8%B0%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>一个最简单的<strong>字符串匹配</strong>问题可以理解为如下：</p><blockquote><p>给定一个长度为 n 的字符串 <spanclass="math inline">\(s\)</span>，检测长度为 m 的字符串 <spanclass="math inline">\(t\)</span> 在 <spanclass="math inline">\(s\)</span> 中出现的位置。</p></blockquote><p>最开始，我们可以使用一些比较朴素的做法，例如直接枚举 <spanclass="math inline">\(t\)</span> 在 <spanclass="math inline">\(s\)</span>中的位置，通过对每个位置进行比较进而得到答案，这样做的最差时间复杂度为<spanclass="math inline">\(O(n*m)\)</span>。当字符串长度较长时，时间代价过大。</p><p>事实上我们可以思考，在每次匹配失败后朴素的做法是将字符串 <spanclass="math inline">\(t\)</span>向后移动一位继续重新匹配。是否存在一种方法可以减少重新匹配的次数呢？也就是说每次向后移动一位是否增加了很多不必要的匹配呢？</p><p>最长公共真前后缀！每次匹配失败后并不是只移动一位，而是移动到当前子串的最长公共真前后缀的位置，这样就避免了一部分的重复匹配，<strong>KMP算法</strong>正是这样做的。它的基本思路是首先对字符串 <spanclass="math inline">\(t\)</span> 进行预处理数组 <spanclass="math inline">\(next\)</span>，计算出其前缀子串的最长公共真前后缀长度，这样就可以在匹配过程中进行转移。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix_function</span><span class="hljs-params">(string t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> j = next[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; t[i] != t[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t[i] == t[j]) &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 <code>prefix_function</code> 我们就可以得到预期的 <spanclass="math inline">\(next\)</span>数组，那我们该怎么使用呢？一般只有在匹配失效时使用 <spanclass="math inline">\(next\)</span> 数组，这时只需要将字符串 <spanclass="math inline">\(t\)</span>的指针指向上一个匹配的公共真前后缀后的位置即可，具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">KMP</span>(string s, string t) &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">prefix_function</span>(t);<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;<br>            i++, j++;<br>            <span class="hljs-keyword">if</span> (j == t.<span class="hljs-built_in">length</span>()) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(i - j, i - <span class="hljs-number">1</span>));<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码返回的是所有在主串 <span class="math inline">\(s\)</span>中出现 <span class="math inline">\(t\)</span> 的开始结束下标。</p><p>那么问题又来了，当我们想在一个字符串里寻找多个这样的 <spanclass="math inline">\(t\)</span> 时该怎么做呢？对每一个 <spanclass="math inline">\(t\)</span> 都构建 <spanclass="math inline">\(next\)</span>数组吗？这听起来是可行的，算了算时间复杂度也不过 <spanclass="math inline">\(O((n + m)*m)\)</span>，似乎是可以接受的。</p><p>有没有更好的做法呢？这若干个字符串 <spanclass="math inline">\(t\)</span>会不会有联系？能不能只用线性时间复杂度完成这样的工作呢？</p><p><strong>AC自动机</strong>正是为了这种解决这种<strong>多模式匹配</strong>问题而出现的，具体的思路是<strong>Trie tree + fail pointer</strong>。要明白的一点是字典树(Trietree)本质上就是一个自动机，这个自动机只能接受且仅接受指定的字符串集合中的元素，而且是通过不同的字母形成的边进行转移。</p><p>我们首先利用这些字符串 <span class="math inline">\(t\)</span>构建一棵字典树。显然光这样是不够的，当我们用主串去输入到这个字典树的时候，会有一些异常情况，比如有些字母不存在边对他们进行转移，这时候就需要加点东西：fail指针。</p><p>fail指针的作用是当发现没有预期匹配的边后，尝试转移到其他相同的后缀子树中，听起来很熟悉，因为KMP 也是这样的思路，只不过 KMP 是借助一个辅助数组进行失配转移，而我们给AC 自动机中的每个点都加了一个 fail 指针。AC自动机中的根节点用来吸收所有预期之外的字母（指fail指针转移的终点）。</p><p>AC 自动机的每个节点都是如下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ACTree</span> &#123;<br>    ACTree *child[<span class="hljs-number">26</span>];<br>    ACTree *fail;<br>    vector&lt;<span class="hljs-type">int</span>&gt; exist; <span class="hljs-comment">// exist 数组存储的是以当前结尾的所有单词长度</span><br>    <span class="hljs-built_in">ACTree</span>() &#123;<br>        fail = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 初始化根节点的 fail 指向空</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            child[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们依然按照以下方式先往这棵树中添加单词，和传统字典树不同的是用exist 数组替代了 isEnd 标记，这允许我们能从每个节点获取更多信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>    ACTree *cur = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>        <span class="hljs-type">int</span> idx = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (cur-&gt;child[idx] == <span class="hljs-literal">nullptr</span>) &#123;<br>            cur-&gt;child[idx] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ACTree</span>();<br>        &#125;<br>        cur = cur-&gt;child[idx];<br>    &#125;<br>    cur-&gt;exist.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">length</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>当 AC 自动机中的字典树构建完成后就开始进行最重要的 fail指针构建，<strong>fail指针指向的是所有模式串的前缀中匹配当前状态的最长后缀</strong>。我们采用层次遍历的方法去给每个节点生成fail 指针的指向，这借助了父节点的 fail 指针信息，具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt; &amp;s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 将所有单词插入到当前的 AC 自动机中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;word : s) &#123;<br>        <span class="hljs-built_in">insert</span>(word);<br>    &#125;<br>    queue&lt;ACTree*&gt; q;<br>    <span class="hljs-comment">// 首先处理与根节点直接相连的节点</span><br>    <span class="hljs-comment">// 这些节点的真后缀为空，所以 fail 指针指向根节点</span><br>    <span class="hljs-comment">// 同时根据层序遍历的逻辑将他们加入到队列中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;child[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;child[i]-&gt;fail = <span class="hljs-keyword">this</span>;<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>-&gt;child[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 处理当前节点的子节点</span><br>        ACTree *cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-comment">// 找到某个子节点，使用 nxt 指向它，</span><br>            <span class="hljs-comment">// 并使用 fafail 指向父节点的 fail 指针</span><br>            <span class="hljs-keyword">if</span> (cur-&gt;child[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>                ACTree *nxt = cur-&gt;child[i], *fafail = cur-&gt;fail;<br>                <span class="hljs-comment">// 借助 fafail 指针遍历所有模式串的前缀中匹配当前状态的后缀</span><br>                <span class="hljs-comment">// 由于我们是层序遍历，所以每失败一次我们就会向上一层进行尝试</span><br>                <span class="hljs-keyword">while</span> (fafail != <span class="hljs-literal">nullptr</span> &amp;&amp; fafail-&gt;child[i] == <span class="hljs-literal">nullptr</span>) &#123;<br>                    fafail = fafail-&gt;fail;<br>                &#125;<br>                <span class="hljs-comment">// 当然如果找不到这样的后缀，最终会指向根节点</span><br>                <span class="hljs-keyword">if</span> (fafail == <span class="hljs-literal">nullptr</span>) &#123;<br>                    nxt-&gt;fail = <span class="hljs-keyword">this</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    nxt-&gt;fail = fafail-&gt;child[i];<br>                &#125;<br>                <span class="hljs-comment">// 记录 fail 指针所指向节点包含的单词</span><br>                <span class="hljs-keyword">if</span> (nxt-&gt;fail-&gt;exist.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : nxt-&gt;fail-&gt;exist) &#123;<br>                        nxt-&gt;exist.<span class="hljs-built_in">push_back</span>(it);<br>                    &#125;<br>                &#125;<br>                q.<span class="hljs-built_in">push</span>(nxt);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC自动机构建完成后就可以进行主串的匹配，其原理和自动机逻辑相同，当遇到没有匹配的边后，通过fail 指针转移到其他子树，直到把整个字符串匹配完成，匹配过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回的是所有在 t 中出现的单词的左右下标</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">query</span>(<span class="hljs-type">const</span> string &amp;t) &#123;<br>    ACTree *cur = <span class="hljs-keyword">this</span>;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> idx = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-comment">// 失配时通过 fail 指针转移</span><br>        <span class="hljs-keyword">while</span> (cur-&gt;child[idx] == <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;fail != <span class="hljs-literal">nullptr</span>) &#123;<br>            cur = cur-&gt;fail;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;child[idx] != <span class="hljs-literal">nullptr</span>) &#123;<br>            cur = cur-&gt;child[idx];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录中间遇到的单词</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;exist.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : cur-&gt;exist) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(i - it + <span class="hljs-number">1</span>, i));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码可以通过本博客的另一篇文章《算法练习常用模板》查看。</p><p>目前字符串匹配只见到了这两种：单字符串匹配和多模式串匹配，后续遇到后缀自动机再更新一下本文。本文主要帮助我自己记忆一些思路，可能形容不是很贴切，具体可以通过<a href="https://oi-wiki.org/string/ac-automaton/">OI-WIKI</a>进行学习，BiliBili这个视频 <ahref="https://www.bilibili.com/video/BV1uJ411Y7Eg/">轻松掌握ac自动机</a>讲的也很棒！</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蚂蚁0330算法岗笔试总结</title>
    <link href="/2023/03/30/Algorithm/InternJob/Ant0330Alg/"/>
    <url>/2023/03/30/Algorithm/InternJob/Ant0330Alg/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>蚂蚁的题总有一种阿里的气息，场外做题的感觉真的比场内要放松很多。</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>小红拿到了一个 01 串 <span class="math inline">\(s\)</span>，她将进行恰好一次如下操作：</p><p>选择下标 <span class="math inline">\(i, j(i \ne j)\)</span> ，交换<span class="math inline">\(s_i\)</span> 和 <spanclass="math inline">\(s_j\)</span>。</p><p>小红想知道，不同的操作方案，最终能生成多少不同的字符串？</p><h3 id="解题方法">解题方法</h3><p>根据题意，我们可以想到对于每一位 0 都可以和前面的若干个 1交换位置形成新的字符串，同理 1 也可以和前面的 0 交换，因此需要统计前缀 0和 1 的个数，即可计算出最终答案。（但需要特判一下长度为 2 的字符串）</p><p>或者只需要统计 0 和 1 的个数，直接相乘得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// version 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> zero = <span class="hljs-number">0</span>, one = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            ans += one;<br>            zero++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans += zero;<br>            one++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// version 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> zero = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            zero++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = (zero*(s.<span class="hljs-built_in">length</span>() - zero) == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:zero*(s.<span class="hljs-built_in">length</span>() - zero));<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>小红定义一个字符串为好串，当且仅当该字符串是回文的，且包含 "red"子串。例如，"redoder" 是好串。</p><p>现在小红拿到了一个字符串，她想知道该字符串有多少个子串是好串？</p><h3 id="解题方法-1">解题方法</h3><p>动态规划。<span class="math inline">\(dp[i][j]\)</span>表示字符串下标从 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span>的子串是否为回文子串，同时再判断是否包含 "red"即可。（可能不是最优解，还有优化的空间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">yes</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len, <span class="hljs-literal">true</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            yes[i][j] = (s[i] == s[j] &amp;&amp; yes[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; len; j++) &#123;<br>            string tmp = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (yes[i][j] &amp;&amp; j - i &gt;= <span class="hljs-number">2</span> &amp;&amp; tmp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;red&quot;</span>) != tmp.npos) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    cout &lt;&lt; <span class="hljs-built_in">countSubstrings</span>(s) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>小红定义一个数组的权值为：平均数正好等于 <spanclass="math inline">\(k\)</span> 的最长连续子数组的长度，</p><p>请你求所有长度为 <span class="math inline">\(n\)</span>的，且元素不大于 <span class="math inline">\(m\)</span>的正整数组成的数组中，权值恰好等于 <spanclass="math inline">\(n\)</span> 的数组数量。答案对 1e9 + 7 取模。</p><p><span class="math inline">\(q\)</span> 次询问，<spanclass="math inline">\(1 \le q \le 10^4\)</span>，每次告诉你 <spanclass="math inline">\(n, m, k\)</span>。</p><h3 id="解题方法-2">解题方法</h3><p>动态规划。我们可以把问题转化为：</p><p>一个体积为 <span class="math inline">\(n*k\)</span> 的背包，可以放<span class="math inline">\(n\)</span> 件物品，每件物品的最大体积为<span class="math inline">\(m\)</span> ，求放满背包的方案数。</p><p>由于询问的次数很多，如果对每次询问做 dp会超时，可以借助离线查询的思维，先处理出所有的情况，<spanclass="math inline">\(dp[i][j][k]\)</span> 表示放 <spanclass="math inline">\(i\)</span> 件物品，体积为 <spanclass="math inline">\(j\)</span>，每件物品的最大体积为 <spanclass="math inline">\(k\)</span> 时的方案个数。</p><p>没在场上测试过，大致算了一下 <spanclass="math inline">\(10^7\)</span>次运算，勉勉强强吧，等看到正解再补一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn_n = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn_k = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn_m = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(maxn_n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(maxn_n*maxn_k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(maxn_m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxn_m; i++) &#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxn_n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= maxn_n*maxn_k; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g = <span class="hljs-number">1</span>; g &lt;= maxn_m; g++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= g; l++) &#123;<br>                    <span class="hljs-keyword">if</span> (j - l &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    dp[i][j][g] = (dp[i][j][g] + dp[i - <span class="hljs-number">1</span>][j - l][g])%mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;       <br>        cout &lt;&lt; dp[n][n*k][m] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>携程0329笔试总结</title>
    <link href="/2023/03/29/Algorithm/InternJob/Ctrip0329/"/>
    <url>/2023/03/29/Algorithm/InternJob/Ctrip0329/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>携程的题比较简单，但还是因为我知识点不够没有能在场上做出最后一题，春招好多厂都考树形DP</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>一个只有数字的字符串，统计其中 '0' 的个数，'0', '6', '9' 包含一个 '0'， '8' 包含两个。</p><h3 id="解题方法">解题方法</h3><p>水题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span> || ch == <span class="hljs-string">&#x27;6&#x27;</span> || ch == <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;8&#x27;</span>) &#123;<br>            ans += <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>游游定义一个排列中，满足以下条件的为"好元素"：对于第公个元素 a而言，a 为前 i个元素的最大值。例如，[3,1,5,2,4]中，第一个和第三个元素是好元素。游游希望你构造一个长度为n 的排列，其中有 k个好元素，且任意两个好元素都不相邻。你能帮帮她吗？</p><p>排列的定义：由 1 到 n 所有正整数组成的长度为 n的数组，每个正整数出现恰好一次。</p><h4 id="输入">输入：</h4><p>两个正整数 n，k，用空格隔开。</p><h4 id="输出">输出：</h4><p>一行 n 个整数</p><h3 id="解题方法-1">解题方法</h3><p>可以将前 k 大的数字从头开始间隔摆放，剩下的数字按增序填充即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-type">int</span> cur = n - k + <span class="hljs-number">1</span>, tmp = cur - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        ans[i] = cur++;<br>        i += <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-number">-1</span>) &#123;<br>            ans[i] = tmp--;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>游游拿到了一个正整数 n，她希望找到一对正整数 x, y 满足 |x!*y - y - n|最小，且 x,y 都不等于2，感叹号表示阶乘。你能帮帮她吗？</p><p>1 &lt;= n &lt;= 1e9</p><h3 id="解题方法-2">解题方法</h3><p>这个题其实比较好想，因为 20! 就已经超过 1e9 只需要枚举 x 然后计算 y，笔试结束才发现自己有个笔误，只能通过暴力骗了88.89%，实在是遗憾，以下是正解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> result_x = <span class="hljs-number">-1</span>, result_y = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> min_val = LONG_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">20</span>; x++) &#123;<br>        fac[x] = fac[x - <span class="hljs-number">1</span>]*x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">20</span>; x++) &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> y = n/(fac[x] - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> y1 = y + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> y2 = y - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> val = <span class="hljs-built_in">abs</span>(<span class="hljs-number">1LL</span>*(fac[x] - <span class="hljs-number">1</span>)*y - n);<br>        <span class="hljs-keyword">if</span> (y != <span class="hljs-number">0</span> &amp;&amp; y != <span class="hljs-number">2</span> &amp;&amp; val &lt; min_val) &#123;<br>            min_val = val;<br>            result_x = x;<br>            result_y = y;<br>        &#125;<br>        val = <span class="hljs-built_in">abs</span>(<span class="hljs-number">1LL</span>*(fac[x] - <span class="hljs-number">1</span>)*y1 - n);<br>        <span class="hljs-keyword">if</span> (y1 != <span class="hljs-number">0</span> &amp;&amp; y1 != <span class="hljs-number">2</span> &amp;&amp; val &lt; min_val) &#123;<br>            min_val = val;<br>            result_x = x;<br>            result_y = y1;<br>        &#125;<br>        val = <span class="hljs-built_in">abs</span>(<span class="hljs-number">1LL</span>*(fac[x] - <span class="hljs-number">1</span>)*y2 - n);<br>        <span class="hljs-keyword">if</span> (y2 != <span class="hljs-number">0</span> &amp;&amp; y2 != <span class="hljs-number">2</span> &amp;&amp; val &lt; min_val) &#123;<br>            min_val = val;<br>            result_x = x;<br>            result_y = y2;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; result_x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result_y &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-4">题目 4</h2><h3 id="题目描述-3">题目描述</h3><p>游游拿到了一棵树，树的每条边有边权。游游准备选择一些边染成红色，她希望不存在两条染红的边共用同一个点，且最终染红边的权值之和尽可能大。你能帮帮她吗？</p><p>注：所谓树，即不包含重边、自环和回路的无向连通图。</p><p>节点个数 n &lt;= 1e5, 边权 w &lt;= 1e9</p><h3 id="解题方法-3">解题方法</h3><p>吃了百度第三题的亏，赛后也没有认真去学树形 DP，拿到这道题的时候呆住了，看着像裸的树形 DP但就是不知道怎么设置状态，我还是太菜了！赛后看到牛客大佬的题解，瞬间就明白怎么做了，于是浅浅补一下题。</p><p>我们可以定义状态 <span class="math inline">\(dp[i][0]\)</span>表示节点 <span class="math inline">\(i\)</span>的出度边不染色的最大收益， <span class="math inline">\(dp[i][1]\)</span>表示节点 <span class="math inline">\(i\)</span> 的出度边染色：</p><ul><li>当节点 <span class="math inline">\(i\)</span>的出度边不染色时，也就意味着其所有子节点 <spanclass="math inline">\(nx\)</span> 的出度边可染可不染，此时收益为 <spanclass="math inline">\(\sum_{nx}^{(i, nx) \in E}max(dp[nx][0],dp[nx][1])\)</span>；</li><li>当节点 <span class="math inline">\(i\)</span>的出度边染色时，需要<strong>从其所有出度边中选择</strong>且<strong>只选择一条边</strong>，此时收益为<span class="math inline">\(max(dp[i][0] - max(dp[nx][0], dp[nx][1]) +dp[nx][0] + val), (i, nx) \in E\)</span>。</li></ul><p>代码如下（未测）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> l, r, val;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;<br>        l--, r--;<br>        g[l].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(r, val));<br>        g[r].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(l, val));<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> p) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[nx, val] : g[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (nx == p) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(nx, cur);<br>            dp[cur][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[nx][<span class="hljs-number">0</span>], dp[nx][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[nx, val] : g[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (nx == p) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[cur][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[cur][<span class="hljs-number">1</span>], dp[cur][<span class="hljs-number">0</span>] - <span class="hljs-built_in">max</span>(dp[nx][<span class="hljs-number">0</span>], dp[nx][<span class="hljs-number">1</span>]) + dp[nx][<span class="hljs-number">0</span>] + val);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小红书0326开发岗笔试总结</title>
    <link href="/2023/03/27/Algorithm/InternJob/Xiaohongshu0326/"/>
    <url>/2023/03/27/Algorithm/InternJob/Xiaohongshu0326/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>小红书的题目算是除拼多多之外比较简单的，就是想不明白为什么第三题可以暴力直接过。</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>凯撒加密，已知密文和滚动长度 3 求明文。</p><h3 id="解题方法">解题方法</h3><p>水题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        s[i] = <span class="hljs-string">&#x27;a&#x27;</span> + (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">3</span> + <span class="hljs-number">26</span>)%<span class="hljs-number">26</span>;<br>    &#125;<br>    cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>在算法中，有各种各样的排序算法，例如归并排序，冒泡排序，快速排序等等。本题中，我们会使用一种新的排序算法：K排序。</p><p>K 排序算法描述如下：首先，算法需要按照某种规则选择该数列上至多 K个位置，将其对应的数抽出来，其他的数都往左对齐，之后这 K个数排好序之后依次放在原数列未尾。以上过程算作一次操作。</p><p>例如，对于数列 [1, 3, 5, 4, 2]，当 K = 2 时可以选择数字 5 和 4，之后数列变成 [1, 3, 2, 4, 5]。</p><p>你的任务是：对于给定的数列，你需要计算出最少需要多少次上述操作使得整个数列从小到大排好序?</p><h3 id="解题方法-1">解题方法</h3><p>思维题。首先我们可以明确的是：</p><ol type="1"><li>每一次操作可排序的数为 K 个；</li><li>对于未被抽出的数会向左对齐。</li></ol><p>因此我们可以得到以下过程：</p><blockquote><p>[1, 3, 5, 4, 2] -&gt; [1, #, #, #, 2] -&gt; [1, 2, #, #, #] -&gt; [1,2, 3, 4, 5]</p></blockquote><p>我们可以从 1 出发寻找一个上升序列，根据第 2点这个上升序列我们是不需要排序的，将其余的部分通过若干次排序即可。通过反证法可以得出从1 出发的必要性。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp == cnt) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = n - cnt + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; res/k + (res%k != <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>给出一个数组。你需要求出按顺序对其进行一系列区间操作后最终所得的数组。</p><p>操作有三种:</p><ol type="1"><li>将下标在 L 到 R 之间的元素全部或上 X</li><li>将下标在 L 到 R 之间的元素全部与上 X</li><li>将下标在 L 到 R 之间的元素全部设为 X</li></ol><p>经过一系列操作后输出数组</p><h3 id="解题方法-2">解题方法</h3><p>在笔试过程中看到这道题以及数据范围的第一反应是线段树或者差分的方法，调了半天后没调出来，后来暴力过了82% 就很抽象。赛后看到牛客上基本上都是暴力解法，甚至还有暴力通过 100%的。先贴一个 82% 的暴力解法，后面等调出来线段树再分享一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 上个读写挂，试图加速</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ll</span><span class="hljs-params">(m)</span>, <span class="hljs-title">rr</span><span class="hljs-params">(m)</span>, <span class="hljs-title">xx</span><span class="hljs-params">(m)</span></span>;<br>    string sym;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; ll[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; rr[i];<br>    &#125;<br>    cin &gt;&gt; sym;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; xx[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> l = ll[i] - <span class="hljs-number">1</span>, r = rr[i] - <span class="hljs-number">1</span>, x = xx[i];<br>        <span class="hljs-type">char</span> ch = sym[i];<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++) &#123;<br>                nums[j] = x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;|&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++) &#123;<br>                nums[j] = nums[j] | x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++) &#123;<br>                nums[j] = nums[j] &amp; x;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nums[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一些常见的 Java 面试问题</title>
    <link href="/2023/03/23/Java/%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/23/Java/%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="语言本身">语言本身</h1><h2 id="jdk-和-jre-有什么区别">JDK 和 JRE 有什么区别？</h2><ul><li>JDK 是整个 Java 的核心，包括 Java 运行环境（Java RuntimeEnvirnment，简称 JRE），Java 工具（比如 javac、java、javap 等等），以及Java 基础类库（比如 rt.jar）；<ul><li>rt.jar 是 Java 的基础类库，包含 lang, util, math, time, awt,applet等基础包</li></ul></li><li>JRE 是 Java 程序的运行环境；</li><li>JDK 包含了同版本的 JRE ，除此之外还有编译器和其他工具。</li></ul><h2 id="c-的析构函数为什么要设计成虚函数">C++的析构函数为什么要设计成虚函数？</h2><blockquote><p>我也不知道我面的是 Java 岗为什么要问我 C++</p></blockquote><ul><li>如果一个类的析构函数是虚函数，那么由它派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数之后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作</li><li>当使用多态特性，让基类指针指向派生类对象时，<strong>如果析构函数不是虚函数</strong>，通过基类指针销毁派生类对象时，会调用静态绑定的析构函数，也就是基类的析构函数，从而只能销毁属于基类的元素，导致派生类析构不完全，<strong>程序就会出现资源泄露或未定义行为</strong>。</li><li>当派生类中不存在使用动态资源或其他自定义析构行为时，可以不写为虚析构函数，来提高程序效率。但<strong>为了程序的可扩展性和健壮性</strong>，在使用多态特性时，一般都建议将基类的析构函数定义为虚函数。</li></ul><h1 id="关于并发编程">关于并发编程</h1><h2 id="volatile-关键字有什么作用能够保证线程安全吗">volatile关键字有什么作用？能够保证线程安全吗？</h2><ul><li>在 Java 中，volatile关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li>volatile 关键字其实并非是 Java 语言特有的，在 C语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用volatile修饰，这就指示编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性</strong>。synchronized关键字两者都能保证。</li><li>volatile关键字除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM的指令重排序</strong>。如果我们将变量声明为 volatile，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障的方式来禁止指令重排序。</li></ul><h1 id="关于对象">关于对象</h1><h2 id="object-类">Object 类</h2><p>Object 类是一个特殊的类，是所有类的父类。它包含十一个方法：</p><ul><li>getclass：获取 Class 对象</li><li>hashcode：获取 hashcode 值，配合散列容器使用，包括HashMap、hashTable、HashSet等</li><li>equals</li><li>clone：返回一个 clone 的对象</li><li>toString</li><li>notify：唤醒一个在此对象监视器上等待的线程</li><li>notifyall：唤醒所有在此对象监视器上等待的线程</li><li>wait：暂停线程执行，并且释放锁</li><li>finalize：垃圾回收时触发，一般不用</li></ul><h2 id="unsafe-类">Unsafe 类</h2><p>Unsafe用于执行一些低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。</p><p>Unsafe 类中的方法都是依赖于本地方法实现的，Java只是声明头方法，具体实现交给本地代码。</p><p>出于安全性考虑，Unsafe类只能由启动类加载器加载的类才能够调用其方法，可以借助反射来获取一个实例化完成的单例对象<code>theUnsafe</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">reflectGetUnsafe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>      field.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      log.error(e.getMessage(), e);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="关于容器">关于容器</h1><h2 id="hashmap-相关">Hashmap 相关</h2><h3 id="hashmap-结构">Hashmap 结构</h3><ul><li>JDK 1.7 之前是数组 + 链表</li><li>JDK 1.8 及之后是 数组 + 链表/红黑树<ul><li>当数组大小 &lt; 64时，通过扩容来保证稀疏，加载因子默认0.75，每次扩容翻倍，初始容量 16</li><li>当数组大小 &gt;= 64 且链表长度 &gt; 8 时，转为红黑树，链表长度 &lt;=6时退化回链表</li></ul></li></ul><h3 id="hashmap-是线程安全的吗">Hashmap 是线程安全的吗？</h3><p>Hashmap 并不是线程安全的，在并发环境下，Hashmap可能会出现以下问题：</p><ul><li>数据覆盖<ul><li>多线程对同一个 Hashmap进行操作时，计算出来的索引相同可能会导致后面的线程把前一个线程数据覆盖</li></ul></li><li>读出为 null<ul><li>当线程 1 进行 put 时发现需要扩容，需要 new 一个新的表，线程 2此时进行 get 就可能会读到空值</li></ul></li><li>死循环<ul><li>JDK 1.7 中， Hashmap 的扩容使用的是头插法，可能会出现<ahref="https://blog.csdn.net/weixin_42396189/article/details/128830923">环形链表</a>，当请求一个不存在的key 时产生死循环。</li><li>JDK 1.8及之后采用的是尾插法，不会导致死循环。</li></ul></li></ul><h3 id="如何保证-hashmap-线程安全呢">如何保证 Hashmap 线程安全呢？</h3><p>Java 提供了三种保证线程安全的哈希方法，分别是 HashTable、Collections.synchronizedMap 以及 ConcurrentHashMap。</p><ul><li>HashTable：通过给每一个方法加锁 (synchronized)来保证互斥，效果比较差，一般不推荐使用。</li><li>Collections.synchronizedMap：通过 Collection 对已有的一个 Hashmap进行包装，内部使用一个 mutex 对象，使用 synchronized对其加锁保证互斥，和 HashTable 原理差不多，性能也比较差。<ul><li><code>Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Object&gt;());</code></li></ul></li><li>ConcurrentHashMap：推荐使用</li></ul><h4id="concurrenthashmap如何保证线程安全呢">ConcurrentHashMap如何保证线程安全呢？</h4><ul><li>JDK 1.7及其之前是 Segment数组 + HashEntry数组 + 链表，其中 Segment继承了 ReentrantLock，相当于对每个 Segment 加锁，每个 Segment 类似一个Hashmap 结构<ul><li>扩容每次翻倍，但元素的新位置要么和之前相同，要么为<code>原idx + 原容量</code></li><li>CAS 初始化 Segment</li></ul></li><li>JDK 1.8及其之后是 Node 数组 + 链表/红黑树<ul><li>put 时定位到目标位置，如果为空 CAS 写入，反之 synchronized 写入</li><li><strong>多线程</strong>扩容，put 时发现正在扩容，就和它一起扩容</li></ul></li></ul><h1 id="一些工具">一些工具</h1><h2 id="如何检查内存泄漏问题">如何检查内存泄漏问题</h2><p>在 java 的 bin 文件夹下有个 jvisualvm.exe 工具，使用它可以检测到 java堆内存的变化情况，借此可以来检测使用 java的程序是否存在内存泄漏问题。</p><h2 id="如何检查死锁问题">如何检查死锁问题</h2><p>可以使用 Java 的 jstack 工具，它是 jdk自带的线程堆栈分析工具。查看线程的函数调用过程，多次对比结果，确认哪几个线程一直没有变化，且是因为在等待锁，那么大概率是由于死锁问题导致的。</p><h1 id="关于操作系统">关于操作系统</h1><h2 id="进程与线程">进程与线程</h2><h3 id="线程的类型">线程的类型</h3><ul><li>用户线程<ul><li>基于用户态的线程管理库来实现的，那么线程控制块（Thread ControlBlock, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB的，它只能看到整个进程的 PCB</li></ul></li><li>内核线程<ul><li>由操作系统管理的，线程对应的 TCB自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</li></ul></li><li>轻量级进程<ul><li>内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP是由内核管理并像普通进程一样被调度。</li></ul></li></ul><h3 id="进程上下文切换保存了什么">进程上下文切换保存了什么？</h3><p>在操作系统中，是用<strong>进程控制块</strong>（process controlblock，PCB）数据结构来描述进程的。</p><p>PCB 主要包含以下信息：</p><ul><li>进程描述信息：进程标识符标识进程，用户标识符标识进程所属用户</li><li>进程控制和管理信息：当前进程的状态（五态），进程的优先级</li><li>资源清单：有关的内存地址空间或虚拟地址空间信息，打开的文件和使用的I/O 设备信息</li><li>CPU相关：各个寄存器的值</li></ul><p><strong>当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB中</strong>。</p><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><p>每个 PCB根据其对应进程的不同状态，通过链表的形式组织在一起，分别为就绪队列、阻塞队列等。</p><h3 id="线程上下文切换保存了什么">线程上下文切换保存了什么？</h3><p>当进程拥有多个线程时，这些线程会共享<strong>相同的虚拟内存</strong>和<strong>全局变量</strong>等资源，这些资源在上下文切换时是不需要修改的；</p><p>除此之外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><p>线程的上下文切换分两种情况：</p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li></ul><h3 id="java-线程和底层操作系统线程是一一对应的吗">Java线程和底层操作系统线程是一一对应的吗？</h3><p>首先，在 <strong>JDK 1.2 之前</strong>，Java线程是<strong>用户线程</strong>实现的；<strong>JDK 1.2及其之后</strong>，线程模型变为基于<strong>操作系统原生线程</strong>模型来实现。</p><p>现在的JDK线程模型基于操作系统原生线程，所以模型依赖于操作系统对线程的支持，另外Windows 和 Linux 系统提供的线程模型就是一对一的。</p><h3 id="linux-中如何查看线程相关信息">Linux中如何查看线程相关信息？</h3><ol type="1"><li>top -H<ul><li>加上 -H 这个选项，top 的每一行就不是显示一个进程，而是一个线程</li></ul></li><li>ps -XH<ul><li>可以查看所有存在的线程，也可以使用 grep 作进一步的过滤</li></ul></li><li>ps -mq PID<ul><li>可以看到指定的进程产生的线程数目</li></ul></li><li>cat /proc/{pid}/status</li><li>pstree -p<ul><li>打印所有进程及其线程</li></ul></li></ol><h2 id="基于操作系统讲一下堆和栈">基于操作系统讲一下堆和栈？</h2><p>一开始听错了，讲了半天什么是栈结构，什么是堆结构，优先队列都整出来了。</p><p>后来连忙重新组织了一下，乱讲一通堆区和栈区的区别。</p><p>一个由 C/C++ 编译的程序占用的内存分为以下几个部分：</p><ol type="1"><li>栈区（stack）——由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</li><li>堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS回收。分配方式倒是类似于链表；</li><li>全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；</li><li>文字常量区 —— 常量字符串就是放在这里的。程序结束后由系统释放；</li><li>程序代码区 —— 存放函数体的二进制代码。</li></ol><p>操作系统中有什么具体的区别？</p><ol type="1"><li>栈由高地址向低地址扩展，堆是由低地址向高地址扩展；</li><li>用户用 new 或者 malloc申请的空间都放在堆区，一些局部变量之类的放在栈帧内；</li><li>堆有很多种空间分配方法（最佳适应算法、最坏适应算法、首次适应算法、循环首次适应算法、），栈没有这么多，硬分配，空间不够就报错；</li><li>栈申请效率高，堆相比较有点慢</li></ol><h1 id="关于数据结构">关于数据结构</h1><h2 id="为什么快速排序是-onlogn-是归并思想还是-dp-思想">为什么快速排序是O(nlogn) ？是归并思想还是 dp 思想？</h2><p>其实快排并不是严格的 <spanclass="math inline">\(O(nlogn)\)</span>，它的时间复杂度在 <spanclass="math inline">\(O(nlogn) - O(n^2)\)</span> 之间</p><ul><li>最坏的情况下，每次哨兵都只能将长度为 <spanclass="math inline">\(n\)</span> 的数组分成 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(n-1\)</span> 两部分，这样的话递归栈的深度就是<span class="math inline">\(O(n)\)</span> ，退化到 <spanclass="math inline">\(O(n^2)\)</span></li><li>最好的情况下，每次哨兵将数组平分，这样的递归栈深度就是 <spanclass="math inline">\(O(logn)\)</span> ，时间复杂度为 <spanclass="math inline">\(O(nlogn)\)</span></li><li>其他情况就在这俩中间</li></ul><p>那问题来了是归并还是 dp 呢？</p><p>其实我觉得这个问题很奇怪，因为归并和 DP不是一个维度的问题，你可以说是贪心还是DP？或者说是不是归并思想？事实上，快排的本质和归并排序思路差不多，可以看作是归并，只是一个自顶向下一个自底向上。</p><h1 id="关于计算机网络">关于计算机网络</h1><h2 id="https-会加密-url-吗">HTTPS 会加密 URL 吗？</h2><p>因为 URL 的信息都是保存在 HTTP Header 中的，而 HTTPS 是会对 HTTPHeader + HTTP Body 整个加密的，所以 URL 自然是会被加密的。</p><blockquote><p>HTTP/1.1 使用明文的形式在请求的第一行注明 URL，HTTP/2 使用伪头部(pseudo-header) 替换了请求行，伪头部一般在名称的开头使用冒号表示。</p></blockquote><p>但是 <strong>HTTPS 可以在 TLS握手阶段看到域名信息</strong>，无法实现对域名的隐藏。</p><h1 id="关于数据库">关于数据库</h1><h2 id="mysql">MySQL</h2><h3 id="杂项">杂项</h3><ul><li>MySQL 中 InnoDB 页的大小默认是 16k</li></ul><h3 id="mysql为什么采用-b-树">MySQL为什么采用 B+ 树？</h3><blockquote><p>作者：我啊 链接：https://leetcode.cn/circle/discuss/uRUsKF/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>哈希范围查询很慢。链表要遍历。剩下的就是树。广为人知的，二叉搜索树，AVL树，红黑树，B 树等等。</p><ul><li>二叉搜索树会退化为链表，层数可能也会很多</li><li>AVL树层数依然过多</li><li>红黑树只是优化了插入、更新，弱化了平衡，在更新和搜索中取了折中。但层数过多的问题没有解决</li><li>B 树，层数变少了，但如果访问下一页需要回到父节点到兄弟节点</li><li>B+ 树，将叶子节点用链表串联起来了，子节点中包含了父节点的信息——解决B树访问下一页需要先回到父节点的问题；同时非叶子节点不保存具体的数据，而只保存关键字的索引，具体数据保存在叶子结点中——相对于B树，减少了非叶子结点（索引）的数据量，所以相同的内存空间能保存更多的索引，从而减少io 次数。</li></ul><h3 id="事务的实现">事务的实现</h3><blockquote><p>作者：我啊 链接：https://leetcode.cn/circle/discuss/uRUsKF/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性(ACID)属性，只有这样才能成为一个事务。事务一般都是与数据库打交道的操作。</p><p><strong>事务的 ACID 特性是由关系数据库管理系统来实现的</strong>。</p><p>DBMS 采用日志来保证事务的原子性、一致性和持久性。MySQL 通过预写式日志undo log、redolog，如果整个事务执行的过程系统崩溃或者断电了，在系统重启的时候，恢复机制会将undo log中未提交的事务进行回滚，保证事务的原子性；而 redo log中已提交的事务重做，保证事务的持久性。</p><p>DBMS采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p><h3 id="mysql-主从复制">MySQL 主从复制</h3><blockquote><p>作者：我啊 链接：https://leetcode.cn/circle/discuss/uRUsKF/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>主从复制是指将主数据库（Master）中的 DDL 和 DML操作通过二进制日志传输到从数据库（Slave）上，然后将这些日志重新执行（重做），从而使得从数据库的数据与主数据库保持一致。MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><h4 id="作用">作用</h4><ul><li>当主数据库出现问题时，可以切换到从数据库；</li><li>可以进行数据库层面的读写分离，实现负载均衡；</li><li>可以在从数据库上进行实时数据备份。</li></ul><h4 id="基本原理">基本原理</h4><p>MySQL的主从复制是一个异步的复制过程（一般情况下感觉是实时的），数据将从一个MySQL 数据库（Master）复制到另外一个 MySQL 数据库（Slave），在 Master 与Slave之间实现整个主从复制的过程是由三个线程参与完成的，其中有两个线程（SQL线程和 I/O 线程）在 Slave 端，另外一个线程（ I/O 线程）在 Master端。</p><ul><li>Master 端：打开二进制日志（binlog ）记录功能 ——记录下所有改变了数据库数据的语句，放进 Master 的 binlog 中；</li><li>Slave 端：开启一个 I/O 线程 —— 负责从 Master上拉取 binlog内容，放进自己的中继日志（Relay log）中；</li><li>Slave 端：SQL 执行线程 —— 读取 Relay log，并顺序执行该日志中的 SQL事件。</li></ul><h4 id="三种模式">三种模式</h4><ol type="1"><li><strong>同步复制</strong>：所有从机接收到binlog，才认为事务提交成功；<ul><li>最安全，但性能差，一般不用</li></ul></li><li><strong>异步复制</strong>：只要主机事务提交成功，就对客户端返回成功；后台线程异步把binlog 同步给从机，然后从机回放；<ul><li>最快，但可能丢失数据；</li></ul></li><li><strong>半同步复制</strong>：部分从机接收到binlog，才对客户端返回成功</li></ol><p>一般做法是牺牲一致性换取高可用；数据丢失后，人工修复。为了解决主从复制延迟太大，切换到从机后数据丢失太多的问题，采用了并行回放策略。</p><ol type="1"><li>按数据维度并行：两个事务没有操作交集可以并行；</li><li>按事务提交顺序并行：同时提交成功的事务是可以并行的）</li></ol><h1 id="关于设计题">关于设计题</h1><h2 id="设计一个短链服务">设计一个短链服务</h2><p>短链服务总的来说，就做两件事：</p><ul><li>将长链接变为短链接，当然是越短越好</li><li>用户点击短链接的时候，实现自动跳转到原来的长链接</li></ul><h3 id="长链如何转短链">长链如何转短链？</h3><h4 id="方法1hash">方法1：hash</h4><p>对长链进行 hash ，常见的 hash 算法有：</p><ul><li>MurmurHash算法：非加密型哈希函数，Redis，Memcached，Cassandra，HBase，Lucene都在用这种算法</li></ul><p>但是会出现一个问题：hash 碰撞怎么办？</p><ul><li>加点特殊字符，直到没有碰撞</li></ul><h4 id="方法2统一发号保证全局唯一">方法2：统一发号保证全局唯一</h4><p>有以下几种解决思路：</p><ul><li>Redis自增：Redis性能好，单机就能支撑10W+请求，如果作为发号器，需要考虑Redis持久化和灾备。</li><li>MySQL自增主键：这种方案和Redis的方案类似，是利用数据库自增主键的提醒实现，保证ID不重复且连续自动创建。</li><li>Snowflake：这是一种目前应用比较广的ID序列生成算法，美团的Leaf是对这种算法的封装升级服务。但是这个算法依赖于服务器时钟，如果有时钟回拨，可能会有ID冲突。<ul><li>生成全局唯一 ID 的长度为 64 位</li><li>最高 1 位固定值 0，因为生成的 id 是正整数，如果是 1就是负数了。</li><li>接下来 41位存储毫秒级时间戳，2^41/(1000<em>60</em>60<em>24</em>365)=69，大概可以使用69 年。</li><li>再接下 10 位存储机器码，包括 5 位 datacenterId 和 5 位workerId。最多可以部署 2^10 = 1024 台机器。</li><li>最后 12位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成2^12=4096 个不重复 id。</li></ul></li><li>。。。</li></ul><p>出问题了，直接将自增的 ID放上去当短链会不会不安全？怎么保证安全呢？</p><ul><li>可以把数字换成字母，a-z，A-Z，混淆一下</li></ul><p>但又好像需要考虑一个问题，对于同一个原始链接，应该返回相同的短链还是不同的短链？</p><ul><li>可以根据其他信息（用户信息、位置信息）等来判断是不是相同的生成请求</li></ul><h3 id="短链怎么存呢">短链怎么存呢？</h3><p>可以直接扔到 MySQL 或者 NoSQL 里，然后接受请求，解析短链并转发</p><p>当然考虑到并发量的话，分布式、分库分表什么的就可以都上来搞一下</p><h3 id="业务逻辑呢">业务逻辑呢？</h3><p>主要逻辑如下：</p><ol type="1"><li>用户使用短链请求</li><li>服务器根据短链找到对应的长链</li><li>进行请求的转发</li><li>结束调用</li></ol><p>有没有什么优化呢？数据库被请求打穿了怎么办？</p><p>上布隆过滤器，上缓存，。。。。</p><h1 id="关于智力题">关于智力题</h1><h2 id="一天-24-小时时针和分针重合多少次">一天 24小时，时针和分针重合多少次？</h2><p>其实这个题有个很简单的解法，一天 24 个小时分针转 24圈，时针转两圈，所以分针要超过时针的圈数是 24 - 2 = 22 圈。</p><p>当然也可以硬算，分针每分钟转 1 格，时针每分钟转 1/12格，因此每次相遇要花费的时间是 <span class="math inline">\(\frac{60}{1 -\frac{1}{12}} = \frac{720}{11}\)</span> 分钟，一天共有 24 * 60 = 1440分钟，直接相除可以得到 22 圈。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里巴巴0322开发岗笔试总结</title>
    <link href="/2023/03/22/Algorithm/InternJob/Alibaba0322Dev/"/>
    <url>/2023/03/22/Algorithm/InternJob/Alibaba0322Dev/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>本周的阿里笔试感觉比上周的要简单，可惜阿里每人只给一次笔试机会，这次算是场外写题当练习了。</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>给你一个字符串，里面仅包含'A', 'a', 'L', 'l', 'I','i'四种字母，询问你是否整体上是ALI这样的排列，不区分大小写。</p><p>例如 <code>AaAaallLLlLiIiIiI</code> 这样就是满足要求的，而<code>AL</code> 这种就输出 No。</p><h3 id="解题方法">解题方法</h3><p>直接进行模拟即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">bool</span> one = <span class="hljs-literal">false</span>, two = <span class="hljs-literal">false</span>, three = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; <span class="hljs-built_in">tolower</span>(s[i++]) == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            one = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; <span class="hljs-built_in">tolower</span>(s[i++]) == <span class="hljs-string">&#x27;l&#x27;</span>) &#123;<br>            two = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; <span class="hljs-built_in">tolower</span>(s[i++]) == <span class="hljs-string">&#x27;i&#x27;</span>) &#123;<br>            three = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (one &amp;&amp; two &amp;&amp; three &amp;&amp; i == len) &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>给你一个仅包含 01 的字符串，每次可以反转相邻的两位，将 0 反转成 1 ，1反转成 0 ，问最大化 1 的个数的最小次数。</p><p>例如 <code>0101</code> 可以通过以下步骤完成：</p><p><code>0101</code> - &gt; <code>0011</code> - &gt;<code>1111</code></p><h3 id="解题方法-1">解题方法</h3><p>思维题。通过尝试可以发现两个 0 是可以通过反转他们下标差的次数来变成 1的，如题目描述中那样。因此就可以统计出所有 0出现的下标，将其从左到右或者从右到左相互匹配转换成 1 ，当然对于奇数个 0最终还是会有一个无法完成转换。</p><p>代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; pos;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            pos.<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> l_ans = <span class="hljs-number">0</span>, r_ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从左到右匹配</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; pos.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        l_ans += pos[i] - pos[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 从右到左匹配</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>) &#123;<br>        r_ans += pos[i + <span class="hljs-number">1</span>] - pos[i];<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">min</span>(l_ans, r_ans)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>//todo</p><h3 id="解题方法-2">解题方法</h3><p>//todo</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>米哈游0319笔试总结</title>
    <link href="/2023/03/19/Algorithm/InternJob/Mihoyo0319/"/>
    <url>/2023/03/19/Algorithm/InternJob/Mihoyo0319/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>题目信息获取来源https://www.nowcoder.com/discuss/467108267630534656，仅交流学习，如有侵权或涉密请联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目内容">题目内容</h3><p>米小游拿到了一个矩阵，矩阵上有一格有一个颜色，为红色( R )。绿色( G)和蓝色( B )这三种颜色的一种。</p><p>然而米小游是蓝绿色盲，她无法分游蓝色和绿色，所以在米小游眼里看来，这个矩阵只有两种颜色，因为蓝色和绿色在她眼里是一种颜色。</p><p>米小游会把相同颜色的部分看成是一个连通块。请注意，这里的连通划是上下左右四连通的。</p><p>由于色盲的原因，米小游自己看到的连通块数量可能比真实的连通块数量少。</p><p>你可以帮米小游计算连通块少了多少吗？</p><h3 id="输入描述">输入描述</h3><p>第一行输入两个正整数 n 和 m ，代表矩阵的行数和列数。</p><p>接下来的 n 行，每行输入一个长度为 m 的，仅包含 R 、G 、B三种颜色的字符串，代表米小游拿到的矩阵。</p><p><span class="math inline">\(1 \le n, m \le 1000\)</span></p><h3 id="输出描述">输出描述</h3><p>一个整数，代表米小游视角里比真实情况少的连通块数量。</p><h3 id="样例">样例</h3><h4 id="输入">输入</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">2 6<br>RRGGBB<br>RGBGRR<br></code></pre></td></tr></table></figure><h4 id="输出">输出</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">3<br></code></pre></td></tr></table></figure><h3 id="解题方法">解题方法</h3><p>模拟题，只需要进行两遍 DFS 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> offset[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0x3f3f3f3f</span>));<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visit</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                g[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;G&#x27;</span>) &#123;<br>                g[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                g[i][j] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> isreal) &#123;<br>        visit[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nx = x + offset[i][<span class="hljs-number">0</span>], ny = y + offset[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m || visit[nx][ny]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isreal &amp;&amp; g[nx][ny] != g[x][y] || <br>                    !isreal &amp;&amp; (g[nx][ny] == <span class="hljs-number">0</span> &amp;&amp; g[x][y] != <span class="hljs-number">0</span> || g[nx][ny] != <span class="hljs-number">0</span> &amp;&amp; g[x][y] == <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(nx, ny, isreal);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">int</span> real_ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i][j]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            real_ans++;<br>            <span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">fill</span>(visit[i].<span class="hljs-built_in">begin</span>(), visit[i].<span class="hljs-built_in">end</span>(), <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> fake_ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i][j]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            fake_ans++;<br>            <span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; real_ans - fake_ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目内容-1">题目内容</h3><p>米小游拿到了一个字符串 s 。她可以进行任意次以下两种操作：</p><p>删除 s 的一个 "mhy" 子序列。 添加一个 "mhy" 子序列在 s 上。例如，给定 s 为 "mhbdy" ，米小游进行一次操作后可以使 s 变成 "bd"，或者变成 "mhmbhdyy" 。</p><p>米小游想知道，经过若干次操作后 s 是否可以变成 t ？</p><p>注：子序列在原串中的顺序也是从左到右，但可以不连续。</p><h3 id="输入描述-1">输入描述</h3><p>第一行输入一个正整数 q ，代表询问的次数。</p><p>接下来每两行为一次询问：每行均为一个字符串，分别代表 s 和 t 。</p><p><span class="math inline">\(1 \le q \le {10^3}\)</span></p><p>字符串的长度均不超过 <spanclass="math inline">\({10^3}\)</span>。</p><h3 id="输出描述-1">输出描述</h3><p>输出 q 行，每行输入一行答案。若可以使 s 变成 t ，则输出 "Yes"。否则输出 "No" 。</p><h3 id="样例-1">样例</h3><h4 id="输入-1">输入</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">3<br>mhbdy<br>bd<br>mhbdy<br>mhmbhdyy<br>mhy<br>abc<br></code></pre></td></tr></table></figure><h4 id="输出-1">输出</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">Yes<br>Yes<br>No<br></code></pre></td></tr></table></figure><h3 id="解题方法-1">解题方法</h3><p><code>yhm-&gt;mhyhmy-&gt;mhyhmy-&gt;hym</code></p><p>通过上例可以看出插入的序列顺序无关，可互相转换，因此只需要统计 hmy的字母个数和剩余序列即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        string s, target;<br>        cin&gt;&gt;s&gt;&gt;target;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s_cnts</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">target_cnts</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;<br>        string s_res = <span class="hljs-string">&quot;&quot;</span>, target_res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;m&#x27;</span>) &#123;<br>                s_cnts[<span class="hljs-number">0</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;h&#x27;</span>) &#123;<br>                s_cnts[<span class="hljs-number">1</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<br>                s_cnts[<span class="hljs-number">2</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                s_res.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : target) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;m&#x27;</span>) &#123;<br>                target_cnts[<span class="hljs-number">0</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;h&#x27;</span>) &#123;<br>                target_cnts[<span class="hljs-number">1</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<br>                target_cnts[<span class="hljs-number">2</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                target_res.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s_res == target_res) &#123;<br>            <span class="hljs-keyword">if</span> (s_cnts[<span class="hljs-number">0</span>] - target_cnts[<span class="hljs-number">0</span>] == s_cnts[<span class="hljs-number">1</span>] - target_cnts[<span class="hljs-number">1</span>] &amp;&amp; <br>                    s_cnts[<span class="hljs-number">1</span>] - target_cnts[<span class="hljs-number">1</span>] == s_cnts[<span class="hljs-number">2</span>] - target_cnts[<span class="hljs-number">2</span>]) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目内容-2">题目内容</h3><p>米小游拿到了一个集合（集合中元素互不相等）。</p><p>她想知道，该集合有多少个元素数量大于 1的子集，满足子集内的元素两两之间互为倍数关系？</p><p>由于数量可能过大，请对 1e9 + 7 取模。</p><h3 id="输入描述-2">输入描述</h3><p>第一行输入一个正整数 n ，代表集合大小。</p><p>第二行输入 n 个正整数 <spanclass="math inline">\(a_i\)</span>，代表集合的元素。</p><p><span class="math inline">\(1 \le n \le {10}^5\)</span></p><p><span class="math inline">\(1 \le a_i \le {10}^6\)</span></p><h3 id="输出描述-2">输出描述</h3><p>一个整数，代表满足题意的子集数量对 对 1e9 + 7 取模的值。</p><h3 id="样例-2">样例</h3><h4 id="输入-2">输入</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">5<br>1 2 3 4 5<br></code></pre></td></tr></table></figure><h4 id="输出-2">输出</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">6<br></code></pre></td></tr></table></figure><h3 id="解题方法-2">解题方法</h3><p>之前在Leetcode上遇到过类似的题目<ahref="https://leetcode.cn/problems/largest-divisible-subset/">368.最大整除子集</a>，所以最开始想到一种时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span> 的 DP 做法，其中 <spanclass="math inline">\(dp[i]\)</span> 表示以第 i个元素结尾的整除子集元素数量，对于每一个这样的集合，其包含的合法子集个数为<span class="math inline">\({2}^{dp[i] - 1} -1\)</span>，借助快速幂可以求出答案。</p><p>但是本题的数据范围要求 <span class="math inline">\(O(n^2)\)</span>以下，所以该做法只通过了 20% 的弱数据。本题的正解也是 DP 的做法，不过<span class="math inline">\(dp[i]\)</span> 表示包含第 i个元素的合法子集个数，可以通过枚举第 i个元素的所有因子进行状态转移，时间复杂度可以优化到 <spanclass="math inline">\(O(n\sqrt{n})\)</span> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(maxn, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin&gt;&gt;nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        pos[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> cur = nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= cur; j++) &#123;<br>            <span class="hljs-keyword">if</span> (cur % j == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (pos[cur/j] != <span class="hljs-number">-1</span> &amp;&amp; cur/j != j) &#123; <span class="hljs-comment">// 保证 nums[i] 的平方根不会统计两次</span><br>                    dp[i] += dp[pos[cur/j]];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pos[j] != <span class="hljs-number">-1</span>) &#123;<br>                    dp[i] += dp[pos[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans = (ans + dp[i])%mod;<br>        dp[i]++; <span class="hljs-comment">// 加入 &#123;nums[i]&#125; 这种情况，为后面的元素做转移</span><br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统基础知识</title>
    <link href="/2023/03/17/DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/17/DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="理论知识">理论知识</h1><p>如果让你设计一个分布式系统，你预见到什么问题？</p><ul><li>保证节点高可用（节点故障）</li><li>数据的一致性</li><li>通讯异常</li><li>网络分区</li></ul><h2 id="cap-理论">CAP 理论</h2><ul><li><strong>可用性(Availability)</strong>，代表服务一直处于正常响应时间内的可用状态。</li><li><strong>一致性 (Consistency)</strong>，数据一致性分为三种<ul><li><strong>强一致性</strong>：更新后的数据需要被后续的访问都能请求到；</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态；</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ul></li><li><strong>分区容错性 (Partitiontolerance)</strong>，指在某分区宕机或网络原因请求不到情况下，仍然能保证系统的可用性和数据一致性。</li></ul><blockquote><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A的选择。也就是说分区容错性（Partitiontolerance）我们是必须要实现的。简而言之就是：CAP 理论中分区容错性 P是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><h2 id="base-理论">BASE 理论</h2><p>BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，可以理解为是对CAP 中 AP 方案的一个补充。</p><ul><li><strong>基本可用 (BasicAvailable)</strong>：当分布式系统处在一个不可预知的故障状态时，依然可以向外界提供服务，只是会损失一部分<strong>时间</strong>或<strong>系统功能</strong>上的可用性</li><li><strong>软状态(Soft-state)</strong>：允许存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li><li><strong>最终一致性 (EventuallyConsistent)</strong>：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性<ul><li>读时修复：在读取数据时，检测数据的不一致，进行修复。</li><li>写时修复：在写入数据，检测数据的不一致时，进行修复。<strong>（较为推荐）</strong></li><li>异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul></li></ul><h2 id="paxos-算法">Paxos 算法</h2><p>Paxos 算法分为两个部分，分别为 <strong>Basic Paxos 算法</strong>和<strong>Multi-Paxos 思想</strong>，是由兰伯特在 1990年提出了一种<strong>分布式系统共识算法</strong>。Raft 算法、ZAB 协议、Fast Paxos 算法都是基于 Paxos 算法改进而来。</p><h3 id="basic-paxos-算法">Basic Paxos 算法</h3><p>Basic Paxos 中存在 3 个重要的角色：</p><ol type="1"><li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号(Proposal ID) 和提议的值 (Value)。</li><li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li><li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li></ol><p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的Acceptor 接受。这样的话，Basic Paxos算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p><h3 id="multi-paxos-思想">Multi Paxos 思想</h3><p>Basic Paxos 算法的仅能就单个值达成共识， Multi-Paxos 通过多个 BasicPaxos 实例就一系列值达成共识。一种应用于工业界的 Multi-Paxos 变种——Raft协议，其简化了 Multi-Paxos的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft算法。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用OpenSSL生成TLS配置文件</title>
    <link href="/2023/03/17/OpenSSL/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90TLS%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/17/OpenSSL/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90TLS%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>最近在搭建SDP项目的通信模块时，需要建立控制器和客户端的双向TLS加密，这部分采用OpenSSL生成密钥和证书的方式实现。本篇文章用于记录OpenSSL的简易使用方法，通过本文可以快速地生成Netty可用的密钥证书。</p><h2 id="构建步骤">构建步骤</h2><p>本文的构建环境为 Ubuntu 22.04，其自带了OpenSSL，其他平台用户可能需要首先安装 OpenSSL，具体步骤如下：</p><ol type="1"><li>生成CA的私钥 <code>ca.key</code> 和自签名证书<code>ca.crt</code>，用于 SSL/TLS 通信的证书认证，当前自签名证书有效期为365 天，即一年 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout ca.key -out ca.crt<br></code></pre></td></tr></table></figure></li><li>生成服务器（即Controller）的私钥<code>server.key</code>，证书签名请求 <code>server.csr</code>以及签名证书 <code>server.crt</code> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">server.key 为密钥长度为 2048 位的 RSA 私钥，证书有效期为 365 天</span><br>openssl genrsa -out server.key 2048<br>openssl req -new -key server.key -out server.csr<br>openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -out server.crt<br></code></pre></td></tr></table></figure></li><li>生成客户端（即Client）的私钥 <code>client.key</code>，证书签名请求<code>client.csr</code> 以及签名证书 <code>client.crt</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">同上，证书有效期为 31 天</span><br>openssl genrsa -out client.key 2048<br>openssl req -new -key client.key -out client.csr<br>openssl x509 -req -days 31 -in client.csr -CA ca.crt -CAkey ca.key -out client.crt<br></code></pre></td></tr></table></figure></li><li>转换为 netty 可以识别的密钥格式 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl pkcs8 -topk8 -inform PEM -in server.key -outform PEM -nocrypt -out server_pkcs8.key<br>openssl pkcs8 -topk8 -inform PEM -in client.key -outform PEM -nocrypt -out client_pkcs8.key<br></code></pre></td></tr></table></figure></li><li>*CA可以通过以下指令去核实证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl verify -purpose sslserver -CAfile ca.crt server.crt<br>openssl verify -purpose sslclient -CAfile ca.crt client.crt<br></code></pre></td></tr></table></figure></li></ol><p>至此我们在当前目录下可以得到以下文件：</p><blockquote><p>ca.key ca.crt ca.srl client.crt client.key client.csrclient_pkcs8.key server.crt server.key server.csr server_pkcs8.key</p></blockquote><p>其中 <code>*_pkcs8.key</code> 文件就是 Netty 配置 TLS 时能够识别的PKCS8 密钥格式。</p><h2 id="可能遇到的问题">可能遇到的问题</h2><ul><li>CA签发证书时提示如下，是指我们在签发证书时需要指定一个生成证书的序列号，可以在签发前<code>echo "01" &gt; ca.srl</code> 避免提示 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -out server.crt</span><br>Signature ok<br>subject=C = CN, ST = JiangSu, L = Nanjing, O = SEU, OU = CyberScience, CN = 6209, emailAddress = ShijieQ@outlook.com<br>Getting CA Private Key<br>ca.srl: No such file or directory<br>139954133366592:error:06067099:digital envelope routines:EVP_PKEY_copy_parameters:different parameters:crypto/evp/p_lib.c:93:<br>139954133366592:error:02001002:system library:fopen:No such file or directory:crypto/bio/bss_file.c:69:fopen(&#x27;ca.srl&#x27;,&#x27;r&#x27;)<br>139954133366592:error:2006D080:BIO routines:BIO_new_file:no such file:crypto/bio/bss_file.c:76:<br></code></pre></td></tr></table></figure></li><li>使用 CA 的自签名证书签发密钥证书后，可能会出现无法 CA无法认证的情况，需要检查在签发时 Common Name 不能和 CA 相同<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout ca.key -out ca.crt</span><br>Generating a RSA private key<br>.++++<br>...................................................................++++<br>writing new private key to &#x27;ca.key&#x27;<br>-----<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter &#x27;.&#x27;, the field will be left blank.<br>-----<br>Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:JiangSu<br>Locality Name (eg, city) []:Nanjing<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:XXX<br>Organizational Unit Name (eg, section) []:XXXX<br>Common Name (e.g. server FQDN or YOUR name) []:XXXX # 这个不能和控制器以及客户端相同<br>Email Address []:ShijieQ@outlook.com<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenSSL</category>
      
      <category>TLS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>OpenSSL</tag>
      
      <tag>TLS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度0313笔试总结</title>
    <link href="/2023/03/13/Algorithm/InternJob/Baidu0313/"/>
    <url>/2023/03/13/Algorithm/InternJob/Baidu0313/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>百度还是很温和的，第一道纯送分，第二道考了一个构造的脑筋急转弯，第三道难度也没有想象中的大，但我没做出来，算法之路任重而道远。</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>若干次询问，每次询问给出一个字符串，需要输出该字符串是否能够重新排列成"Baidu"，要求大小写一致。</p><h3 id="解题方法">解题方法</h3><p>水题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    string target = <span class="hljs-string">&quot;Baidu&quot;</span>;<br>    <span class="hljs-built_in">sort</span>(target.<span class="hljs-built_in">begin</span>(), target.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        string q;<br>        cin&gt;&gt;q;<br>        <span class="hljs-built_in">sort</span>(q.<span class="hljs-built_in">begin</span>(), q.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span> (q == target) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>给定一个整数 x，请你构造一个仅由 'r' , 'e' , 'd'三种字符组成的字符串，其中回文子串的数量恰好为 x</p><h3 id="解题方法-1">解题方法</h3><p>数学题。对于一个长度为 k的字符串，如果其仅有一种字符组成，则该字符串的回文子串数量为 <spanclass="math inline">\(n(n + 1)/2\)</span>，贪心构造即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    cin&gt;&gt;x;<br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> &lt;= x; i++) &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;r&quot;</span>;<br>        &#125;<br>        i--;<br>        x -= i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> &lt;= x; i++) &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;e&quot;</span>;<br>        &#125;<br>        i--;<br>        x -= i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> &lt;= x; i++) &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;d&quot;</span>;<br>        &#125;<br>        i--;<br>        x -= i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>小红拿到了一棵树，每个节点被染成了红色或者蓝色。</p><p>小红定义每条边的权值为：删除这条边时，形成的两个子树的同色连通块数量之差的绝对值。</p><p>小红想知道，所有边的权值之和是多少？</p><h3 id="输入描述">输入描述</h3><p>第一行输入一个正整数 n ,代表节点的数量。</p><p>第二哈输入一个长度为 n 且仅由 R 和 B 两种字符组成的字符串。</p><p>第 i 个字符为 R 代表 i 号节点被染成红色，为 B 则被染成蓝色。</p><p>接下来的 n−1 行，每行输入两个正整数 u 和 v ，代表节点 u 和节点 v有一条边相连。</p><p><span class="math inline">\(1 \le n \le 200000\)</span></p><h3 id="输出描述">输出描述</h3><p>一个正整数，代表所有节点的权值之和。</p><h3 id="样例">样例</h3><h4 id="输入">输入</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">4<br>BBRR<br>1 2<br>3 2<br>4 1<br></code></pre></td></tr></table></figure><h4 id="输出">输出</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">2<br></code></pre></td></tr></table></figure><h3 id="解题方法-2">解题方法</h3><p>这道题目在笔试中没有做出来，当时看到题目就知道是树形DP，前段时间做过一道类似的题目：<ahref="https://leetcode.cn/problems/count-number-of-possible-root-nodes/">2581.统计可能的树根数目</a>，用到了<ahref="https://zhuanlan.zhihu.com/p/348349531">换根DP</a>的思想。但是因为对于树形DP 的练习过少，错误地高估了这道题的难度（换根 DP似乎更不容易理解），短时间内也没有想到正解。</p><p>赛后补了一下这道题和树形 DP，使用 <spanclass="math inline">\(dp[i]\)</span> 表示以第 <spanclass="math inline">\(i\)</span>个节点为根的连通块个数，初始时所有的节点连通块个数为 1，使用 dfs跑一遍树可以计算出所有 <span class="math inline">\(dp[i]\)</span>的值。</p><p>随后再一次 dfs 尝试拆边，对于每一条边 <span class="math inline">\((l,r)\)</span> ：</p><ul><li>如果其左右节点颜色不同，则拆边不会影响连通块的个数，贡献为；<spanclass="math inline">\(abs((dp[0] - dp[r]) - dp[r])\)</span>；</li><li>若左右节点颜色相同，则拆边会导致连通块个数加 1 ，贡献为：<spanclass="math inline">\(abs((dp[0] - dp[r] + 1) - dp[r])\)</span>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n &gt;&gt; s;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l--, r--;<br>        g[l].<span class="hljs-built_in">emplace_back</span>(r);<br>        g[r].<span class="hljs-built_in">emplace_back</span>(l);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;] (<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> p) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;nx : g[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (nx == p) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">dfs</span>(nx, cur);<br>            <span class="hljs-keyword">if</span> (s[cur] != s[nx]) &#123;<br>                dp[cur] += dp[nx];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[cur] += dp[nx] - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; solve = [&amp;] (<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> p) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;nx : g[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (nx == p) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">solve</span>(nx, cur);<br>            <span class="hljs-keyword">if</span> (s[cur] == s[nx]) &#123;<br>                ans += ((dp[<span class="hljs-number">0</span>] - dp[nx] + <span class="hljs-number">1</span>) - dp[nx]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans += ((dp[<span class="hljs-number">0</span>] - dp[nx]) - dp[nx]);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拼多多0312笔试总结</title>
    <link href="/2023/03/13/Algorithm/InternJob/PDD0312/"/>
    <url>/2023/03/13/Algorithm/InternJob/PDD0312/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>拼多多的暑期实习招聘题目相对来说难度不大，题面也比较好理解，本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目描述">题目描述</h3><p>大致意思是给你一个压缩的字符串，让你还原出原始字符串，属于一个简单的模拟题目，样例如下：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">10a1b1c -&gt; aaaaaaaaaabc<br>1P2D1p2d1P1D1d -&gt; PDDpddPDd<br></code></pre></td></tr></table></figure></p><h3 id="解题方法">解题方法</h3><p>直接模拟，字符串处理。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;<br>            num = num*<span class="hljs-number">10</span> + s[i++]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; num; k++) &#123;<br>            cout &lt;&lt; s[i];<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="题目-2">题目 2</h2><h3 id="题目描述-1">题目描述</h3><p>T 个关卡，每个关卡 N 个敌人。需要打败所有敌人，现在有两种操作：</p><p>A 攻击：命中两个敌人，每个耐受值 -1。</p><p>B 攻击：命中一个敌人，直接消灭。</p><p>求打败所有敌人所需要操作的最小次数。</p><h3 id="解题方法-1">解题方法</h3><p>贪心。对于一个敌人如果其耐受值 &gt;= 2，可以直接使用 B 攻击；可以使用A 攻击同时击杀两个耐受值为 1 的敌人。因此只需要统计两种敌人的数量即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t, n;<br>    cin&gt;&gt;t&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br>        <span class="hljs-type">int</span> more = <span class="hljs-number">0</span>, one = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin&gt;&gt;tmp;<br>            <span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">2</span>) &#123;<br>                more++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                one++;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (more + (one + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="题目-3">题目 3</h2><h3 id="题目描述-2">题目描述</h3><p>第一行，一个整数 N ，代表准备参加活动的人数。<spanclass="math inline">\((1 \le N \le 100)\)</span></p><p>接下来 N 行，每行一个由 "ABC" 组成的字符串，其中第 i 行表示第 i个人投票了哪几个活动。（输入保证字符串非空，且由大写的 "ABC"字符组成）</p><p>最后 3行，每行两个整数，分别表示三个活动的人数上限以及每个人参加的费用。（人数上限以及参与活动的费用均为不超过100 的正整数）</p><h3 id="样例">样例</h3><h4 id="输入">输入</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">5<br>A<br>B<br>C<br>AB<br>ABC<br>2 1<br>2 2<br>2 3<br></code></pre></td></tr></table></figure><h4 id="输出">输出</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">YES<br>9<br></code></pre></td></tr></table></figure><h3 id="解题方法-2">解题方法</h3><p>动态规划。这道题其实在笔试的时候没有想到 DP，而是直接使用贪心来做，没想到竟然骗了 95%的分，题目数据可能比较弱，看到牛客上也有用贪心过了 100% 的。</p><p>赛中贪心解法(95%)： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">activaty</span>(<span class="hljs-number">3</span>);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">want</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        string s = <span class="hljs-string">&quot;&quot;</span>;<br>        cin &gt;&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>            want[i].<span class="hljs-built_in">push_back</span>(ch - <span class="hljs-string">&#x27;A&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        cin &gt;&gt; activaty[i].first &gt;&gt; activaty[i].second;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">sort</span>(want[i].<span class="hljs-built_in">begin</span>(), want[i].<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b) &#123;<br>            <span class="hljs-keyword">return</span> activaty[a].second &lt; activaty[b].second;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(want.<span class="hljs-built_in">begin</span>(), want.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>() ? a &lt; b:a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>();<br>    &#125;);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; isok;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;w : want[i]) &#123;<br>            <span class="hljs-keyword">if</span> (activaty[w].first &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans += activaty[w].second;<br>                activaty[w].first--;<br>                isok.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isok.<span class="hljs-built_in">size</span>() == n) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span> &lt;&lt; isok.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>赛后看到一种 dp 思路，<spanclass="math inline">\(dp[i][j][k]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个人，<spanclass="math inline">\(j\)</span> 个选 A，<spanclass="math inline">\(k\)</span> 个选 B，<spanclass="math inline">\(i-j-k\)</span> 个人选C，的最小值，后续有时间写一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// todo</span><br></code></pre></td></tr></table></figure><h2 id="题目-3-1">题目 3</h2><h3 id="题目描述-3">题目描述</h3><p>大致意思就是给你一个数组，长度为 n，让你输出两个长度为 n 的序列 <spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(A_i\)</span> 分别代表前 i个数的中位数和平均数。</p><h3 id="解题方法-3">解题方法</h3><p>数据流的中位数，借助两个栈即可实现，Leetcode 原题：<ahref="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指Offer 41. 数据流中的中位数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> _sum = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; small;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; big;<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; ans1, ans2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num;<br>        cin&gt;&gt;num;<br>        _sum += num;<br>        <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">empty</span>() || num &lt;= small.<span class="hljs-built_in">top</span>()) &#123;<br>            small.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (big.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> &lt; small.<span class="hljs-built_in">size</span>()) &#123;<br>                big.<span class="hljs-built_in">push</span>(small.<span class="hljs-built_in">top</span>());<br>                small.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            big.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (big.<span class="hljs-built_in">size</span>() &gt; small.<span class="hljs-built_in">size</span>()) &#123;<br>                small.<span class="hljs-built_in">push</span>(big.<span class="hljs-built_in">top</span>());<br>                big.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> average = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(<span class="hljs-number">1.0</span>*_sum/(i+<span class="hljs-number">1</span>) + <span class="hljs-number">0.5</span>);<br>        <span class="hljs-type">int</span> middle = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">size</span>() != big.<span class="hljs-built_in">size</span>()) &#123;<br>            middle = small.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            middle = (small.<span class="hljs-built_in">top</span>() + big.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        &#125;<br>        ans1.<span class="hljs-built_in">emplace_back</span>(average);<br>        ans2.<span class="hljs-built_in">emplace_back</span>(middle);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cout&lt;&lt;ans1[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        cout&lt;&lt;ans2[j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团0311笔试总结</title>
    <link href="/2023/03/12/Algorithm/InternJob/Meituan0311/"/>
    <url>/2023/03/12/Algorithm/InternJob/Meituan0311/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面：</p><p>作为整个人生求职生涯的第一场笔试，在做美团笔试时还是充满紧张和激动的，以至于最后一道题都没有看到，熟悉又陌生的ACM 模式还是让我对本地 IDE 和 OJ的差异性做出了过低的评估以至于第二题手忙脚乱浪费了不少时间。</p><p>本篇文章仅分享本人解答代码做学习交流，若涉密或侵权可联系我删除。</p></blockquote><h2 id="题目-1">题目 1</h2><h3 id="题目内容">题目内容</h3><p>大意是给你一个字符串，让你把它改成相邻元素不同的状态，询问最少修改次数</p><p>例如，对于字符串 11222333 ，她可以进行 3 次修改将其变为 121212313。</p><h3 id="解题方法">解题方法</h3><p>模拟。遇到相同的就修改，记录次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;s) &#123;<br>        string now = s;<br>        <span class="hljs-type">int</span> len = now.<span class="hljs-built_in">length</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (now[i<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (now[i] == now[i<span class="hljs-number">-1</span>]) &#123;<br>                ans++;<br>                now[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-2">题目 2</h2><h3 id="题目内容-1">题目内容</h3><p>小团在一个 n*m 的网格地图上探索。网格地图上第 i 行第 j 列的格子用坐标(i, j) 简记。</p><p>初始时，小团的位置在地图的左上角，即坐标 (1, 1)。地图上的每一个格子上都有一定的金币，特别地，小团位于的初始位置 (1, 1)上的金币为 0 。小团在进行探索移动时，可以选择向右移动一格(即从 (x, y)到达 (x, y + 1) ) 或向下移动一格 (即从 (x, y) 到达(x + 1, y)) 。</p><p>地图上的每个格子都有一个颜色，红色或蓝色。如果小团一次移动前后的两个格子颜色不同，那么他需要支付k个金币才能够完成这一次移动；如果移动前后的两个格子颜色相同，则不需要支付金币。小团可以在任意格子选择结束探索。</p><p>现在给你网格地图上每个格子的颜色与金币数量，假设小团初始时的金币数量为0，请你帮助小团计算出最优规划，使他能获得最多的金币，输出能获得的最多金币数量即可注意：要求保证小团任意时刻金币数量不小于零。</p><h4 id="输入">输入</h4><p>第一行 n， m， k 分别代表行数、列数和颜色转换需要的金币数</p><p>输入 colors 颜色二维数组</p><p>输入金币二维数组代表每点的金币个数</p><h3 id="解题方法-1">解题方法</h3><p>动态规划。比较基础的一道 DP ，直接使用 <spanclass="math inline">\(dp[i][j]\)</span> 表示到达位置 (i, j)时的最大金币数。（第一次笔试，写的比较丑）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;n&gt;&gt;m&gt;&gt;k) &#123;<br>        string graph[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin &gt;&gt; graph[i];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">val</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                cin &gt;&gt; val[i][j];<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> pre = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - (graph[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] == graph[i][<span class="hljs-number">0</span>] ? <span class="hljs-number">0</span>:k);<br>            <span class="hljs-keyword">if</span> (pre &gt;= <span class="hljs-number">0</span>)&#123;<br>                dp[i][<span class="hljs-number">0</span>] = pre + val[i][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-type">int</span> pre = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] - (graph[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] == graph[<span class="hljs-number">0</span>][j] ? <span class="hljs-number">0</span>:k);<br>            <span class="hljs-keyword">if</span> (pre &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = pre + val[<span class="hljs-number">0</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-type">int</span> l = dp[i<span class="hljs-number">-1</span>][j] - (graph[i<span class="hljs-number">-1</span>][j] == graph[i][j] ? <span class="hljs-number">0</span>:k);<br>                <span class="hljs-type">int</span> r = dp[i][j<span class="hljs-number">-1</span>] - (graph[i][j<span class="hljs-number">-1</span>] == graph[i][j] ? <span class="hljs-number">0</span>:k);<br>                <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], l + val[i][j]);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], r + val[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目-3">题目 3</h2><h3 id="题目内容-2">题目内容</h3><p>小美是一位天文爱好者，她收集了接下来一段时间中所有会划过她所在的观测地上空的流星信息。具体地，她收集了n 个流星在她所在观测地上空的出现时刻和消失时刻。</p><p>对于一个流星，若其的出现时刻为 s，消失时刻为 t，那么小美在时间段 [s,t]都能够观测到它。对于一个时刻，观测地上空出现的流星数量越多，则小美认为该时刻越好。小美希望能够选择一个最佳的时刻进行观测和摄影，使她能观测到最多数量的流星。</p><p>现在小美想知道，在这个最佳时刻，她最多能观测到多少个流星以及一共有多少个最佳时刻可供她选择。</p><h4 id="输入-1">输入</h4><p>第一行： n 代表区间个数</p><p>第二行， 输入所有区间的起始端点</p><p>第三行， 输入所有区间的末尾端点</p><h3 id="解题方法-2">解题方法</h3><p>离散化 + 差分。基本上是裸的模板题，直接秒了。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;n) &#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">t</span>(n);<br>        vector&lt;<span class="hljs-type">int</span>&gt; node;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin&gt;&gt;t[i].first;<br>            node.<span class="hljs-built_in">push_back</span>(t[i].first);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin&gt;&gt;t[i].second;<br>            node.<span class="hljs-built_in">push_back</span>(t[i].second);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(node.<span class="hljs-built_in">begin</span>(), node.<span class="hljs-built_in">end</span>());<br>        node.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(node.<span class="hljs-built_in">begin</span>(), node.<span class="hljs-built_in">end</span>()), node.<span class="hljs-built_in">end</span>());<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> len = node.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            hash[node[i]] = i;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(len + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[l, r] : t) &#123;<br>            diff[hash[l]] += <span class="hljs-number">1</span>;<br>            diff[hash[r]+<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; um;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) &#123;<br>            cnt += diff[i];<br>            um[cnt]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : um) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; ans) &#123;<br>                ans = k;<br>                pos = v;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;pos&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>赛后去学习离散化 + 差分时学到了一个很简洁的写法，借助 Map 的有序性和Key 唯一性，代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin&gt;&gt;n) &#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> s, e;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin &gt;&gt; s;<br>            m[s]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin &gt;&gt; e;<br>            m[e + <span class="hljs-number">1</span>]--;<br>            m[e];<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">-1</span>, times = <span class="hljs-number">-1</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnts;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : m) &#123;<br>            cnt += v;<br>            cnts[cnt]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v]: cnts) &#123;<br>            <span class="hljs-keyword">if</span> (v &gt; ans) &#123;<br>                ans = v;<br>                times = k;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; times &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="题目-4">题目 4</h2><h3 id="题目内容-3">题目内容</h3><p>坦克大战，但我没来得及写</p><h3 id="解题方法-3">解题方法</h3><p>等找到题面后，有时间做一下 &gt; // todo</p><h2 id="题目-5">题目 5</h2><h3 id="题目内容-4">题目内容</h3><p>不知道，甚至都没有看到</p><h3 id="解题方法-4">解题方法</h3><p>等找到题面后，有时间做一下 &gt; // todo</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>InternJob</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同注册中心之间的差异</title>
    <link href="/2023/03/07/DistributedSystem/MicroService/%E4%B8%8D%E5%90%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <url>/2023/03/07/DistributedSystem/MicroService/%E4%B8%8D%E5%90%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h2 id="nacos-eureka-zookeeper">Nacos &amp; Eureka &amp; Zookeeper</h2><p>Nacos、Eureka 和 Zookeeper都可以实现<strong>分布式注册中心框架</strong>。</p><p>Eureka 与 Nacos 底层通过 Raft 协议实现集群产生领导角色。</p><h3 id="差异">差异</h3><p>Zookeeper 采用 CP 保证数据的一致性的问题，原理是采用 ZAB原子广播协议。当我们 ZK领导者宕机或出现了故障，会自动重新实现选举新的领导角色，整个选举的过程中为了保证数据一致性的问题，整个微服务无法实现通讯（本地有缓存除外）。还有可运行的节点必须满足过半机制，整个ZK 才可以使用，要不然会奔溃。</p><p>Eureka 采用 AP设计理念架构注册中心，相互注册（你中有我，我中有你），完全去中心化，也就是没有主从之分，只要有一台Eureka 节点存在整个微服务就可以实现通讯。</p><p>Nacos 从 1.0 版本选择 AP 和 CP 混合形式实现注册中心，默认情况下采用AP 保证服务可用性，CP 形式底层采用 Raft协议保证数据的一致性问题。如果选择为 AP模式，注册服务的实例仅支持临时模式，在网络分区的的情况允许注册服务实例。选择CP模式可以支持注册服务的实例为持久模式，在网络分区的产生了抖动情况下不允许注册服务实例。</p><ul><li>也就是说 Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用CP 模式。</li><li>Nacos 同时支持服务列表变更的消息推送模式，服务列表更新更加及时</li></ul>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
      <category>MicroService</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见中间件</title>
    <link href="/2023/03/05/DistributedSystem/MicroService/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2023/03/05/DistributedSystem/MicroService/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="常见中间件">常见中间件</h2><h3 id="zookeeper">Zookeeper</h3><p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><h4 id="特点">特点</h4><ul><li><strong>顺序一致性</strong>：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper 中去；</li><li><strong>原子性</strong>：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用；</li><li><strong>单一系统映像</strong>：无论客户端连到哪一个 ZooKeeper服务器上，其看到的服务端数据模型都是一致的；</li><li><strong>可靠性</strong>：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li><li><strong>最终一致性</strong>：写操作最终（而非立即）会对客户端可见</li></ul><h4 id="常见功能">常见功能</h4><ol type="1"><li><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁；<ul><li>依托于临时节点会在 C/S 之间关闭 Session 后自动删除的功能</li></ul></li><li><strong>命名服务</strong>：可以通过 ZooKeeper 的顺序节点生成全局唯一ID；<ul><li>依托于 Zookeeper 的原子性与顺序性</li></ul></li><li><strong>数据发布/订阅</strong>：通过 Watcher 机制可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper被监听的节点上，其他机器可通过监听 ZooKeeper上节点的变化来实现配置的动态更新。<ul><li>依托于 Zookeeper 的 Watch 机制</li></ul></li></ol><blockquote><p>虽然以上功能主要依托于 ZooKeeper 可以保存数据和创建不同节点 (Znode)的功能，但 ZooKeeper 并不适合保存大量数据，每个节点数据量最大是1M。Zookeeper 主要功能是协调服务，不要存储大量数据在 Znode 上。</p></blockquote><h4 id="具体应用场景">具体应用场景</h4><ul><li><strong>Kafka</strong>: ZooKeeper 主要为 Kafka 提供 Broker 和 Topic的注册以及多个 Partition 的负载均衡等功能；</li><li><strong>Hbase</strong>: ZooKeeper 为 Hbase 提供确保整个集群只有一个Master 以及保存和提供 regionserver 状态信息（是否在线）等功能；</li><li><strong>Hadoop</strong>: ZooKeeper 为 Namenode 提供高可用支持。</li></ul><h4 id="使用">使用</h4><p><strong>Curator</strong> 是 Netflix 公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator的封装更加完善，各种 API 都可以比较方便地使用。</p><h3 id="kafka">Kafka</h3><p>Kafka是一个<strong>分布式流式处理平台</strong>，流平台一般具有三个关键功能：<strong>消息队列</strong>、<strong>容错的持久方式存储记录消息流</strong>、<strong>流式处理平台</strong>。</p><h4 id="特点-1">特点</h4><ul><li><strong>性能较强</strong>：基于 Scala 和 Java语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理<strong>千万级别</strong>的消息；</li><li><strong>兼容性较强</strong>：在大数据和流计算领域，与周边生态系统较为兼容。</li></ul><h4 id="常见功能-1">常见功能</h4><ol type="1"><li><strong>消息队列</strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据；</li><li><strong>数据处理</strong>：构建实时的流数据处理程序来转换或处理数据流。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
      <category>MicroService</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习常用模板</title>
    <link href="/2023/01/01/Algorithm/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/01/01/Algorithm/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串">字符串</h2><h3 id="回文子串">回文子串</h3><h4 id="动态规划">动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java version</span><br><span class="hljs-comment">// yes[i][j] 表示下标从 i 到 j 的子串是否为回文子串</span><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-type">boolean</span>[][] yes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    Arrays.fill(yes[i], <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>        yes[i][j] = (s.charAt(i) == s.charAt(j) &amp;&amp; yes[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="manacher-算法">Manacher 算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string now = <span class="hljs-string">&quot;$#&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>            now += ch;<br>            now += <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(now.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> mi = <span class="hljs-number">0</span>, mr = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, len = now.<span class="hljs-built_in">size</span>();<br>        now += <span class="hljs-string">&#x27;!&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            f[i] = (i &lt;= mr ? <span class="hljs-built_in">min</span>(f[<span class="hljs-number">2</span>*mi - i], mr - i + <span class="hljs-number">1</span>):<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (now[i + f[i]] == now[i - f[i]]) &#123;<br>                f[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; mr) &#123;<br>                mi = i;<br>                mr = i + f[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += (f[i] - <span class="hljs-number">1</span>)%<span class="hljs-number">2</span> ? f[i]/<span class="hljs-number">2</span>:(f[i] - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kmp-算法">KMP 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix_function</span><span class="hljs-params">(string t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> j = next[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; t[i] != t[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t[i] == t[j]) &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">KMP</span>(string s, string t) &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">prefix_function</span>(t);<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;<br>            i++, j++;<br>            <span class="hljs-keyword">if</span> (j == t.<span class="hljs-built_in">length</span>()) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(i - j, i - <span class="hljs-number">1</span>));<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="z-函数---扩展-kmp">Z 函数 - 扩展 KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    z[i] 表示 s[i:] 与 s 的最长公共前缀长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">zFunc</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>            z[i] = z[i - l];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            z[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) &#123;<br>                z[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) &#123;<br>            l = i;<br>            r = i + z[i] - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> z;<br>&#125;<br><br><span class="hljs-comment">// version 2:</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">zFunc</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= r) &#123;<br>            z[i] = <span class="hljs-built_in">min</span>(z[i - l], r - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) &#123;<br>            l = i;<br>            r = i + z[i];<br>            z[i]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ac-自动机">AC 自动机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ACTree</span> &#123;<br><br><span class="hljs-keyword">private</span>:<br>    ACTree *child[<span class="hljs-number">26</span>];<br>    ACTree *fail;<br>    vector&lt;<span class="hljs-type">int</span>&gt; exist; <span class="hljs-comment">// exist 数组存储的是以当前结尾的单词长度</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ACTree</span>() &#123;<br>        fail = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            child[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>        ACTree *cur = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>            <span class="hljs-type">int</span> idx = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur-&gt;child[idx] == <span class="hljs-literal">nullptr</span>) &#123;<br>                cur-&gt;child[idx] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ACTree</span>();<br>            &#125;<br>            cur = cur-&gt;child[idx];<br>        &#125;<br>        cur-&gt;exist.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">length</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt; &amp;s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;word : s) &#123;<br>            <span class="hljs-built_in">insert</span>(word);<br>        &#125;<br>        queue&lt;ACTree*&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;child[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">this</span>-&gt;child[i]-&gt;fail = <span class="hljs-keyword">this</span>;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>-&gt;child[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ACTree *cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;child[i] != <span class="hljs-literal">nullptr</span>) &#123;<br>                    ACTree *nxt = cur-&gt;child[i], *fafail = cur-&gt;fail;<br>                    <span class="hljs-keyword">while</span> (fafail != <span class="hljs-literal">nullptr</span> &amp;&amp; fafail-&gt;child[i] == <span class="hljs-literal">nullptr</span>) &#123;<br>                        fafail = fafail-&gt;fail;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (fafail == <span class="hljs-literal">nullptr</span>) &#123;<br>                        nxt-&gt;fail = <span class="hljs-keyword">this</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        nxt-&gt;fail = fafail-&gt;child[i];<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (nxt-&gt;fail-&gt;exist.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : nxt-&gt;fail-&gt;exist) &#123;<br>                            nxt-&gt;exist.<span class="hljs-built_in">push_back</span>(it);<br>                        &#125;<br>                    &#125;<br>                    q.<span class="hljs-built_in">push</span>(nxt);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回的是所有在 t 中出现的单词的左右下标</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">query</span>(<span class="hljs-type">const</span> string &amp;t) &#123;<br>        ACTree *cur = <span class="hljs-keyword">this</span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> idx = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">while</span> (cur-&gt;child[idx] == <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;fail != <span class="hljs-literal">nullptr</span>) &#123;<br>                cur = cur-&gt;fail;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur-&gt;child[idx] != <span class="hljs-literal">nullptr</span>) &#123;<br>                cur = cur-&gt;child[idx];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur-&gt;exist.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : cur-&gt;exist) &#123;<br>                    ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(i - it + <span class="hljs-number">1</span>, i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理括号字符串 s 的通用方法：</span><br><span class="hljs-comment">// 遍历 s，用一个变量 cnt 记录 s 前缀的左括号的个数减去右括号的个数。</span><br><span class="hljs-comment">// 如果 s 是合法括号字符串，那么在遍历的过程中 cnt &gt;= 0，且遍历结束后 cnt = 0。</span><br><br><span class="hljs-comment">// 把拼接的字符串分别记作 S 和 T，即 S + T 是合法括号字符串。</span><br><span class="hljs-comment">// 设 S 的 cnt 值为 cntS，要求遍历过程中的 cntS 的最小值 &gt;= 0。</span><br><span class="hljs-comment">// 设 T 的 cnt 值为 cntT，要求遍历过程中的 cntT 的最小值等于遍历结束后的 cntT。</span><br><span class="hljs-comment">// 如果 S+T 是合法括号字符串，那么 cntS + cntT = 0。</span><br><br><span class="hljs-comment">// Code:</span><br><span class="hljs-comment">// mp 存储的是成为合法括号字符串对应的冗余量，</span><br><span class="hljs-comment">// 正值表示该字符串应该位于左边，负值为右边，零值表示该字符串为合法括号字符串</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>(), cnt = <span class="hljs-number">0</span>, mcnt = len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>        cnt += (ch == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);<br>        mcnt = <span class="hljs-built_in">min</span>(cnt, mcnt);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">0</span> &amp;&amp; mcnt &gt;= <span class="hljs-number">0</span> || cnt &lt; <span class="hljs-number">0</span> &amp;&amp; mcnt == cnt) &#123;<br>        mp[cnt]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串哈希">字符串哈希</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">stringHash</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *hash;<br>    vector&lt;<span class="hljs-type">int</span>&gt; src;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> p;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *exp_p;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">stringHash</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;src, <span class="hljs-type">int</span> p) &#123;<br>        length = src.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;src = src;<br>        hash = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>[length];<br>        exp_p = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>[length];<br>        <span class="hljs-keyword">this</span>-&gt;p = p;<br>        <span class="hljs-comment">// 初始化前缀hash 和 p^i</span><br>        hash[<span class="hljs-number">0</span>] = src[<span class="hljs-number">0</span>];<br>        exp_p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            hash[i] = hash[i<span class="hljs-number">-1</span>]*p + src[i];<br>            exp_p[i] = p*exp_p[i<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 0 &lt;= l &lt;= r &lt;= length</span><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (l == <span class="hljs-number">0</span> ? hash[r]:hash[r] - hash[l<span class="hljs-number">-1</span>]*exp_p[r-l+<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> src, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> src == <span class="hljs-built_in">query</span>(l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="树">树</h2><h3 id="前序-中序建树">前序 + 中序建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            idx[inorder[i]] = i;<br>        &#125;<br>        function&lt;TreeNode*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir) -&gt; TreeNode* &#123;<br>            <span class="hljs-keyword">if</span> (pl &gt; pr || il &gt; ir) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            TreeNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pl]);<br>            <span class="hljs-type">int</span> m = idx[preorder[pl]];<br>            <span class="hljs-type">int</span> len = m - il;<br>            TreeNode *l = <span class="hljs-built_in">dfs</span>(pl + <span class="hljs-number">1</span>, pl + len, il, il + len - <span class="hljs-number">1</span>);<br>            TreeNode *r = <span class="hljs-built_in">dfs</span>(pl + len + <span class="hljs-number">1</span>, pr, m + <span class="hljs-number">1</span>, ir);<br>            cur-&gt;left = l, cur-&gt;right = r;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="后序-中序建树">后序 + 中序建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            pos[inorder[i]] = i;<br>        &#125;<br>        function&lt;TreeNode*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr) -&gt; TreeNode* &#123;<br>            <span class="hljs-keyword">if</span> (il &gt; ir || pl &gt; pr) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> m = pos[postorder[pr]];<br>            <span class="hljs-type">int</span> len = m - il;<br>            TreeNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[pr]);<br>            cur-&gt;left = <span class="hljs-built_in">dfs</span>(il, m - <span class="hljs-number">1</span>, pl, pl + len - <span class="hljs-number">1</span>);<br>            cur-&gt;right = <span class="hljs-built_in">dfs</span>(m + <span class="hljs-number">1</span>, ir, pl + len, pr - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="前序-后序建树">前序 + 后序建树</h3><blockquote><p>根据数据结构知识，树并不唯一，返回其中一种情况</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; idx;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; postorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            idx[postorder[i]] = i;<br>        &#125;<br>        function&lt;TreeNode*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; solve = [&amp;](<span class="hljs-type">int</span> lpre, <span class="hljs-type">int</span> rpre, <span class="hljs-type">int</span> lpost, <span class="hljs-type">int</span> rpost) -&gt; TreeNode* &#123;<br>            <span class="hljs-keyword">if</span> (lpre &gt; rpre || lpost &gt; rpost) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lpre == rpre) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[lpre]);<br>            &#125;<br>            <span class="hljs-type">int</span> m = idx[preorder[lpre + <span class="hljs-number">1</span>]];<br>            <span class="hljs-type">int</span> len = m - lpost;<br>            TreeNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[lpre]);<br>            cur-&gt;left = <span class="hljs-built_in">solve</span>(lpre + <span class="hljs-number">1</span>, lpre + <span class="hljs-number">1</span> + len, lpost, m);<br>            cur-&gt;right = <span class="hljs-built_in">solve</span>(lpre + <span class="hljs-number">1</span> + len + <span class="hljs-number">1</span>, rpre, m + <span class="hljs-number">1</span>, rpost - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="树状数组">树状数组</h3><blockquote><p>注释部分为区间最值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fenwick</span> &#123;<br>    vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; tree;<br>    <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// max -&gt; tree(n + 1, LLONG_MIN)</span><br>    <span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">tree</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">n</span>(n) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x&amp;-x;<br>    &#125;<br><br>    <span class="hljs-comment">// max -&gt; update(int, long long)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>            <span class="hljs-comment">// tree[i] = max(tree[i], val);</span><br>            tree[i] += val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pre_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>            res += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// long long pre_max(int i) &#123;</span><br>    <span class="hljs-comment">//     long long res = LLONG_MIN;</span><br>    <span class="hljs-comment">//     while (i &gt; 0) &#123;</span><br>    <span class="hljs-comment">//         res = max(res, tree[i]);</span><br>    <span class="hljs-comment">//         i -= i &amp; -1;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return res;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="图">图</h2><h3 id="dijkstra-算法">Dijkstra 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; &amp;graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(graph.size(), MAX_VALUE)</span></span>;<br>    dist[start] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, x] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (d &gt; dist[x]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [to, val] : graph[x]) &#123;<br>            <span class="hljs-type">int</span> cur_d = dist[x] + val;<br>            <span class="hljs-keyword">if</span> (cur_d &lt; dist[to]) &#123;<br>                dist[to] = cur_d;<br>                pq.<span class="hljs-built_in">push</span>(&#123;cur_d, to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数学">数学</h2><h3 id="素数筛">素数筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 埃式筛法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MX = <span class="hljs-number">1e5</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(MX + <span class="hljs-number">5</span>, <span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-type">int</span> init = []() &#123;<br>    isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= MX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= MX; j += i) &#123;<br>                isPrime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="质因数分解">质因数分解</h3><blockquote><p>需要预处理质数集合 prime</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">prime_factorization</span>(<span class="hljs-type">int</span> a) &#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; fact;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; prime.<span class="hljs-built_in">size</span>() &amp;&amp; prime[j] &lt; cur; j++) &#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cur % prime[j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (cur % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                cur /= prime[j];<br>                cnt++;<br>            &#125;<br>            fact.<span class="hljs-built_in">push_back</span>(&#123;prime[j], cnt&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur != <span class="hljs-number">1</span>) &#123;<br>        fact.<span class="hljs-built_in">push_back</span>(&#123;cur, <span class="hljs-number">1</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵快速幂">矩阵快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-comment">// calc A*B</span><br>vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">multiply</span>(vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; &amp;a, vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; &amp;b) &#123;<br>    <span class="hljs-type">int</span> m = a.<span class="hljs-built_in">size</span>(), n = b[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> t = a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            ans[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; t; k++) &#123;<br>                ans[i][j] = (ans[i][j] + a[i][k]*b[k][j])%mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// calc A^k</span><br>vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">qpow</span>(vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; &amp;a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() != a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br>            ans = <span class="hljs-built_in">multiply</span>(ans, a);<br>        &#125;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = <span class="hljs-built_in">multiply</span>(a, a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据处理">数据处理</h2><h3 id="前缀和">前缀和</h3><p>设数组 <span class="math inline">\(\operatorname{nums}\)</span>的前缀和为 <spanclass="math inline">\(\operatorname{pre\_sum}\)</span>，其中</p><p><span class="math display">\[\operatorname{pre\_sum}[i]=\sum_{j=0}^{i-1} \operatorname{nums}[j]\]</span></p><p>因此区间 <span class="math inline">\([L, R]\)</span> 的前缀和表示为<span class="math inline">\(\operatorname{pre\_sum}[R + 1] -\operatorname{pre\_sum}[L]\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre_sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    pre_sum[i] = pre_sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">auto</span> calc = [&amp;](<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>    <span class="hljs-keyword">return</span> pre_sum[R + <span class="hljs-number">1</span>] - pre_sum[L];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和的前缀和">前缀和的前缀和</h3><p>设数组 <span class="math inline">\(\operatorname{nums}\)</span>的前缀和的前缀和为 <spanclass="math inline">\(\operatorname{pre\_sum\_sum}\)</span>，其中</p><p><span class="math display">\[\operatorname{pre\_sum\_sum}[i]=\sum_{j=0}^{i-1}\operatorname{pre\_sum}[j]\]</span></p><p>因此区间 <span class="math inline">\([L, R]\)</span>的前缀和的前缀和表示为 <spanclass="math inline">\(\operatorname{pre\_sum\_sum}[R + 1] -\operatorname{pre\_sum\_sum}[L]\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre_pre_sum</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> pre_sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    pre_sum += nums[i - <span class="hljs-number">1</span>];<br>    pre_pre_sum[i + <span class="hljs-number">1</span>] = pre_pre_sum[i] + pre_sum;<br>&#125;<br><br><span class="hljs-keyword">auto</span> calc = [&amp;](<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>    <span class="hljs-keyword">return</span> pre_pre_sum[R + <span class="hljs-number">1</span>] - pre_pre_sum[L];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用">应用</h4><blockquote><p>Problem: (leetcode) <ahref="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">2281.巫师的总力量和</a></p></blockquote><p>在范围内含下标 i 的所有子数组的元素和的和可以表示为</p><p><span class="math display">\[\begin{aligned}&amp; \sum_{r=i+1}^{R+1}\sum_{l=L}^i(\operatorname{pre\_sum}[r]-\operatorname{pre\_sum}[l]) \\= &amp; \left(\sum_{r=i+1}^{R+1} \sum_{l=L}^i\operatorname{pre\_sum}[r]\right)-\left(\sum_{r=i+1}^{R+1} \sum_{l=L}^i\operatorname{pre\_sum}[l]\right) \\= &amp; (i-L+1) \cdot \sum_{r=i+1}^{R+1}\operatorname{pre\_sum}[r]-(R-i+1) \cdot \sum_{l=L}^i\operatorname{pre\_sum}[l]\end{aligned}\]</span></p><p>因此我们还需要计算出前缀和 <spanclass="math inline">\(\operatorname{pre\_sum}\)</span> 的前缀和 <spanclass="math inline">\(\operatorname{pre\_sum\_sum}\)</span> ，其中</p><p><span class="math display">\[\operatorname{pre\_sum\_sum}[i]=\sum_{j=0}^{i-1}\operatorname{pre\_sum}[j]\]</span></p><p>综上，区间 [L, R] 中含下标 i 的所有子数组的元素和的和可以表示为:</p><p><span class="math display">\[(i-L+1) \cdot (\operatorname{pre\_sum\_sum}[R+2] -\operatorname{pre\_sum\_sum}[i+1])-(R-i+1) \cdot(\operatorname{pre\_sum\_sum}[i+1]-\operatorname{pre\_sum\_sum}[L])\]</span></p><h3 id="离散化">离散化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arrayRankTransform</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp = arr;<br>    <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 去重</span><br>    tmp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()), tmp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : arr) &#123;<br>        x = <span class="hljs-built_in">upper_bound</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), x) - tmp.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数位-dp">数位 DP</h3><blockquote><p>视频讲解，从 19:30 开始https://www.bilibili.com/video/BV1rS4y1s721</p><p>其他资料：</p><p>https://zhuanlan.zhihu.com/p/348851463</p><p>https://www.bilibili.com/video/BV1MT4y1376C</p><p>https://www.bilibili.com/video/BV1yT4y1u7jW</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>(), dp[m][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <span class="hljs-comment">// mask 表示当前已经使用的数字，is_num 表示是否填充数字，is_limit 表示当前数位是否受上一数位限制</span><br>        <span class="hljs-comment">// is_num 用于限制前导零</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt; f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">bool</span> is_limit, <span class="hljs-type">bool</span> is_num) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (i == m) &#123;<br>                <span class="hljs-keyword">return</span> is_num;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!is_limit &amp;&amp; is_num &amp;&amp; dp[i][mask] &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> dp[i][mask];<br>            &#125;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 可以跳过当前数位</span><br>            <span class="hljs-keyword">if</span> (!is_num) &#123;<br>                res = <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <br>            &#125;<br>            <span class="hljs-comment">// 枚举要填入的数字 d</span><br>            <span class="hljs-type">int</span> up = is_limit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span> - is_num; d &lt;= up; ++d) &#123;<br>                <span class="hljs-comment">// d 不在 mask 中 (非必要条件)</span><br>                <span class="hljs-keyword">if</span> ((mask &gt;&gt; d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                    res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask | (<span class="hljs-number">1</span> &lt;&lt; d), is_limit &amp;&amp; d == up, <span class="hljs-literal">true</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!is_limit &amp;&amp; is_num) &#123;<br>                dp[i][mask] = res;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位运算">位运算</h2><h3 id="highbit">HighBit</h3><blockquote><p>返回该数对应二进制的最高位 1 所对应的数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">highbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    i |= (i &gt;&gt;  <span class="hljs-number">1</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">2</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">4</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">8</span>);<br>    i |= (i &gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> i - (i &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lowbit">LowBit</h3><blockquote><p>返回该数对应二进制的最低位 1 所对应的数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i &amp; -i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二进制移除最低位">二进制移除最低位</h3><blockquote><p>每次循环将数字 k 的最低二进制为 1 的比特位置为 0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (; k; k &amp;= k - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// code...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二进制子集遍历">二进制子集遍历</h3><blockquote><p>用于遍历数字 k 的所有二进制子集</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// version 1:</span><br><span class="hljs-type">int</span> sub = k;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// code...</span><br>    sub = (sub - <span class="hljs-number">1</span>) &amp; k;<br>&#125; <span class="hljs-keyword">while</span>(sub != k);<br><br><span class="hljs-comment">// version 2:</span><br><span class="hljs-type">int</span> sub = k;<br><span class="hljs-keyword">while</span> (sub &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// code...</span><br>    sub = (sub - <span class="hljs-number">1</span>) &amp; k;<br>&#125;<br><br><span class="hljs-comment">// version 3:</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sub = s; sub; sub = (sub - <span class="hljs-number">1</span>) &amp; s) &#123;<br>    <span class="hljs-comment">// code...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c-位运算内置函数">C++ 位运算内置函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回 x 的二进制表示中的 1 的个数</span><br><span class="hljs-type">int</span> __builtin_popcount(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x);<br><span class="hljs-type">int</span> __builtin_popcountl(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x);<br><span class="hljs-type">int</span> __builtin_popcountll(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> x);<br><span class="hljs-comment">// 返回 x 的二进制表示中的 1 的个数奇偶性，偶数个 1 返回 0，反之 1</span><br><span class="hljs-type">int</span> __builtin_parity(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x);<br><span class="hljs-type">int</span> __builtin_parityl(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x);<br><span class="hljs-type">int</span> __builtin_parityll(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> x);<br><span class="hljs-comment">// 返回 x 的二进制表示中前导的 0 的个数，常用 32 - __builtin_clz(x) 计算 x 对应二进制的有效位数</span><br><span class="hljs-type">int</span> __builtin_clz(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x);<br><span class="hljs-type">int</span> __builtin_clzl(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x);<br><span class="hljs-type">int</span> __builtin_clzll(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> x);<br><span class="hljs-comment">// 返回 x 的二进制表示中末尾的 0 的个数，不常用</span><br><span class="hljs-type">int</span> __builtin_ctz(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x);<br><span class="hljs-type">int</span> __builtin_ctzl(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x);<br><span class="hljs-type">int</span> __builtin_ctzll(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> x);<br></code></pre></td></tr></table></figure><h2 id="倍增">倍增</h2><h3 id="树上倍增">树上倍增</h3><blockquote><p>Problem: (leetcode) <ahref="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/description/">1483.树节点的第 K 个祖先</a></p><p>通过对 k 的二进制转换能够在 log(k) 的时间复杂度内计算出节点的 k祖先</p><p>预处理时间复杂度：O(nlogn)，询问时间复杂度：O(logk)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// pa[i][j] 表示节点 i 的第 2^j 个祖先</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent) &#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span> - __builtin_clz(n);<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        <span class="hljs-comment">// 预处理每个节点的第 1 个祖先</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            pa[i][<span class="hljs-number">0</span>] = parent[i];<br>        &#125;<br>        <span class="hljs-comment">// pa[x][i + 1] = pa[pa[x][i]][i]</span><br>        <span class="hljs-comment">// 即表示 x 的第 2^i 个祖先节点的第 2^i 个祖先节点就是 x 的第 2^(i+1) 个祖先节点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> p = pa[j][i];<br>                <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span>) &#123;<br>                    pa[j][i + <span class="hljs-number">1</span>] = pa[p][i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKthAncestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span> - __builtin_clz(k);<br>        <span class="hljs-comment">// 二进制分解 k 进行 log(k) 次跳跃查询</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((k &gt;&gt; i) &amp; <span class="hljs-number">1</span>) &#123;<br>                node = pa[node][i];<br>                <span class="hljs-keyword">if</span> (node &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="lca最近公共祖先">【LCA】最近公共祖先</h3><p>朴素的最近公共祖先可以通过 DFS 进行查询，时间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>基于倍增的解法是首先预处理所有节点的第 <spanclass="math inline">\(2^i\)</span> 个祖先，然后将待求解的节点 x 和 y置于同一层，进行 <span class="math inline">\(log_{2}{k}\)</span>次祖先查询，最终得到公共祖先，其中 k 为树的最大高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; depth;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;edges) &#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// n 的二进制长度</span><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span> - __builtin_clz(n); <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-comment">// 建图，节点编号从 0 开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y]: edges) &#123;<br>            g[x].<span class="hljs-built_in">push_back</span>(y);<br>            g[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        depth.<span class="hljs-built_in">resize</span>(n);<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        <span class="hljs-comment">// O(n) 求每个节点的深度，用于后续求 LCA 前转移两个节点为同一层</span><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) &#123;<br>            pa[x][<span class="hljs-number">0</span>] = fa;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y: g[x]) &#123;<br>                <span class="hljs-keyword">if</span> (y != fa) &#123;<br>                    depth[y] = depth[x] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">dfs</span>(y, x);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-comment">// 倍增预处理出每个节点的第 2^i 个祖先</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++) &#123;<br>                <span class="hljs-type">int</span> p = pa[x][i];<br>                <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span>) &#123;<br>                    pa[x][i + <span class="hljs-number">1</span>] = pa[p][i];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取节点 node 的第 k 个祖先</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_kth_ancestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (; k; k &amp;= k - <span class="hljs-number">1</span>)<br>            node = pa[node][__builtin_ctz(k)];<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 x 和 y 的最近公共祖先（节点编号从 0 开始）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth[x] &gt; depth[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-comment">// 使 y 和 x 在同一深度</span><br>        y = <span class="hljs-built_in">get_kth_ancestor</span>(y, depth[y] - depth[x]);<br>        <span class="hljs-keyword">if</span> (y == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-comment">// 循环从大到小，尝试每次上跳 i 步，理解为二进制分解两个节点的公共祖先高度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pa[x].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> px = pa[x][i], py = pa[y][i];<br>            <span class="hljs-comment">// 跳跃</span><br>            <span class="hljs-keyword">if</span> (px != py) &#123;<br>                x = px;<br>                y = py;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 保证两个节点最终跳跃的位置对应的父节点为最近公共祖先</span><br>        <span class="hljs-keyword">return</span> pa[x][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="区间询问">区间询问</h2><h3 id="区间数字出现频率">区间数字出现频率</h3><blockquote><p>Problem: (leetcode) <ahref="https://leetcode.cn/problems/range-frequency-queries/description/">2080.区间内查询数字的频率</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RangeFreqQuery</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; um;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RangeFreqQuery</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            um[arr[i]].<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (um.<span class="hljs-built_in">find</span>(value) == um.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">lower_bound</span>(um[value].<span class="hljs-built_in">begin</span>(), um[value].<span class="hljs-built_in">end</span>(), left);<br>        <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">upper_bound</span>(um[value].<span class="hljs-built_in">begin</span>(), um[value].<span class="hljs-built_in">end</span>(), right);<br>        <span class="hljs-keyword">return</span> r - l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数据结构">数据结构</h2><h3 id="集合前-k-小">集合前 k 小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两个 multiset 维护集合中的前 K 小值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KNums</span> &#123;<br>    <span class="hljs-comment">// 当前维护集合的前 K 小</span><br>    <span class="hljs-type">int</span> K;<br>    <span class="hljs-comment">// st1 保存前 K 小值，st2 保存其它值</span><br>    multiset&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; st1, st2;<br>    <span class="hljs-comment">// sum 表示 st1 中所有数的和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum;<br><br>    <span class="hljs-built_in">KNums</span>(<span class="hljs-type">int</span> K): <span class="hljs-built_in">K</span>(K), <span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 调整 st1 和 st2 的大小，保证调整后 st1 保存前 K 小值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (st1.<span class="hljs-built_in">size</span>() &lt; K &amp;&amp; st2.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = *(st2.<span class="hljs-built_in">begin</span>());<br>            st1.<span class="hljs-built_in">insert</span>(t);<br>            sum += t;<br>            st2.<span class="hljs-built_in">erase</span>(st2.<span class="hljs-built_in">begin</span>());<br>        &#125;<br>        <span class="hljs-keyword">while</span> (st1.<span class="hljs-built_in">size</span>() &gt; K) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = *<span class="hljs-built_in">prev</span>(st1.<span class="hljs-built_in">end</span>());<br>            st2.<span class="hljs-built_in">insert</span>(t);<br>            st1.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">prev</span>(st1.<span class="hljs-built_in">end</span>()));<br>            sum -= t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入元素 x</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!st2.<span class="hljs-built_in">empty</span>() &amp;&amp; x &gt;= *(st2.<span class="hljs-built_in">begin</span>())) &#123;<br>            st2.<span class="hljs-built_in">insert</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st1.<span class="hljs-built_in">insert</span>(x);<br>            sum += x;<br>        &#125;<br>        <span class="hljs-built_in">adjust</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素 x</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = st1.<span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">if</span> (it != st1.<span class="hljs-built_in">end</span>()) &#123;<br>            st1.<span class="hljs-built_in">erase</span>(it);<br>            sum -= x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st2.<span class="hljs-built_in">erase</span>(st2.<span class="hljs-built_in">find</span>(x));<br>        &#125;<br>        <span class="hljs-built_in">adjust</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数据流中的中位数">数据流中的中位数</h3><blockquote><p>不支持删除操作，支持删除操作的可以转换为『集合前 K 小问题』</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; queMin;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; queMax;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">empty</span>() || num &lt;= queMin.<span class="hljs-built_in">top</span>()) &#123;<br>            queMin.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> &lt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMax.<span class="hljs-built_in">push</span>(queMin.<span class="hljs-built_in">top</span>());<br>                queMin.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queMax.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() &gt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMin.<span class="hljs-built_in">push</span>(queMax.<span class="hljs-built_in">top</span>());<br>                queMax.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">size</span>() &gt; queMax.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> queMin.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (queMin.<span class="hljs-built_in">top</span>() + queMax.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring相关基础知识</title>
    <link href="/2022/11/10/Java/Spring/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/11/10/Java/Spring/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="spring">Spring</h1><ul><li><p>解决的是编译时的依赖</p></li><li><p><code>Class.forname()</code>方法的作用，就是初始化给定的类。而我们给定的MySQL 的 Driver 类中，它在静态代码块中通过 JDBC 的 DriverManager注册了一下驱动。我们也可以直接使用 JDBC 的驱动管理器注册 mysql驱动，从而代替使用 <code>Class.forName</code></p></li></ul><h2 id="reference">Reference</h2><p>《Spring揭秘》 《Spring IN ACTION》</p><h2 id="约定大于配置">约定大于配置</h2><blockquote><p>约定大于配置，也可以叫做约定优于配置（convention overconfiguration），也称作按约定编程，是一种软件设计范式，指在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p></blockquote><h2 id="循环依赖">循环依赖</h2><blockquote><p>If you use predominantly constructor injection, it is possible tocreate an unresolvable circular dependency scenario.</p><p>For example: Class A requires an instance of class B throughconstructor injection, and class B requires an instance of class Athrough constructor injection. If you configure beans for classes A andB to be injected into each other, the Spring IoC container detects thiscircular reference at runtime, and throws a<code>BeanCurrentlyInCreationException</code>.</p><p>One possible solution is to edit the source code of some classes tobe configured by setters rather than constructors. Alternatively, avoidconstructor injection and use setter injection only. In other words,although it is not recommended, you can configure circular dependencieswith setter injection.</p><p>Unlike the typical case (with no circular dependencies), a circulardependency between bean A and bean B forces one of the beans to beinjected into the other prior to being fully initialized itself (aclassic chicken-and-egg scenario).</p><p>如果您主要使用构造函数注入，则可能会创建无法解决的循环依赖场景。</p><p>例如：A类通过构造函数注入需要B类的实例，B类通过构造函数注入需要A类的实例。如果为类A 和 B 配置 bean 以相互注入，Spring IoC容器会在运行时检测到此循环引用，并抛出BeanCurrentlyInCreationException。</p><p>一种可能的解决方案是编辑某些类的源代码以由设置器而不是构造器配置。或者，避免构造函数注入并仅使用setter注入。也就是说，虽然不推荐，但是可以通过setter注入来配置循环依赖。</p><p>与典型情况（没有循环依赖关系）不同，bean A 和 bean B之间的循环依赖关系强制其中一个 bean 在完全初始化之前注入另一个bean（典型的先有鸡还是先有蛋的场景）。</p></blockquote><h2 id="延迟加载lazy-init">延迟加载lazy-init</h2><blockquote><p>By default, <code>ApplicationContext</code> implementations eagerlycreate and configure all singleton beans as part of the initializationprocess.</p></blockquote><p>通过<code>lazy-init</code>属性，可以将部分单例bean延迟加载。</p><h2 id="method-inject方法注入">Method Inject方法注入</h2><p>在大多数应用场景中，容器中的大多数 bean 都是单例的。 当一个单例 bean需要与另一个单例 bean 协作或非单例 bean 需要与另一个非单例 bean协作时，您通常通过将一个 bean 定义为另一个 bean 的属性来处理依赖关系。当 bean 生命周期不同时，就会出现问题。 假设单例 bean A需要使用非单例（原型）bean B，可能在 A上的每个方法调用上。容器只创建一次单例 beanA，因此只有一次设置属性的机会。 容器无法在每次需要时为 bean A提供一个新的 bean B 实例。 一个解决方案是放弃一些控制反转。您可以通过实现 ApplicationContextAware 接口让 bean A 知道容器，并在每次bean A 需要时对容器进行 getBean("B") 调用来请求（通常是新的）bean B实例。</p><p>//TODO</p><h2 id="java中的getresourceasstream">Java中的getResourceAsStream</h2><p><strong>首先，Java中的getResourceAsStream有以下几种：</strong></p><ol type="1"><li><p>Class.getResourceAsStream(String path) ： path不以’/'开头时默认是从此类所在的包下取资源，以’/'开头则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。</p></li><li><p>Class.getClassLoader.getResourceAsStream(String path)：默认则是从ClassPath根下获取，path不能以’/'开头，最终是由ClassLoader获取资源。</p></li><li><p>ServletContext. getResourceAsStream(Stringpath)：默认从WebAPP根目录下取资源，Tomcat下path是否以’/'开头无所谓，当然这和具体的容器实现有关。</p></li><li><p>Jsp下的application内置对象就是上面的ServletContext的一种实现。</p></li></ol><p><strong>其次，getResourceAsStream 用法大致有以下几种：</strong></p><p>第一： 要加载的文件和.class文件在同一目录下，例如：com.x.y下有类me.class ,同时有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第二：在me.class目录的子目录下，例如：com.x.y 下有类me.class ,同时在com.x.y.file 目录下有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第三：不在me.class目录下，也不在子目录下，例如：com.x.y下有类me.class ,同时在 com.x.file 目录下有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;/com/x/file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>总结一下，可能只是两种写法</p><p>第一：前面有 “ / ”</p><p>“ / ”代表了工程的根目录，例如工程名叫做myproject，“ /”代表了myproject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;/com/x/file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第二：前面没有 “ / ”</p><p>代表当前类的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;myfile.xml&quot;</span>); <br>me.class.getResourceAsStream(<span class="hljs-string">&quot;file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><h2 id="spring中的ioc">Spring中的IOC</h2><p>通过工厂模式和单例模式可以实现解耦的作用，但是Spring框架简化了我们的开发过程。通过使用Spring的IOC可以解决程序耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shijieq.ui;<br><br><span class="hljs-keyword">import</span> com.shijieq.dao.IAccountDao;<br><span class="hljs-keyword">import</span> com.shijieq.service.IAccountService;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟一个表现层，用于调用业务层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取spring的Ioc核心容器，并根据id获取对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * ApplicationContext的三个常用实现类：</span><br><span class="hljs-comment">     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用)</span><br><span class="hljs-comment">     *      FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 核心容器的两个接口引发出的问题：</span><br><span class="hljs-comment">     *  ApplicationContext:     单例对象适用              采用此接口</span><br><span class="hljs-comment">     *      它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *  BeanFactory:            多例对象使用</span><br><span class="hljs-comment">     *      它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.获取核心容器对象</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br><span class="hljs-comment">//        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\Users\\zhy\\Desktop\\bean.xml&quot;);</span><br>        <span class="hljs-comment">//2.根据id获取Bean对象</span><br>        <span class="hljs-type">IAccountService</span> <span class="hljs-variable">as</span>  <span class="hljs-operator">=</span> (IAccountService)ac.getBean(<span class="hljs-string">&quot;accountService&quot;</span>);<br>        <span class="hljs-type">IAccountDao</span> <span class="hljs-variable">adao</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;accountDao&quot;</span>,IAccountDao.class);<br><br>        System.out.println(as);<br>        System.out.println(adao);<br>        as.saveAccount();<br><br><br>        <span class="hljs-comment">//--------BeanFactory----------</span><br><span class="hljs-comment">//        Resource resource = new ClassPathResource(&quot;bean.xml&quot;);</span><br><span class="hljs-comment">//        BeanFactory factory = new XmlBeanFactory(resource);</span><br><span class="hljs-comment">//        IAccountService as  = (IAccountService)factory.getBean(&quot;accountService&quot;);</span><br><span class="hljs-comment">//        System.out.println(as);</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基于xml的ioc配置">基于XML的IOC配置</h2><h3 id="模板">模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br>&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中<br> id 属性：对象的唯一标识。<br> class 属性：指定要创建对象的全限定类名<br>--&gt;<br>&lt;!-- 配置 service --&gt; <br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;<br>&lt;!-- 配置 dao --&gt;<br>&lt;bean id=&quot;accountDao&quot; class=&quot;com.shijieq.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="bean标签">bean标签</h3><ul><li><p>作用：</p><p>用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p></li><li><p>属性：</p><ul><li><code>id</code>：给对象在容器中提供一个唯一标识。用于获取对象。</li><li><code>class</code>：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</li><li><code>scope</code>：指定对象的作用范围。<ul><li><code>singleton</code>: 默认值，单例的.<ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。</li><li>生命周期：<ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul></li></ul></li><li><code>prototype</code>: 多例的.<ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期：<ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul></li></ul></li><li><code>request</code>: WEB 项目中, Spring 创建一个 Bean的对象,将对象存入到 request 域中.</li><li><code>session</code>: WEB 项目中, Spring 创建一个 Bean的对象,将对象存入到 session 域中.</li><li><code>global session</code>: WEB 项目中, 应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session.</li></ul></li><li><code>init-method</code>：指定类中的初始化方法名称。</li><li><code>destroy-method</code>：指定类中销毁方法名称。</li><li>...</li></ul></li></ul><h4 id="实例化bean的三种方式">实例化bean的三种方式</h4><h5 id="默认无参构造函数">默认无参构造函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!--在默认情况下：<br>它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;/&gt;<br></code></pre></td></tr></table></figure><h5 id="静态工厂创建对象">静态工厂创建对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">/**<br>* 模拟一个静态工厂，创建业务层实现类<br>*/<br>public class StaticFactory &#123;<br>public static IAccountService createAccountService()&#123;<br>return new AccountServiceImpl();<br>&#125;<br>&#125;<br>&lt;!-- 此种方式是:<br>使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器<br>id 属性：指定 bean 的 id，用于从容器中获取<br>class 属性：指定静态工厂的全限定类名<br>factory-method 属性：指定生产对象的静态方法<br>--&gt;<br>&lt;bean id=&quot;accountService&quot;<br>  class=&quot;com.shijieq.factory.StaticFactory&quot;<br>  factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="实例工厂创建对象">实例工厂创建对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">/**<br>* 模拟一个实例工厂，创建业务层实现类<br>* 此工厂创建对象，必须现有工厂实例对象，再调用方法<br>*/<br>public class InstanceFactory &#123;<br>public IAccountService createAccountService()&#123;<br>return new AccountServiceImpl();<br>&#125;<br>&#125;<br>&lt;!-- 此种方式是：<br>先把工厂的创建交给 spring 来管理。<br>然后在使用工厂的 bean 来调用里面的方法<br>factory-bean 属性：用于指定实例工厂 bean 的 id。<br>factory-method 属性：用于指定实例工厂中创建对象的方法。<br>--&gt;<br>&lt;bean id=&quot;instancFactory&quot; class=&quot;com.shijieq.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;<br>&lt;bean id=&quot;accountService&quot;<br>  factory-bean=&quot;instancFactory&quot;<br>  factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h3 id="依赖注入">依赖注入</h3><h4 id="构造方法注入">构造方法注入</h4><p>采用构造函数的方式，给bean属性传值，要求<strong>类中存在一个对应参数列表的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAccountService</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountServiceImpl</span><span class="hljs-params">(String name, Integer age, Date birthday)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.birthday = birthday;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAccount</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;,&quot;</span>+age+<span class="hljs-string">&quot;,&quot;</span>+birthday);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 使用构造函数的方式，给 service 中的属性传值<br>要求：<br>类中需要提供一个对应参数列表的构造函数。<br>涉及的标签：<br>constructor-arg<br>属性：<br>index:指定参数在构造函数参数列表的索引位置<br>type:指定参数在构造函数中的数据类型<br>name:指定参数在构造函数中的名称 用这个找给谁赋值<br>=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============<br>value:它能赋的值是基本数据类型和 String 类型<br>ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;<br>&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="set方法注入">set方法注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAccountService</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBirthday</span><span class="hljs-params">(Date birthday)</span> &#123;<br>        <span class="hljs-built_in">this</span>.birthday = birthday;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAccount</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;,&quot;</span>+age+<span class="hljs-string">&quot;,&quot;</span>+birthday);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式<br>涉及的标签：<br>property<br>属性：<br>name：找的是类中 set 方法后面的部分<br>ref：给属性赋值是其他 bean 类型的<br>value：给属性赋值是基本数据类型和 string 类型的<br>实际开发中，此种方式用的较多。<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="p-名称空间注入数据">p 名称空间注入数据</h4><p>p 名称空间注入本质上还是调用set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br>    &lt;bean id=&quot;accountService&quot; <br>       class=&quot;com.shijieq.service.impl.AccountServiceImpl4&quot;<br>  p:name=&quot;test&quot; p:age=&quot;21&quot; p:birthday-ref=&quot;now&quot;/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="注入集合属性">注入集合属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 注入集合数据<br>List 结构的: array,list,set<br>Map 结构的: map,entry,props,prop<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;<br>&lt;!-- 给数组注入数据 --&gt;<br>&lt;property name=&quot;myStrs&quot;&gt;<br>&lt;set&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>&lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/set&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 list 集合数据 --&gt;<br>&lt;property name=&quot;myList&quot;&gt;<br>&lt;array&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>            &lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/array&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 set 集合数据 --&gt;<br>&lt;property name=&quot;mySet&quot;&gt;<br>&lt;list&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>            &lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/list&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 Map 数据 --&gt;<br>&lt;property name=&quot;myMap&quot;&gt;<br>&lt;props&gt;<br>            &lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt;<br>            &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;<br>&lt;/props&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 properties 数据 --&gt;<br>&lt;property name=&quot;myProps&quot;&gt;<br>&lt;map&gt;<br>&lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;<br>&lt;entry key=&quot;testB&quot;&gt;<br>&lt;value&gt;bbb&lt;/value&gt;<br>&lt;/entry&gt;<br>&lt;/map&gt;<br>&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h2 id="基于注解的ioc配置">基于注解的IOC配置</h2><h3 id="模板-1">模板</h3><p>相较于”基于XML的IOC配置“模板，导入约束时需要多导入一个<strong>context</strong> 名称空间下的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>    http://www.springframework.org/schema/beans/spring-beans.xsd<br>       http://www.springframework.org/schema/context<br>   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;<br>&lt;context:component-scan base-package=&quot;com.shijieq&quot;&gt;&lt;/context:component-scan&gt;<br><br>&lt;!-- 配置 dbAssit --&gt;<br>&lt;bean id=&quot;dbAssit&quot; class=&quot;com.shijieq.dbassit.DBAssit&quot;&gt;<br>&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br><br>&lt;!-- 配置数据源 --&gt;<br>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;<br>&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day02&quot;&gt;&lt;/property&gt;<br>        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;<br>        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="常用注解">常用注解</h3><p><strong>细节</strong>：如果注解中有且只有一个属性要赋值时，且名称是value，value 在赋值是可以不写</p><h4 id="创建对象">创建对象</h4><p>相当于：<code>&lt;bean id="" class=""&gt;</code></p><ul><li><code>@Component</code><ul><li>把资源让 spring 来管理。相当于在 xml 中配置一个 bean</li><li>属性：<ul><li><code>value</code>：指定 bean 的 id。如果不指定 value 属性，默认bean 的 id 是当前类的类名。<strong>首字母小写</strong></li></ul></li></ul></li><li><code>@Controller, @Service, @Repository</code>：<ul><li><code>@Controller</code>：一般用于<strong>表现层</strong>的注解</li><li><code>@Service</code>：一般用于<strong>业务层</strong>的注解</li><li><code>@Repository</code>：一般用于<strong>持久层</strong>的注解</li></ul></li></ul><h4 id="注入数据">注入数据</h4><p>相当于：<code>&lt;property name="" ref=""&gt;</code>、<code>&lt;property name="" value=""&gt;</code></p><ul><li><code>@Autowired</code><ul><li>自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在spring 容器查找，找到了也可以注入成功。找不到就报错。</li></ul></li><li><code>@Qualifier</code><ul><li>在自动按照类型注入的基础之上，再按照 Bean 的 id注入。它在给字段注入时不能独立使用，必须和 <span class="citation"data-cites="Autowire">@Autowire</span>一起使用；但是给方法参数注入时，可以独立使用。</li><li>属性：<ul><li><code>value</code>：指定 bean 的 id</li></ul></li></ul></li><li><code>@Resource</code><ul><li>直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。</li><li>属性：<ul><li><code>name</code>：指定 bean 的 id</li></ul></li></ul></li><li><code>@Value</code><ul><li>注入基本数据类型和 String 类型数据</li><li>属性：<ul><li><code>value</code>：用于指定值</li></ul></li></ul></li></ul><h4 id="改变作用范围">改变作用范围</h4><p>相当于： <code>&lt;bean id="" class="" scope=""&gt;</code></p><ul><li><code>@Scope</code><ul><li>指定 bean 的作用范围</li><li>属性：<ul><li><code>value</code>：指定范围的值，取值为：<code>singleton, prototype, request, session, global session</code></li></ul></li></ul></li></ul><h4 id="生命周期相关">生命周期相关*</h4><p>相当于：<code>&lt;bean id="" class="" init-method="" destroy-method="" /&gt;</code></p><ul><li><code>@PostConstruct</code>：用于指定初始化方法</li><li><code>@PreDestroy</code>：用于指定销毁方法</li></ul><h2 id="基于注解和xml的ioc对比">基于注解和XML的IOC对比</h2><p><img src=".\img\基于注解和XML的对比.png" alt="image-20220318235631736" style="zoom:67%;" /></p><h3 id="相关替代">相关替代</h3><h4 id="替代bean.xml">替代bean.xml</h4><p>如何用注解完全替代<code>bean.xml</code>？</p><ul><li><code>@Configuration</code><ul><li>用于<strong>指定当前类是一个 spring配置类</strong>，当创建容器时会从该类上加载注解。</li><li>获取容器时需要使用 AnnotationApplicationContext(有@Configuration注解的类.class)</li><li>属性：<ul><li><code>value</code>：用于指定配置类的字节码</li></ul></li></ul></li><li><code>@ComponentScan</code><ul><li>用于<strong>指定 spring 在初始化容器时要扫描的包</strong>。</li><li>作用和在 spring 的 xml配置文件中的：<code>&lt;context:component-scan base-package="com.shijieq"/&gt;</code>是一样的</li><li>属性：<ul><li><code>basePackages</code>：用于指定要扫描的包。和<strong>该注解中的value 属性作用一样</strong>。</li></ul></li></ul></li><li><code>@Bean</code><ul><li>该注解<strong>只能写在方法</strong>上，表明使用<strong>此方法创建一个对象</strong>，并且放入spring 容器</li><li>属性：<ul><li><code>name</code>：给当前@Bean注解方法创建的对象指定一个名称(<strong>即 bean 的 id</strong>）。</li></ul></li></ul></li></ul><h4 id="提取配置">提取配置</h4><p>此时<code>bean.xml</code>文件已经可以删除，对于一些数据源或者其他如何将他们配置出来？</p><ul><li><p><code>@PropertySource</code></p><ul><li><strong>用于加载<code>.properties</code>文件中的配置</strong>。</li><li>例如我们配置数据源时，可以把连接数据库的信息写到 properties配置文件中，就可以使用此注解指定 properties 配置文件的位置。</li><li>属性：<ul><li><code>value[]</code>：用于指定 properties 文件位置，如果是在<ahref="./Java.md">类路径</a>下，需要写上<code>classpath:</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 连接数据库的配置类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br><span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 创建一个数据源，并存入 spring 容器中</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@Bean(name=&quot;dataSource&quot;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">createDataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        ds.setDriverClass(driver);<br>            ds.setJdbcUrl(url);<br>            ds.setUser(username);<br>            ds.setPassword(password);<br>            <span class="hljs-keyword">return</span> ds;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">jdbc.properties 文件：</span><br><span class="hljs-comment">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="hljs-comment">jdbc.url=jdbc:mysql://localhost:3306/day44_ee247_spring</span><br><span class="hljs-comment">jdbc.username=root</span><br><span class="hljs-comment">jdbc.password=1234</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="导入其他配置">导入其他配置</h4><ul><li><p><code>@Import</code></p><ul><li>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解（写上也没事）。</li><li>属性：</li><li><code>value[]</code>：用于指定其他配置类的字节码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.shijieq.spring&quot;)</span><br><span class="hljs-meta">@Import(&#123; JdbcConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfiguration</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="获取容器">获取容器</h4><p>当配置文件被完全替代后，如何通过注解获取容器？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);<br></code></pre></td></tr></table></figure><h2 id="spring整合junit">Spring整合Junit</h2><p>以下主要介绍在Spring中如何整合单元测试，这部分在Springboot中有更好更为简洁的方式。</p><h3 id="配置步骤">配置步骤</h3><ol type="1"><li>拷贝整合 junit 的必备 jar 包到 lib 目录，或通过maven导入依赖</li><li>使用<code>@RunWith</code>注解替换原有运行器</li><li>使用<code>@ContextConfiguration</code>指定 spring配置文件的位置</li><li>使用<code>@Autowired</code>给测试类中的变量注入数据</li></ol><h3 id="举个例子">举个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 测试类</span><br><span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations= &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceTest</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> IAccountService as ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring中的aop">Spring中的AOP</h2><p>AOP全称是”面向切面编程“，简单来说就是<strong>把我们程序重复的代码抽取出来</strong>，在需要执行的时候，使用<strong>动态代理技术</strong>，在不修改源码的基础上，对我们的已有方法进行增强。</p><p>例如转账系统中对持久层的操作都是独立事务，导致无法实现事务控制，不符合事务的一致性。我们通过让业务层来控制事务的提交和回滚，而这个过程中存在一些重复的代码，此时就可以采用动态代理技术进行增强。</p><h3 id="动态代理与静态代理">动态代理与静态代理</h3><p><strong>动态代理的特点是字节码随用随创建，随用随加载</strong>。它与静态代理的区别也在于此。因为<strong>静态代理是字节码一上来就创建好，并完成加载。</strong></p><p>装饰者模式就是静态代理的一种体现。</p><p>动态代理常用的有两种方式：<strong>基于接口的动态代理</strong>和<strong>基于子类的动态代理</strong>。</p><h4 id="基于接口的动态代理">基于接口的动态代理</h4><p>使用JDK官方提供的Proxy类，<strong>要求被代理类最少实现一个接口</strong>。</p><h4 id="基于子类的动态代理">基于子类的动态代理</h4><p>使用第三方的CGLib，<strong>要求被代理类不能用final修饰，即不能为最终类</strong></p><h3 id="相关术语">相关术语</h3><ul><li><code>Joinpoint(连接点)</code>:所谓连接点是指那些被拦截到的点。<strong>在 spring中,这些点指的是方法</strong>，因为 spring 只支持方法类型的连接点。</li><li><code>Pointcut(切入点)</code>: 所谓切入点是指我们要对哪些 Joinpoint进行拦截的定义。</li><li><code>Advice(通知/增强)</code>:<ul><li>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。</li><li>通知类型<ul><li>前置通知</li><li>后置通知</li><li>异常通知</li><li>最终通知</li><li>环绕通知</li></ul></li></ul></li><li><code>Introduction(引介)</code>:引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或 Field。</li><li><code>Target(目标对象)</code>: 代理的目标对象。</li><li><code>Weaving(织入)</code>:<ul><li>是指把增强应用到目标对象来创建新的代理对象的过程。</li><li>spring 采用动态代理织入，而 AspectJ采用编译期织入和类装载期织入。</li></ul></li><li><code>Proxy（代理）</code>: 一个类被 AOP织入增强后，就产生一个结果代理类。</li><li><code>Aspect(切面)</code>: 是切入点和通知（引介）的结合。</li></ul><h3 id="要明确的事">要明确的事</h3><h4 id="开发阶段">开发阶段</h4><p>这部分工作由开发人员完成：</p><ol type="1"><li>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。</li><li>把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。</li><li>在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。</li></ol><h4 id="运行阶段">运行阶段</h4><p>这部分工作由Spring框架完成：</p><p>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><p><strong>在 spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</strong></p><h2 id="基于xml的aop配置">基于XML的AOP配置</h2><h3 id="模板-2">模板</h3><p>在IOC模板的基础上还需要导入aop的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="配置步骤-1">配置步骤</h3><ol type="1"><li><p>把通知类用 bean 标签配置起来</p></li><li><p>使用 <code>aop:config</code> 声明 aop 配置</p></li><li><p>使用 <code>aop:aspect</code> 配置切面</p></li><li><p>使用 <code>aop:pointcut</code>配置切入点表达式<code>expression</code></p></li><li><p>使用 <code>aop:xxx</code> 配置对应的通知类型</p><ul><li>aop:xxx都拥有的共同属性：<ul><li><code>method</code>: 用于指定通知类中的增强方法名称</li><li><code>pointcut</code>: 用于指定切入点表达式</li><li><code>pointcut-ref</code>: 用于指定切入点的表达式的引用</li></ul></li><li><code>aop:before</code><ul><li>用于配置<strong>前置通知</strong>。指定增强的方法在切入点方法之前执行。</li></ul></li><li><code>aop:after-returning</code><ul><li>用于配置<strong>后置通知</strong></li><li>执行时间点：<strong>切入点方法正常执行之后。它和异常通知只能有一个执行。</strong></li></ul></li><li><code>aop:after-throwing</code><ul><li>用于配置<strong>异常通知</strong></li><li>执行时间点：<strong>切入点方法执行产生异常后执行。它和后置通知只能执行一个。</strong></li></ul></li><li><code>aop:after</code><ul><li>用于配置<strong>最终通知</strong></li><li>执行时间点：<strong>无论切入点方法执行时是否有异常，它都会在其后面执行。</strong></li></ul></li><li><code>aop:around</code><ul><li>用于配置<strong>环绕通知</strong></li><li>它是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。</li><li><strong>通常情况下环绕通知都是单独使用的。</strong></li></ul></li></ul></li></ol><h3 id="切入点表达式expression">切入点表达式expression</h3><blockquote><p>execution(表达式)</p></blockquote><h4 id="语法">语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br></code></pre></td></tr></table></figure><h4 id="写法">写法</h4><h5 id="全匹配模式">全匹配模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="访问修饰符省略">访问修饰符省略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">void</span> com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="返回值用表示">返回值用*表示</h5><p>返回值*表示任意返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="包名用表示">包名用*表示</h5><p>包名*表示任意包名，但是有几级包，就要写几个*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* *.*.*.*.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="用..表示当前包">用..表示当前包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="类名使用号">类名使用*号</h5><p>类名*表示任意类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="方法名使用号">方法名使用*号</h5><p>方法名*表示任意方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="参数列表使用号">参数列表使用*号</h5><p>参数列表*表示可以是任意数据类型，但是必须有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(*))<br></code></pre></td></tr></table></figure><h5 id="参数列表使用..号">参数列表使用..号</h5><p>参数列表..表示有无参数均可，如有参数可为任意数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(..))<br></code></pre></td></tr></table></figure><h5 id="全通配模式">全通配模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* *..*.*(..))<br></code></pre></td></tr></table></figure><h3 id="举个例子-1">举个例子</h3><p>假设我们要对业务层代码切入事务控制，首先定义一个事务控制类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 事务控制类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><span class="hljs-comment">//定义一个 DBAssit</span><br>    <span class="hljs-keyword">private</span> DBAssit dbAssit ;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDbAssit</span><span class="hljs-params">(DBAssit dbAssit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dbAssit = dbAssit;<br>&#125;<br><span class="hljs-comment">//开启事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginTransaction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//提交事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().commit();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//回滚事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().rollback();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//释放资源</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置文件，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;<br>&lt;!-- 配置通知 --&gt;<br>&lt;bean id=&quot;txManager&quot; class=&quot;com.shijieq.utils.TransactionManager&quot;&gt;<br>&lt;property name=&quot;dbAssit&quot; ref=&quot;dbAssit&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br><br>&lt;!--配置AOP--&gt;<br>&lt;aop:config&gt;<br>&lt;!--配置切面--&gt;<br>&lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt;<br>&lt;!--声明一个切入点pt1--&gt;<br>&lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;/&gt;<br>&lt;!--配置前置通知--&gt;<br>&lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置后置通知--&gt;<br>&lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置异常通知--&gt;<br>&lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置最终通知--&gt;<br>&lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;/aop:aspect&gt;<br>&lt;/aop:config&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="环绕通知">环绕通知</h4><p>//TODO</p><h2 id="基于注解的aop配置">基于注解的AOP配置</h2><h3 id="模板-3">模板</h3><p>相较于”基于XML的AOP配置“模板，导入约束时需要多导入一个<strong>context</strong> 名称空间下的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd<br>   http://www.springframework.org/schema/context<br>   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="配置步骤-2">配置步骤</h3><ol type="1"><li><p>把通知类也使用注解配置</p></li><li><p>在通知类上使用@Aspect 注解声明为切面</p></li><li><p>在增强的方法上使用注解配置通知</p></li><li><p>在 spring 配置文件中开启 spring 对注解 AOP 的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;<br>&lt;aop:aspectj-autoproxy/&gt;<br></code></pre></td></tr></table></figure><p>或者通过注解开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.shijie&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="相关注解">相关注解</h3><ul><li><p><code>@Aspect</code>: 表明当前类是一个切面类</p></li><li><p><code>@Before</code>: 把当前方法看成是前置通知</p></li><li><p><code>@AfterReturning</code>: 把当前方法看成是后置通知</p></li><li><p><code>@AfterThrowing</code>: 把当前方法看成是异常通知</p></li><li><p><code>@After</code>: 把当前方法看成是最终通知</p></li><li><p><code>@Around</code>: 把当前方法看成是环绕通知</p></li><li><p><code>@Pointcut</code>: 指定切入点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt1</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@After(&quot;pt1()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="举个例子-2">举个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 事务控制类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component(&quot;txManager&quot;)</span><br><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//表明当前类是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><span class="hljs-comment">//定义一个 DBAssit</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DBAssit dbAssit;<br>    <br>    <span class="hljs-comment">//开启事务</span><br><span class="hljs-meta">@Before(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginTransaction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>    dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    e.printStackTrace();<br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().commit();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().rollback();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring中的事务控制">Spring中的事务控制</h2><p>//TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见决策算法汇总</title>
    <link href="/2022/11/01/Laboratory/TrustManagement/%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/01/Laboratory/TrustManagement/%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="topsis">TOPSIS</h1><p>TOPSIS法根据有限个评价对象与理想化目标的接近程度进行排序的方法，是在现有的对象中进行相对优劣的评价。TOPSIS法是一种逼近于理想解的排序法，该方法只要求各效用函数具有单调递增（或递减）性就行。TOPSIS法是多目标决策分析中一种常用的有效方法，又称为<strong>优劣解距离法</strong>。&gt; 1981年，C.L.Hwang和K.Yoon首次提出了Topsis，全称Technique for OrderPreference by Similarity to an IdealSolution，可翻译为逼近理想解排序法，国内常称为优劣解距离法。它是一种常用的综合评价方法。</p><h2 id="优点">优点</h2><p>TOPSIS可以弥补层次分析法的一些缺点: 1.优劣解距离法可以充分利用原始数据信息，且其结果能充分反应各评价方案与最优方案的接近程度。2.对样本容量没有严格限制，数据计算简单易行，无需数据检验。（topsis法适用于两个以上）</p><h2 id="基本过程">基本过程</h2><ol type="1"><li>原始矩阵正向化，得到正向化矩阵<ul><li>指标类型。指标类型一般分为四种，<strong>极大型指标</strong>、<strong>极小型指标</strong>、<strong>中间型指标</strong>、<strong>区间型指标</strong>。<ul><li>极大型指标越大越好；</li><li>极小型指标越小越好；</li><li>中间型指标越接近中间值越好；</li><li>区间型指标落在区间内最好。</li></ul></li><li>正向化公式。正向化就是将原始数据指标都转化为极大型指标<ul><li>极小型 -&gt; 极大型：<span class="math inline">\(x_i = max -x_i\)</span>，当指标值中没有"0"时也可以用 <spanclass="math inline">\(x_i = \frac{1}{x_i}\)</span></li><li>中间型 -&gt; 极大型：<span class="math inline">\(x_i = 1 -\frac{|x_i - max|}{mid}\)</span>，其中 <spanclass="math inline">\(mid\)</span> 为中间值</li><li>区间型 -&gt; 极大型：其中 <span class="math inline">\(M\)</span>表示为距离区间最远的距离，即 <span class="math inline">\(max(a -min(x_i), max(x_i) - b)\)</span> <span class="math display">\[\left\{\begin{array}{c}x_i=1-\frac{a-x_i}{M}\left(x^i \leqslant a\right) \\x_i=1\left(a \leqslant x_i \leqslant b\right) \\x_i=1-\frac{x_i-b}{M}\left(x^i \geqslant b\right)\end{array}\right.\]</span></li></ul></li></ul>假设有n个要评价的对象，m个已经正向化的评价指标，构成的正向化矩阵为：<span class="math display">\[X=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></li><li>对正向化矩阵标准化 <span class="math display">\[Z_{i j}=\frac{x_{i j}}{\sqrt{\sum_1^n x_{i j}^2}}\]</span> 得到标准化矩阵为： <span class="math display">\[Z=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></li><li>计算得分并归一化 构造评分公式：<span class="math inline">\(S =\frac{x - min}{max - min}\)</span>，变形可得 <spanclass="math inline">\(S = \frac{x - min}{(max - x) + (x - min)}\)</span>计算列最大值 <span class="math display">\[ Z^+ = (Z^+_1, Z^+_2, \cdots,Z^+_m) =\left(\max \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \max\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \max \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\]</span> 计算列最小值 <span class="math display">\[ Z^- = (Z^-_1,Z^-_2, \cdots, Z^-_m) =\left(\min \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \min\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \min \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\]</span> 定义第 <span class="math inline">\(i\)</span>个评价对象与最大值的距离 <spanclass="math inline">\(D_i^{+}=\sqrt{\sum_{j=1}^m\left(Z_j^{+}-z_{ij}\right)^2}\)</span> 定义第 <span class="math inline">\(i\)</span>个评价对象与最小值的距离 <spanclass="math inline">\(D_i^{-}=\sqrt{\sum_{j=1}^m\left(Z_j^{-}-z_{ij}\right)^2}\)</span> 那么可以计算出第 <spanclass="math inline">\(i\)</span> 个评价对象未归一化的得分为：<spanclass="math inline">\(S_i = \frac{D^-_i}{D^+_i + D^-_i}\)</span> 将<span class="math inline">\(S_i\)</span>归一化后进行数值排名，即可得到最佳方案</li></ol><h1 id="vikor">VIKOR</h1><h2 id="与topsis的对比">与TOPSIS的对比</h2><ul><li>TOPSIS和VIKOR的区别之一在于<strong>聚合函数</strong>。TOPSIS是基于距离理想解的距离的集合，VIKOR方法在TOPSIS方法的基础上提出了一个具有优势率的折衷方案。在TOPSIS方法中，不仅要考虑到与正理想解的最近距离，而且考虑到与负理想解的最长距离，从而确定最优解，以最大限度地提高效益。但TOPSIS中的这些距离只是简单地求和，没有考虑它们的相对重要性，而在VIKOR中决策者会根据自身需求确定其重要性。</li><li>VIKOR方法相比TOPSIS方法多了一个<strong>决策机制系数</strong>，它可以使决策者做出更激进或更保守的决策。TOPSIS方法的过程没有纳入任何主观因素，更适合要求结果完全客观的决策环境。</li><li>VIKOR方法的独特优势在于可以得到<strong>带有优先级的折衷方案</strong>，这使得通过VIKOR排序后的最佳方案可能不止一个。而TOPSIS方法只能得到唯一最优解，毕竟它的过程是完全客观的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Laboratory</category>
      
      <category>TrustManagement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Laboratory</tag>
      
      <tag>TrustManagement</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 中的 Socket</title>
    <link href="/2022/10/10/C++/C++%E4%B8%AD%E7%9A%84Socket/"/>
    <url>/2022/10/10/C++/C++%E4%B8%AD%E7%9A%84Socket/</url>
    
    <content type="html"><![CDATA[<h1 id="socket">Socket</h1><p>《TCP/IP 网络编程》和《Linux高性能服务器编程》</p><p><strong>socket其实就是操作系统提供给程序员操作「网络协议栈」的接口，开发人员能通过socket的接口，来控制协议找工作，从而实现网络通信，达到跨主机通信</strong></p><!-- <img src=".\img\分层通信图.jpeg" alt="img" style="zoom:50%;" /> --><p>socket一般分为<strong>TCP网络编程</strong>和<strong>UDP网络编程</strong></p><!-- <img src=".\img\TCP状态转换.jpeg" alt="img"  /><img src=".\img\TCP三次握手.jpeg" alt="img" style="zoom:67%;" /><img src="http://mms0.baidu.com/it/u=3527589293,3143988730&fm=253&app=138&f=JPEG&fmt=auto&q=75?w=500&h=527" alt="img" style="zoom: 80%;" /> --><h2 id="c中的socket">C中的socket</h2><h3 id="socket函数">socket()函数</h3><h4 id="函数声明">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br></code></pre></td></tr></table></figure><h4 id="形参解释">形参解释</h4><ul><li><code>domain</code>: 即协议域，又称为协议族（Protocolfamily），协议族决定了socket的协议类型，在通信中必须采用对应的地址，常用的socket协议域有PF_INET、PF_INET6、PF_LOCAL（或称PF_UNIX，Unix域socket）、RF_ROUTE等等<ul><li><code>PF_INET</code>: 表示IPv4地址</li><li><code>PF_INET6</code>: 表示IPv6地址</li><li>...</li></ul></li><li><code>type</code>:指定socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等<ul><li><code>SOCK_STREAM</code>:流式套接字，使用这种套接字时，数据在客户端是顺序发送的，并且到达的顺序是一致的。比如你在客户端先发送1，再发送2，那么在服务器端的接收顺序是先接收到1，再接收到2，流式套接字是可靠的，是面向连接的；</li><li><code>SOCK_STREAM</code>:数据报套接字，这种套接字是无连接的，数据是打包成数据包发送的，到达的顺序不一定与发送的顺序是一致的，并且数据不一定是可达的，并且接收到的数据还可能出错。</li><li><code>SOCK_RAW</code>: 原始套接字，RawSocket广泛应用于高级网络编程，也是一种广泛的黑客手段。著名的网络sniffer、拒绝服务攻击（DOS）、IP欺骗等都可以以RawSocket实现。Raw Socket直接置"根"于操作系统网络核心（NetworkCore）。当我们使用RawSocket的时候，可以完全自定义IP包，一切形式的包都可以"制造"出来。</li></ul></li><li><code>protocol</code>:指定socket协议，常用的socket协议有IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><p><strong>注意：</strong>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（addressfamily，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="bind函数">bind()函数</h3><p>bind()函数把一个地址族中的特定地址赋给socket，例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket</p><h4 id="函数声明-1">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure><h4 id="形参解释-1">形参解释</h4><ul><li><p><code>sockfd</code>:即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字</p></li><li><p><code>addr</code>: 一个const struct sockaddr*指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，</p><ul><li><p>ipv4对应的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span>    sin_family; <span class="hljs-comment">// 地址族(Address Family)</span><br>    <span class="hljs-type">in_port_t</span>      sin_port;   <span class="hljs-comment">// 16位TCP/UDP端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <span class="hljs-comment">// 32位IP地址</span><br>    <span class="hljs-type">char</span>           sin_zero[<span class="hljs-number">8</span>];<span class="hljs-comment">// 一般不使用，置0</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>       s_addr;     <span class="hljs-comment">// 32位IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>ipv6对应的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-type">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-type">in_port_t</span>       sin6_port;      <br>    <span class="hljs-type">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-type">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>addrlen</code>:对应的地址长度，可以用<code>sizeof(addr)</code>获取</p></li></ul><h3 id="listenconnect函数">listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果作为一个客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><h4 id="函数声明-2">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure><h4 id="形参解释-2">形参解释</h4><ul><li><code>sockfd</code>: socket描述字</li><li><code>backlog</code>: 指相应socket可以排队的最大连接个数</li><li><code>addr</code>: 服务器的socket地址</li><li><code>addrlen</code>: socket地址的长度</li></ul><h4 id="相关要点">相关要点</h4><ul><li><p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求；</p></li><li><p>客户端通过调用connect函数来建立与TCP服务器的连接</p></li><li><p>在调用connect之前不必非得调用bind函数，如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口</p></li></ul><h4 id="tcp套接字connect错误">TCP套接字connect错误</h4><ul><li>若TCP客户端没有收到syn分节的响应，则返回ETIMEOUT错误；调用connect函数时，内核发送一个syn，若无响应则等待6s后再发送一个，若仍然无响应则等待24s后在发送一个，若总共等待75s后仍未收到响应则返回本错误；</li><li>若对客户的syn响应是rst，则表明该服务器在我们指定的端口上没有进程在等待与之连接，这是一种硬错误，客户一收到rst马上返回ECONNREFUSED错误；</li><li>若客户发送的syn在中间的某个路由器上引发了目的不可达icmp错误，则认为是一种软错误。客户主机内核保存该消息，并按照第一种情况的时间间隔继续发送syn，咋某个规定时间后仍未收到响应，则把保存的消息作为EHOSTUNREACH或者ENETUNREACH错误返回给进程；</li></ul><h3 id="accept函数">accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><h4 id="函数声明-3">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br></code></pre></td></tr></table></figure><h4 id="相关要点-1">相关要点</h4><ul><li>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表<strong>与返回客户的TCP连接</strong></li><li>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字</li><li>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</li></ul><h3 id="readwrite等函数">read()、write()等函数</h3><p>服务器与客户端建立好连接后就可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信，网络I/O操作有下面几组：- read()/write() - recv()/send() - readv()/writev() -recvmsg()/sendmsg() - recvfrom()/sendto()</p><p>推荐使用<code>recvmsg()/sendmsg()</code>函数，或者<code>recv()/send()</code>，在Linux 下你用 <code>read</code> 和 <code>write</code> 的话，文件和 socket两者都能读写，只是无法直接设置一些特殊的 flag</p><h4 id="函数声明-4">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                 <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">// 推荐的使用</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> msghdr *msg, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> msghdr *msg, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><h4 id="readwrite函数详解">read/write函数详解</h4><p>read函数是负责从fd中读取内容。当读取成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd，成功时返回写的字节数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符write时有两种可能</p><ol type="1"><li>返回值大于0，表示写了部分或者是全部的数据。</li><li>返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</li></ol><p><strong>注：</strong>其他几对I/O函数可以使用man或者google进行了解</p><h3 id="close函数">close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><h4 id="函数声明-5">函数声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure><h4 id="相关要点-2">相关要点</h4><ul><li>close一个TCPsocket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数</li><li>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</li></ul><h3 id="protocol-families-address-families">Protocol families &amp;Address families</h3><p><strong>协议簇(Protocolfamilies)</strong>：用来指定socket通信过程中的协议，也就是<code>socket()</code>函数的第一个参数</p><p><strong>地址簇(Addressfamilies)</strong>：用来指定socket的地址类型，也就是<code>struct sockaddr</code>的<code>sin_family</code>字段</p><p>其中在一些教程中出现了两者的混用，例如<code>AF_INET, PF_INET</code>两者可以相互使用，在Windows中并无差异，但在Unix/Linux系统中不同版本两者有细微差别。</p><p>因此理论上，建立socket时是指定协议，应该用PF_XXXX，设置地址时应该用AF_XXXX。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。</p><h3 id="其他函数">其他函数</h3><h4 id="setsockopt">setsockopt()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span>;<br></code></pre></td></tr></table></figure><p>setsocket函数用作对socket设置一些选项，或者说是属性，以便于完成更好的功能，其中sockfd指的是待设置选项的socket文件描述符；，例如<code>SOL_SOCKET</code>是在socketAPIlevel；optval指的是选项名；optlen指的是选项大小，一般为<code>sizeof(optval)</code>。</p><p><strong>例如在一个应用场景中</strong>：TCP连接recv()等函数默认为阻塞模式(block)，即直到有数据到来之前函数不会返回，而我们有时则需要一种超时机制使其在一定时间后返回而不管是否有数据到来，这里我们就会用到setsockopt()函数。</p><p><strong>另外一个应用场景</strong>：一般来说一个端口释放后会等待两分钟之后才能再被使用，<code>SO_REUSEADDR</code>是让端口释放后立即就可以被再次使用。<strong>server程序总是应该在调用bind()之前设置SO_REUSEADDR套接字选项，即一般服务器的监听socket都应该打开它，它的大意是允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</strong>。</p><ul><li>服务器启动后，有客户端连接并已建立，如果服务器主动关闭，那么和客户端的连接会处于TIME_WAIT状态，此时再次启动服务器，就会bind不成功，报：Addressalready in use。</li><li>服务器父进程监听客户端，当和客户端建立链接后，fork一个子进程专门处理客户端的请求，如果父进程停止，因为子进程还和客户端有连接，所以再次启动父进程，也会报Addressalready in use。</li></ul><p>通过下面这段代码就可以实现对该应用场景的问题解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> on = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword">sizeof</span>(on))) &lt; <span class="hljs-number">0</span>)  &#123;  <br>        error_die(<span class="hljs-string">&quot;setsockopt failed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getsockname">getsockname()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Put the local address of FD into *ADDR and its length in *LEN.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockname</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br></code></pre></td></tr></table></figure><p>getsockname函数用作返回指定sockfd的sockaddr值，也就是将bind后的地址信息写入到第二个参数中，通常用作获取用户指定的端口号sin_port（<strong>一般是指bind时sin_port为0的情况</strong>）</p><h4 id="pthread_create">pthread_create()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a new thread, starting with execution of START-ROUTINE</span><br><span class="hljs-comment">   getting passed ARG.  Creation attributed come from ATTR.  The new</span><br><span class="hljs-comment">   handle is stored in *NEWTHREAD.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span> <span class="hljs-params">(<span class="hljs-type">pthread_t</span> *__restrict __newthread,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *__restrict __attr,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> *(*__start_routine) (<span class="hljs-type">void</span> *),</span><br><span class="hljs-params">   <span class="hljs-type">void</span> *__restrict __arg)</span> __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))</span>;<br><span class="hljs-comment">//或</span><br><span class="hljs-comment">/* The pthread_create() function starts a new thread in the calling process. The new thread starts execution by invoking start_routine(); arg is passed as the sole argument of start_routine(). */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span><br><span class="hljs-params">                    <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>pthread_create函数用于在调用过程中创建一个新的线程，新线程通过调用<code>start_routine()</code>开始执行；arg 作为<code>start_routine()</code>的唯一参数传递。</p><h2 id="sockaddr-sockaddr_in">sockaddr &amp; sockaddr_in</h2><p><code>struct sockaddr</code>和<code>struct sockaddr_in</code>这两个结构体用来处理网络通信的地址。</p><!-- ![img](.\img\sockaddr&sockaddr_in.png) --><h3 id="sockaddr">sockaddr</h3><p>sockaddr在头文件<code>#include &lt;sys/socket.h&gt;</code>中定义，sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span>  <br>    <span class="hljs-type">sa_family_t</span> sin_family; <span class="hljs-comment">// 地址族</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];       <span class="hljs-comment">// 14字节，包含socket中的目标地址和端口信息               </span><br>&#125;; <br></code></pre></td></tr></table></figure><h3 id="sockaddr_in">sockaddr_in</h3><p>sockaddr_in在头文件<code>#include&lt;netinet/in.h&gt;或#include &lt;arpa/inet.h&gt;</code>中定义，该结构体解决了sockaddr的缺陷，把port和addr分开储存在两个变量中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span>    sin_family; <span class="hljs-comment">// 地址族(Address Family)</span><br>    <span class="hljs-type">in_port_t</span>      sin_port;   <span class="hljs-comment">// 16位TCP/UDP端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <span class="hljs-comment">// 32位IP地址</span><br>    <span class="hljs-type">char</span>           sin_zero[<span class="hljs-number">8</span>];<span class="hljs-comment">// 不使用</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>       s_addr;     <span class="hljs-comment">// 32位IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Tips：当sin_addr为0时，经过bind()系统会自动指定一个端口，可以通过getsockname()函数获取系统指定的端口号。</strong></p><h3 id="注意事项">注意事项</h3><p><code>sin_port</code>和<code>sin_addr</code>都必须是网络字节序（NBO），一般可视化的数字都是主机字节序（HBO），转换函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 将主机字节序转换为网络字节序</span><br><span class="hljs-type">unit32_t</span> <span class="hljs-title function_">htonl</span> <span class="hljs-params">(<span class="hljs-type">unit32_t</span> hostlong)</span>;<br><span class="hljs-type">unit16_t</span> <span class="hljs-title function_">htons</span> <span class="hljs-params">(<span class="hljs-type">unit16_t</span> hostshort)</span>; <span class="hljs-comment">// </span><br><span class="hljs-comment">// 将网络字节序转换为主机字节序</span><br><span class="hljs-type">unit32_t</span> <span class="hljs-title function_">ntohl</span> <span class="hljs-params">(<span class="hljs-type">unit32_t</span> netlong)</span>;<br><span class="hljs-type">unit16_t</span> <span class="hljs-title function_">ntohs</span> <span class="hljs-params">(<span class="hljs-type">unit16_t</span> netshort)</span>;<br><br><span class="hljs-comment">// 说明：h -----host；n----network ；s------short；l----long。</span><br></code></pre></td></tr></table></figure><h4 id="网络字节序nbo">网络字节序NBO</h4><p>网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节？也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题；</p><p>UDP/TCP/IP协议规定：把接收到的第一个字节当作高位字节看待，这就要求发送端发送的第一个字节是高位字节；而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节，也就是说，该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即高位字节存放在低地址处)；由此可见，多字节数值在发送之前,在内存中因该是以<strong>大端法</strong>存放的;</p><p>所以说，<strong>网络字节序是大端字节序</strong>；在实际中，当在两个存储方式不同的主机上传输时，需要借助字节序转换函数。</p><h3 id="总结">总结</h3><ul><li>sockaddr、sockaddr_in两者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以<strong>互相转化</strong>；</li><li>sockaddr、sockaddr_in两者是并列结构，<strong>指向sockaddr_in结构的指针也可以指向sockaddr</strong>；</li><li>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址；sockaddr_in是internet环境下套接字的地址形式</li></ul><p><strong>在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。</strong>一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数</p><h4 id="举个例子">举个例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">mysock</span>;</span><br><br>    sockfd = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);  <span class="hljs-comment">//获得fd</span><br><br>    bzero(&amp;mysock,<span class="hljs-keyword">sizeof</span>(mysock));  <span class="hljs-comment">//初始化结构体</span><br>    mysock.sin_family = AF_INET;  <span class="hljs-comment">//设置地址家族</span><br>    mysock.sin_port = htons(<span class="hljs-number">800</span>);  <span class="hljs-comment">//设置端口</span><br>    mysock.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;192.168.1.0&quot;</span>);  <span class="hljs-comment">//设置地址</span><br>    bind(sockfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;mysock,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr); <span class="hljs-comment">/* bind的时候进行转化 */</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中两个函数 htons() 和 inet_addr()：</p><ul><li><p>htons()作用是将端口号由主机字节序转换为网络字节序的整数值。(hostto net)</p></li><li><p>inet_addr()作用是将一个IP字符串转化为一个网络字节序的整数值，用于<code>sockaddr_in.sin_addr.s_addr</code></p></li><li><p>inet_ntoa()作用是将一个sin_addr结构体输出成IP字符串(network toascii)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,inet_ntoa(mysock.sin_addr));<br></code></pre></td></tr></table></figure></li><li><p>inet_aton()将一个字符串IP地址转换为一个32位的网络序列IP地址。如果这个函数成功，函数的返回值非零，如果输入地址不正确则会返回零</p></li></ul><h5 id="三种给socket赋值地址的方法">三种给socket赋值地址的方法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// function 1:</span><br>inet_aton(server_addr_string, &amp;myaddr.sin_addr);<br><span class="hljs-comment">// function 2:</span><br>myaddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;132.241.5.10&quot;</span>);<br><span class="hljs-comment">// function 3:</span><br>myaddr.sin_addr.s_addr = htons(INADDR_ANY);<br>myaddr.sin_addr.s_addr = INADDR_ANY; <span class="hljs-comment">// 转不转NBO都行</span><br></code></pre></td></tr></table></figure><h5 id="两种给socket赋值端口的方法">两种给socket赋值端口的方法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// function 1:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYPORT 3490</span><br>myaddr.sin_port = htons(MYPORT);<br><span class="hljs-comment">// function 2: 随机端口0</span><br>myaddr.sin_port = htons(<span class="hljs-number">0</span>);<br>myaddr.sin_port = <span class="hljs-number">0</span>; <span class="hljs-comment">// 转不转NBO都行</span><br></code></pre></td></tr></table></figure><h4 id="再举个例子">再举个例子</h4><h5 id="服务器端">服务器端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 1500<span class="hljs-comment">//端口号 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKLOG 5<span class="hljs-comment">/*最大监听数*/</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> sockfd,new_fd;<span class="hljs-comment">/*socket句柄和建立连接后的句柄*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">my_addr</span>;</span><span class="hljs-comment">/*本方地址信息结构体，下面有具体的属性赋值*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">their_addr</span>;</span><span class="hljs-comment">/*对方地址信息*/</span><br>    <span class="hljs-type">int</span> sin_size;<br><br>    sockfd=socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<span class="hljs-comment">//建立socket </span><br>    <span class="hljs-keyword">if</span>(sockfd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket failed:%d&quot;</span>,errno);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    my_addr.sin_family=AF_INET;<span class="hljs-comment">/*该属性表示接收本机或其他机器传输*/</span><br>    my_addr.sin_port=htons(PORT);<span class="hljs-comment">/*端口号*/</span><br>    my_addr.sin_addr.s_addr=htonl(INADDR_ANY);<span class="hljs-comment">/*IP，括号内容表示本机IP*/</span><br>    bzero(&amp;(my_addr.sin_zero),<span class="hljs-number">8</span>);<span class="hljs-comment">/*将其他属性置0*/</span><br>    <span class="hljs-keyword">if</span>(bind(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;my_addr,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr))&lt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//绑定地址结构体和socket</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bind error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>        listen(sockfd,BACKLOG);<span class="hljs-comment">//开启监听 ，第二个参数是最大监听数 </span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            sin_size=<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);<br>            new_fd=accept(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;their_addr,&amp;sin_size);<span class="hljs-comment">//在这里阻塞知道接收到消息，参数分别是socket句柄，接收到的地址信息以及大小 </span><br>            <span class="hljs-keyword">if</span>(new_fd==<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;receive failed&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;receive success&quot;</span>);<br>            send(new_fd,<span class="hljs-string">&quot;Hello World!&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//发送内容，参数分别是连接句柄，内容，大小，其他信息（设为0即可） </span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="客户端">客户端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEST_PORT 1500<span class="hljs-comment">//目标地址端口号 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEST_IP <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-comment">/*目标地址IP，这里设为本机*/</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_DATA 100<span class="hljs-comment">//接收到的数据最大程度 </span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> sockfd,new_fd;<span class="hljs-comment">/*cocket句柄和接受到连接后的句柄 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">dest_addr</span>;</span><span class="hljs-comment">/*目标地址信息*/</span><br>    <span class="hljs-type">char</span> buf[MAX_DATA];<span class="hljs-comment">//储存接收数据 </span><br><br>    sockfd=socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<span class="hljs-comment">/*建立socket*/</span><br>    <span class="hljs-keyword">if</span>(sockfd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket failed:%d&quot;</span>,errno);<br>    &#125;<br><br>    <span class="hljs-comment">//参数意义见上面服务器端 </span><br>    dest_addr.sin_family=AF_INET;<br>    dest_addr.sin_port=htons(DEST_PORT);<br>    dest_addr.sin_addr.s_addr=inet_addr(DEST_IP);<br>    bzero(&amp;(dest_addr.sin_zero),<span class="hljs-number">8</span>);<br>    <br>    <span class="hljs-keyword">if</span>(connect(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;dest_addr,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr))==<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//连接方法，传入句柄，目标地址和大小 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect failed:%d&quot;</span>,errno);<span class="hljs-comment">//失败时可以打印errno </span><br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect success&quot;</span>);<br>        recv(sockfd,buf,MAX_DATA,<span class="hljs-number">0</span>);<span class="hljs-comment">//将接收数据打入buf，参数分别是句柄，储存处，最大长度，其他信息（设为0即可）。 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received:%s&quot;</span>,buf);<br>    &#125;<br>    close(sockfd);<span class="hljs-comment">//关闭socket </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="通讯过程">通讯过程</h5><p>// todo<!-- <img src=".\img\客户端和服务器端通信过程.jpeg" alt="img" style="zoom:50%;" /> --></p><h2 id="java服务器端">Java服务器端</h2><p>socket编程的套路是一定的，客户端和服务器端都是固定不变的编写套路，唯一的差别就在于不同的语言和系统之间可能编码不同、API不同而已。</p><h3 id="java服务器端的代码简单实现">Java服务器端的代码简单实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*; <br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123; <br>ServerSocket server=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">5678</span>); <br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>Socket client=server.accept(); <span class="hljs-comment">// 接受请求</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;接收到连接,消息如下：&quot;</span>);<br>            <span class="hljs-comment">// 获取socket输入流，用于从客户端获取数据</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>                    <span class="hljs-comment">// 一次性读取1024字节的数据</span><br>                    <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> is.read(b);<br>                    <span class="hljs-comment">// 考虑到c语言存在结束符&#x27;\0&#x27;，为了不影响处理，仅读取前len-1个字节</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>);<br>                    deal(msg); <span class="hljs-comment">//TODO</span><br>                    <span class="hljs-comment">// 获取socket输出流，用于向客户端写回数据</span><br>                    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>                    <span class="hljs-comment">// 用写回“123456789”为例，考虑到客户端为c程序，故拼接结束符&#x27;\0&#x27;</span><br>                    os.write(<span class="hljs-string">&quot;123456789\0&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>                    is.close();<br>                    os.close();<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();  <br>client.close();<br>&#125; <br>&#125; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="一种参考的c客户端的代码实现">*一种参考的C客户端的代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_DATA 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEST_IP <span class="hljs-string">&quot;121.248.49.240&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEST_PORT 8888</span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> buf[MAX_DATA];<br><span class="hljs-type">int</span> sockfd;<br><span class="hljs-type">int</span> len;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br><span class="hljs-type">int</span> result;<br><span class="hljs-type">char</span>* ch;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>sockfd = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>address.sin_family = AF_INET;<br>address.sin_addr.s_addr = inet_addr(DEST_IP);<br>address.sin_port = htons(DEST_PORT);<br>len = <span class="hljs-keyword">sizeof</span>(address);<br>ch = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">1024</span>);<br>result = connect(sockfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;address,len);<br><span class="hljs-keyword">if</span>(result == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;oops:client\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你要传输的数据\n&quot;</span>);<br>gets(ch);<span class="hljs-comment">//TODO</span><br>len = <span class="hljs-built_in">strlen</span>(ch);<br>ch[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %s\n&quot;</span>, len, ch);<br>write(sockfd,ch,len+<span class="hljs-number">1</span>);<br>recv(sockfd,buf,MAX_DATA,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s&quot;</span>,buf);<br>close(sockfd);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile 基本知识</title>
    <link href="/2022/09/17/C++/Makefile%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/17/C++/Makefile%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="makefile">Makefile</h1><p>Makerfile是一个可以帮助我们自动化编译的工具，可以用于构建大型项目，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><h2 id="语法">语法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">target: prerequisites</span><br>command<br></code></pre></td></tr></table></figure><p>其中</p><p><code>target</code>是<strong>目标文件</strong>，可以是Objectfile，可执行文件，标签Label；</p><p><code>prerequisites</code>是生成<code>target</code>所需的文件，即<strong>依赖文件</strong>；</p><p><code>command</code>是make需要执行的<strong>命令</strong>，可以是任意的shell指令。</p><h2 id="特殊">特殊</h2><p><code>$@</code>: 目标文件</p><p><code>$^</code>: 所有依赖文件</p><p><code>$&lt;</code>: 第一个依赖文件</p><h2 id="工作原理">工作原理</h2><ul><li><p>如何确保每个目标文件(target)是最新的？</p><blockquote><p>make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令，生成对应的目标文件；反之则不需要操作。</p></blockquote></li><li><p>在某个路径下输入make会发生什么？</p><blockquote><p>make会在当前路径下寻找”makefile“或”Makefile“文件，然后寻找第一个target文件，并把其作为<strong>最终目标文件</strong></p><p>make会从第一个target文件开始，对其依赖文件prerequisites依次检查是否存在且最新，若为否则执行command并生成</p></blockquote></li><li><p>如果make过程中出错怎么办？</p><blockquote><p>这需要分情况，主要有两种：</p><p>若<strong>依赖出错</strong>，即找不到被依赖的文件，且没有生成命令，则报错，并直接退出。</p><p>若<strong>命令出错</strong>，make不会理会，因为它只解决依赖问题。当然除非你的命令出错导致某个依赖文件无法生成，这样最终会导致依赖出错。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些有意思的 Java 项目</title>
    <link href="/2022/06/08/Java/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84Java%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/06/08/Java/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84Java%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="goodforu">GoodForU</h2><p>在动手写代码之前有一些事情很重要，比如调研一下是否有人实现了。私以为当你在开发过程中思考一个模块的设计方法时，停下你的思考，然后去github上找，一定有一个开源项目是存在的且比你的构思更为缜密。这一点尤其是在java项目中体现突出。</p><p>故本文档收集一些项目帮助加快甚至完成开发。</p><h3 id="hutool">hutool</h3><blockquote><p>A set of tools that keep Java sweet.</p></blockquote><p><a href="https://github.com/dromara/hutool">项目地址</a> <ahref="https://www.hutool.cn/docs/#/">中文文档</a></p><h3 id="hertzbeat">HertzBeat</h3><blockquote><p><a href="https://github.com/dromara/hertzbeat">HertzBeat赫兹跳动</a>是由<a href="https://dromara.org/">Dromara</a>孵化，<ahref="https://tancloud.cn/">TanCloud</a>开源的一个支持网站，API，PING，端口，数据库，操作系统等监控类型，拥有易用友好的可视化操作界面的开源监控告警项目。我们也提供了对应的 <strong><ahref="https://console.tancloud.cn/">SAAS版本监控云</a></strong>，中小团队和个人无需再为了监控自己的网站资源，而去部署一套繁琐的监控系统，<strong><ahref="https://console.tancloud.cn/">登录即可免费开始</a></strong>。HertzBeat 支持<ahref="https://hertzbeat.com/docs/advanced/extend-point">自定义监控</a>,只用通过配置YML文件我们就可以自定义需要的监控类型和指标，来满足常见的个性化需求。HertzBeat模块化，<code>manager, collector, scheduler, warehouse, alerter</code>各个模块解耦合，方便理解与定制开发。 HertzBeat支持更自由化的告警配置(计算表达式)，支持告警通知，告警模版，邮件钉钉微信飞书等及时通知送达欢迎登录 HertzBeat 的 <ahref="https://console.tancloud.cn/">云环境TanCloud</a> 试用发现更多。我们正在快速迭代中，欢迎参与加入一起共建项目开源生态。</p></blockquote><blockquote><p><code>HertzBeat</code>的多类型支持，易扩展，低耦合，希望能帮助开发者和中小团队快速搭建自有监控系统。</p></blockquote><p><a href="https://github.com/dromara/hertzbeat">项目地址</a> <ahref="https://hertzbeat.com/">官网地址</a></p><h3 id="sa-token">Sa-Token</h3><blockquote><p><strong>Sa-Token</strong> 是一个轻量级 Java权限认证框架，主要解决：<strong><code>登录认证</code></strong>、<strong><code>权限认证</code></strong>、<strong><code>Session会话</code></strong>、<strong><code>单点登录</code></strong>、<strong><code>OAuth2.0</code></strong>、<strong><code>微服务网关鉴权</code></strong>等一系列权限相关问题</p></blockquote><p><a href="https://github.com/dromara/Sa-Token">项目地址</a> <ahref="https://sa-token.dev33.cn/index.html">官网地址</a></p><h3 id="okhttps">okhttps</h3><blockquote><p>OkHttps 是近期开源的对 OkHttp3轻量封装的框架，它独创的异步预处理器，特色的标签，灵活的上传下载进度监听与过程控制功能，在轻松解决很多问题的同时，设计上也力求纯粹与优雅。</p><ul><li>超级优雅的 API 设计，且链式调用，让你顺滑到底！</li><li>BaseURL、URL占位符、HTTP 同步异步、WebSocket，让你想干啥就干啥！</li><li>JSON、Xml等自动封装与解析，且支持与任意格式的数据解析框架集成，想用啥就用啥！</li><li>同步拦截器、异步预处理器、回调执行器、全局监听、回调阻断等等，让你扩展无限功能！</li><li>文件上传下载（过程控制、进度监听），上传下载如此简单！</li><li>单方法回调，充分利用 Lambda 表达式，让你代码超级简洁！</li><li>超级轻量，但性能卓越！</li></ul></blockquote><p><a href="https://github.com/ejlchina/okhttps">项目地址</a> <ahref="https://okhttps.ejlchina.com/">官网地址</a></p><h3 id="java-native-access-jna">Java Native Access (JNA)</h3><blockquote><p>The definitive JNA reference (including an overview and usagedetails) is in the <ahref="http://java-native-access.github.io/jna/5.11.0/javadoc/">JavaDoc</a>.Please read the <ahref="http://java-native-access.github.io/jna/5.11.0/javadoc/overview-summary.html#overview_description">overview</a>.Questions, comments, or exploratory conversations should begin on the <ahref="http://groups.google.com/group/jna-users">mailing list</a>,although you may find it easier to find answers to already-solvedproblems on <ahref="http://stackoverflow.com/questions/tagged/jna">StackOverflow</a>.</p><p>JNA provides Java programs easy access to native shared librarieswithout writing anything but Java code - no JNI or native code isrequired. This functionality is comparable to Windows' Platform/Invokeand Python's ctypes.</p><p>JNA allows you to call directly into native functions using naturalJava method invocation. The Java call looks just like the call does innative code. Most calls require no special handling or configuration; noboilerplate or generated code is required.</p><p>JNA uses a small JNI library stub to dynamically invoke native code.The developer uses a Java interface to describe functions and structuresin the target native library. This makes it quite easy to take advantageof native platform features without incurring the high overhead ofconfiguring and building JNI code for multiple platforms. Read this <ahref="https://github.com/java-native-access/jna/blob/master/www/FunctionalDescription.md">morein-depth description</a>.</p><p>While significant attention has been paid to performance, correctnessand ease of use take priority.</p><p>In addition, JNA includes a platform library with many nativefunctions already mapped as well as a set of utility interfaces thatsimplify native access.</p></blockquote><p><a href="https://github.com/java-native-access/jna">项目地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC 学习笔记</title>
    <link href="/2022/06/08/Java/Spring/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/08/Java/Spring/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="springmvc">SpringMVC</h1><!-- <img title="" src=".\img\SpringMVC总览.bmp" alt="image-20220318235631736"><img src=".\img\springmvc执行流程原理.jpg" alt="image-20220318235631736"  /> --><h2 id="servletapi">ServletAPI</h2><p>SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数，支持原始ServletAPI 对象有：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>java.security.Principal</li><li>Locale</li><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ul><p><strong>我们可以直接把这些对象写在控制的方法参数中使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testServletAPI&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testServletAPI</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                             HttpServletResponse response,</span><br><span class="hljs-params">                             HttpSession session)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用注解">常用注解</h2><ul><li><p><code>@RequestParam</code></p><ul><li><strong>把请求中指定名称的参数给控制器中的形参赋值</strong>。</li><li>属性：<ul><li>value: 请求参数中的名称。</li><li>required:请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/useRequestParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">useRequestParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String username,</span><br><span class="hljs-params">                              <span class="hljs-meta">@RequestParam(value=&quot;age&quot;,required=false)</span> Integer age)</span>&#123;<br>    System.out.println(username+<span class="hljs-string">&quot;,&quot;</span>+age);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@RequestBody</code></p><ul><li>用于<strong>获取请求体内容</strong>。直接使用得到是key=value&amp;key=value... 结构的数据。</li><li>get 请求方式不适用。</li><li>属性：<ul><li>required: 是否必须有请求体。默认值是:true。当取值为 true 时，get请求方式会报错。如果取值 为 false，get 请求得到是 null。</li></ul></li></ul></li><li><p><code>@PathVaribale</code></p><ul><li>用于<strong>绑定 url 中的占位符</strong>。例如：请求 url 中<code>/delete/&#123;id&#125;</code>，这个{id}就是 url 占位符</li><li>url 支持占位符是 spring3.0 之后加入的，是 springmvc 支持 rest 风格URL 的一个重要标志。</li><li>属性：<ul><li>value: 用于指定 url 中占位符名称。</li><li>required: 是否必须提供占位符。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">usePathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;<br>    System.out.println(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@RequestHeader</code></p><ul><li>用于<strong>获取请求消息头</strong>。</li><li><strong>在实际开发中一般不怎么用。</strong></li><li>属性：<ul><li>value: 提供消息头名称。</li><li>required: 是否必须有此消息头。</li></ul></li></ul></li><li><p><code>@CookieValue</code></p><ul><li>用于把<strong>指定 cookie 名称的值传入控制器方法参数</strong>。</li><li>属性：<ul><li>value：指定 cookie 的名称。</li><li>required：是否必须有此 cookie。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/useCookieValue&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">useCookieValue</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value=&quot;JSESSIONID&quot;,required=false)</span> String cookieValue)</span>&#123;<br>    System.out.println(cookieValue);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@ModelAttribute</code></p><ul><li>用来<strong>将请求参数绑定到 Model 对象</strong>。</li><li>需要注意的是，因为<strong>模型对象要先于 controller方法之前创建，所以被 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span> 注解的方法会在Controller 每个方法执行之前都执行。因此一个 Controller 映射多个 URL时，要谨慎使用。</strong><ul><li>因此可以用作<strong>控制登录权限</strong>，当然控制登录权限的方法有很多，例如拦截器、过滤器等。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法有返回值</span><br><span class="hljs-meta">@ModelAttribute(&quot;name&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">myModel</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false)</span> String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-comment">// 等同于 model.addAttribute(&quot;name&quot;, name);</span><br><br><span class="hljs-comment">// 方法无返回值</span><br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myModel</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false)</span> String name, Model model)</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接受请求参数">接受请求参数</h2><p>Spring MVC Controller 接收请求参数的方式有很多种，有的适合 get请求方式，有的适合 post请求方式，有的两者都适合。主要有以下几种方式：</p><ul><li><p>通过实体 Bean 接收请求参数</p></li><li><p>通过处理方法的形参接收请求参数</p></li><li><p>通过 HttpServletRequest 接收请求参数</p></li><li><p>通过 <span class="citation"data-cites="PathVariable">@PathVariable</span> 接收 URL中的请求参数</p></li><li><p>通过 <span class="citation"data-cites="RequestParam">@RequestParam</span> 接收请求参数</p><ul><li>和<strong>通过实体 Bean 接收请求参数</strong>相比会报404错误</li></ul></li><li><p>通过 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span> 接收请求参数</p><ul><li><p><code>@ModelAttribute</code>注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用</p></li><li><p><strong>通过实体 Bean接收请求参数</strong>中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过实体Bean接受请求参数</span><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(User user, Model model)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bianchengbang&quot;</span>.equals(user.getName())<br>            &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(user.getPwd())) &#123;<br><br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;main&quot;</span>; <span class="hljs-comment">// 登录成功，跳转到 main.jsp</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 通过@ModelAttribute接受请求参数</span><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User user, Model model)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bianchengbang&quot;</span>.equals(name)<br>            &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(pwd)) &#123;<br><br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;main&quot;</span>; <span class="hljs-comment">// 登录成功，跳转到 main.jsp</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="重定向和转发">重定向和转发</h2><p><strong>重定向(redirect)：</strong>将用户从当前处理请求定向到另一个视图（例如JSP）或处理请求，以前的请求（request）中存放的信息<strong>全部失效</strong>，并进入一个新的request 作用域。</p><p><strong>转发(forward)：</strong>将用户对当前处理的请求转发给另一个视图或处理请求，以前的request 中存放的信息<strong>不会失效</strong>。</p><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><h3 id="转发过程">转发过程</h3><p>客户浏览器发送 http 请求，Web服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个Web 容器下的 URL，其<strong>不能转向到其他的 Web路径上</strong>，中间传递的是自己的容器内的 request。</p><p><strong>在客户浏览器的地址栏中显示的仍然是其第一次访问的路径</strong>，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</p><h3 id="重定向过程">重定向过程</h3><p>客户浏览器发送 http 请求，Web 服务器接受后<strong>发送 302状态码</strong>响应及对应新的 location 给客户浏览器，客户浏览器发现是302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location地址，服务器根据此请求寻找资源并发送给客户。</p><p>在这里 location 可以重定向到任意URL，既然是浏览器重新发出了请求，那么就没有什么 request传递的概念了。在客户浏览器的地址栏中显示的是其重定向的路径，客户可以观察到地址的变化。<strong>重定向行为是浏览器做了至少两次的访问请求</strong>。</p><h3 id="特别的">特别的</h3><p>在 Spring MVC框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要DispatcherServlet 的资源，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/html/my.html&quot;</span>;<br></code></pre></td></tr></table></figure><p>则需要使用 mvc:resources 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;mvc:resources location=&quot;/html/&quot; mapping=&quot;/html/**&quot; /&gt;<br></code></pre></td></tr></table></figure><h2 id="model和modelandview">Model和ModelAndView</h2><p>Model：每次请求中都存在的默认参数，利用其 addAttribute()方法即可将服务器的值传递到客户端页面中。</p><p>ModelAndView：包含 model 和 view 两部分，使用时需要自己实例化，利用ModelMap 来传值，也可以设置 view 的名称。</p><h2 id="类型转换器">类型转换器</h2><p>Converter&lt;S,T&gt;将一种数据类型转换成另一种数据类型的接口，<strong>源类型可以是任意数据类型</strong>。</p><p>//TODO</p><h2 id="格式化转换器">格式化转换器</h2><p>Formatter&lt;T&gt;将一种数据类型转换成另一种数据类型的接口，<strong>源类型必须是String 类型</strong>。</p><p>//TODO</p><h2 id="hiddenthttpmethodfilter">HiddentHttpMethodFilter</h2><h3 id="作用">作用</h3><p>由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method并不支持，Spring3.0添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持GET、POST、PUT 与 DELETE 请求。</p><h3 id="使用方法">使用方法</h3><p>第一步：在 web.xml 中配置该过滤器。</p><p>第二步：请求方式必须使用 post 请求。</p><p>第三步：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。</p><h3 id="举个例子">举个例子</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;springmvc/testRestDELETE/1&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    &lt;!--这里hidden的_method--&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;_method&quot;</span> value=<span class="hljs-string">&quot;DELETE&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;删除&quot;</span>&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><h2 id="post方式">Post方式</h2><p>主要通过控制 <code>Content-Type</code>来控制Post方式，主要包括以下四种方式。</p><h3id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h3><p>以<code>key-value</code>键值对拼接的形式，如<code>name=abc&amp;phone=123456</code></p><p>Java后端可以通过<code>@RequestParam</code>获取指定<code>key</code>对应的参数，或者直接通过对象映射，例如</p><p><strong>方法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doLogin</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> WebLoginParam webLoginParam)</span> &#123;<br>    System.out.println(webLoginParam);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebLoginParam</span> &#123;<br><br>    <span class="hljs-meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@NotBlank(message = &quot;密码不能为空&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doLogin</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; webLoginParam)</span> &#123;<br>    Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = webLoginParam.entrySet();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;<br>        System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span>+entry.getValue());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">username: abc</span><br><span class="hljs-comment">password: 123456</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>若请求格式为<code>http://localhost:8080/api/user?page=1&amp;size=10&amp;_search=1&amp;username=&amp;role=user&amp;status=&amp;createTime=&amp;updateTime=</code></p><p>则 Map 对应存储的 <code>key-value</code> 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">page: <span class="hljs-number">1</span><br>size: <span class="hljs-number">10</span><br>_search: <span class="hljs-number">1</span><br>username: <span class="hljs-comment">//value非null，而是空值&quot;&quot;</span><br>role: user<br>status: <br>createTime: <br>updateTime: <br></code></pre></td></tr></table></figure><h3 id="applicationjson">application/json</h3><p>以 json 格式，如<code>&#123;"name":"abc","phone":"123456"&#125;</code></p><h3 id="multipartform-data">multipart/form-data</h3><p><code>multipart/form-data</code>是基于 post方法来传递数据的，并且其请求内容格式为<code>Content-Type: multipart/form-data</code>,用来指定请求内容的数据编码格式。另外，该格式会生成一个boundary字符串来分割请求头与请求体的，具体的是以一个<code>boundary=$&#123;boundary&#125;</code>来进行分割，伪码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: multipart/form-data; boundary=$&#123;boundary&#125; <br><br>--$&#123;boundary&#125;<br>...<br>...<br><br>--$&#123;boundary&#125;--<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">POST</span> <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.example.com HTTP/1.1</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>:multipart/form-data; boundary=----<span class="hljs-title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA<br><br>------<span class="hljs-title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Disposition</span>: form-data; name=<span class="hljs-string">&quot;text&quot;</span><br><br>title<br>------<span class="hljs-title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Disposition</span>: form-data; name=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;chrome.png&quot;</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: image/png<br><br><span class="hljs-variable constant_">PNG</span> ... content <span class="hljs-keyword">of</span> chrome.<span class="hljs-property">png</span> ...<br>------<span class="hljs-title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA--<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 生成器配置文件详解</title>
    <link href="/2022/04/13/Java/Mybatis%E7%94%9F%E6%88%90%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/04/13/Java/Mybatis%E7%94%9F%E6%88%90%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置生成器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项</span><br><span class="hljs-comment">    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        </span><br><span class="hljs-comment">    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.</span><br><span class="hljs-comment">    注意，两个属性只能选址一个;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用</span><br><span class="hljs-comment">&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;</span><br><span class="hljs-comment"> --&gt;</span><br><br> <span class="hljs-comment">&lt;!-- 在MBG工作的时候，需要额外加载的依赖包</span><br><span class="hljs-comment">     location属性指明加载jar/zip包的全路径</span><br><span class="hljs-comment">&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">    context:生成一组对象的环境 </span><br><span class="hljs-comment">    id:必选，上下文id，用于在生成错误时提示</span><br><span class="hljs-comment">    defaultModelType:指定生成对象的样式</span><br><span class="hljs-comment">        1，conditional：类似hierarchical；</span><br><span class="hljs-comment">        2，flat：所有内容（主键，blob）等全部生成在一个对象中；</span><br><span class="hljs-comment">        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)</span><br><span class="hljs-comment">    targetRuntime:</span><br><span class="hljs-comment">        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；</span><br><span class="hljs-comment">        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；</span><br><span class="hljs-comment">    introspectedColumnImpl：类全限定名，用于扩展MBG</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">defaultModelType</span>=<span class="hljs-string">&quot;hierarchical&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span> &gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；</span><br><span class="hljs-comment">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoDelimitKeywords&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生成的Java文件的编码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javaFileEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 格式化java代码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;javaFormatter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 格式化XML代码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xmlFormatter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beginningDelimiter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;`&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;endingDelimiter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;`&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 必须要有的，使用这个配置链接数据库</span><br><span class="hljs-comment">        @<span class="hljs-doctag">TODO:</span>是否可以扩展</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> </span><br><span class="hljs-tag"><span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql:///pss&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- java类型处理器 </span><br><span class="hljs-comment">        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；</span><br><span class="hljs-comment">        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； </span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型</span><br><span class="hljs-comment">            false：默认,</span><br><span class="hljs-comment">                scale&gt;0;length&gt;18：使用BigDecimal;</span><br><span class="hljs-comment">                scale=0;length[10,18]：使用Long；</span><br><span class="hljs-comment">                scale=0;length[5,9]：使用Integer；</span><br><span class="hljs-comment">                scale=0;length&lt;5：使用Short；</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- java模型创建器，是必须要的元素</span><br><span class="hljs-comment">        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类</span><br><span class="hljs-comment">        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；</span><br><span class="hljs-comment">        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com._520it.mybatis.domain&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  for MyBatis3/MyBatis3Simple</span><br><span class="hljs-comment">            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;constructorBased&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- for MyBatis3 / MyBatis3Simple</span><br><span class="hljs-comment">            是否创建一个不可变的类，如果为true，</span><br><span class="hljs-comment">            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;immutable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 设置一个根对象，</span><br><span class="hljs-comment">            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项</span><br><span class="hljs-comment">            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：</span><br><span class="hljs-comment">                1，属性名相同，类型相同，有相同的getter/setter方法；</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rootClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com._520it.mybatis.domain.BaseDomain&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 生成SQL map的XML文件生成器，</span><br><span class="hljs-comment">        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），</span><br><span class="hljs-comment">            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置</span><br><span class="hljs-comment">        targetPackage/targetProject:同javaModelGenerator</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com._520it.mybatis.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 </span><br><span class="hljs-comment">        targetPackage/targetProject:同javaModelGenerator</span><br><span class="hljs-comment">        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：</span><br><span class="hljs-comment">            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；</span><br><span class="hljs-comment">            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；</span><br><span class="hljs-comment">            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；</span><br><span class="hljs-comment">        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com._520it.mybatis.mapper&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ANNOTATEDMAPPER&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查</span><br><span class="hljs-comment">        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">         --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素</span><br><span class="hljs-comment">        选择的table会生成一下文件：</span><br><span class="hljs-comment">        1，SQL map文件</span><br><span class="hljs-comment">        2，生成一个主键类；</span><br><span class="hljs-comment">        3，除了BLOB和主键的其他字段的类；</span><br><span class="hljs-comment">        4，包含BLOB的类；</span><br><span class="hljs-comment">        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；</span><br><span class="hljs-comment">        6，Mapper接口（可选）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        tableName（必要）：要生成对象的表名；</span><br><span class="hljs-comment">        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会</span><br><span class="hljs-comment">            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：</span><br><span class="hljs-comment">            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；</span><br><span class="hljs-comment">            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；</span><br><span class="hljs-comment">            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；</span><br><span class="hljs-comment">            4，否则，使用指定的大小写格式查询；</span><br><span class="hljs-comment">        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；</span><br><span class="hljs-comment">        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        可选：</span><br><span class="hljs-comment">        1，schema：数据库的schema；</span><br><span class="hljs-comment">        2，catalog：数据库的catalog；</span><br><span class="hljs-comment">        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName</span><br><span class="hljs-comment">        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；</span><br><span class="hljs-comment">        5，enableInsert（默认true）：指定是否生成insert语句；</span><br><span class="hljs-comment">        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；</span><br><span class="hljs-comment">        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；</span><br><span class="hljs-comment">        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；</span><br><span class="hljs-comment">        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；</span><br><span class="hljs-comment">        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；</span><br><span class="hljs-comment">        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；</span><br><span class="hljs-comment">        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；</span><br><span class="hljs-comment">        13，modelType：参考context元素的defaultModelType，相当于覆盖；</span><br><span class="hljs-comment">        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）</span><br><span class="hljs-comment">        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;userinfo&quot;</span> &gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;constructorBased&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ignoreQualifiersAtRuntime&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;immutable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;modelOnly&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 参考 javaModelGenerator 的 rootClass 属性 </span><br><span class="hljs-comment">        &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">         --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 参考javaClientGenerator 的  rootInterface 属性</span><br><span class="hljs-comment">        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog </span><br><span class="hljs-comment">        &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema </span><br><span class="hljs-comment">        &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename </span><br><span class="hljs-comment">        &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 注意，该属性只针对MyBatis3Simple有用；</span><br><span class="hljs-comment">            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;selectAllOrderByClause&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;age desc,username asc&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useActualColumnNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br><br>        <span class="hljs-comment">&lt;!-- generatedKey用于生成生成主键的方法，</span><br><span class="hljs-comment">            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选</span><br><span class="hljs-comment">            column:主键的列名；</span><br><span class="hljs-comment">            sqlStatement：要生成的selectKey语句，有以下可选项：</span><br><span class="hljs-comment">                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span><br><span class="hljs-comment">                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span><br><span class="hljs-comment">                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1</span><br><span class="hljs-comment">                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()</span><br><span class="hljs-comment">                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()</span><br><span class="hljs-comment">                Informix  :相当于selectKey的SQL为：select dbinfo(&#x27;sqlca.sqlerrd1&#x27;) from systables where tabid=1</span><br><span class="hljs-comment">                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()</span><br><span class="hljs-comment">                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()</span><br><span class="hljs-comment">                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY</span><br><span class="hljs-comment">                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性</span><br><span class="hljs-comment">        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;</span><br><span class="hljs-comment">         --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，</span><br><span class="hljs-comment">            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；</span><br><span class="hljs-comment">            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是</span><br><span class="hljs-comment">            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，</span><br><span class="hljs-comment">            如果使用了columnOverride元素，该属性无效；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;</span><br><span class="hljs-comment">         --&gt;</span><br><br><br>         <span class="hljs-comment">&lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；</span><br><span class="hljs-comment">             column:要重新设置的列名；</span><br><span class="hljs-comment">             注意，一个table元素中可以有多个columnOverride元素哈~</span><br><span class="hljs-comment">          --&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">columnOverride</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;property&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;userName&quot;</span>/&gt;</span><br><br>             <span class="hljs-comment">&lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名</span><br><span class="hljs-comment">             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">              --&gt;</span><br><br>             <span class="hljs-comment">&lt;!-- jdbcType用于指定该列的JDBC类型 </span><br><span class="hljs-comment">             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">              --&gt;</span><br><br>             <span class="hljs-comment">&lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名</span><br><span class="hljs-comment">                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler</span><br><span class="hljs-comment">                 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述</span><br><span class="hljs-comment">             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">             --&gt;</span><br><br>             <span class="hljs-comment">&lt;!-- 参考table元素的delimitAllColumns配置，默认为false</span><br><span class="hljs-comment">             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">              --&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">columnOverride</span>&gt;</span><br><br>         <span class="hljs-comment">&lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 </span><br><span class="hljs-comment">             column:指定要忽略的列的名字；</span><br><span class="hljs-comment">             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             注意，一个table元素中可以有多个ignoreColumn元素</span><br><span class="hljs-comment">         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;</span><br><span class="hljs-comment">         --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kernel 学习</title>
    <link href="/2021/12/17/OS/Kernel/"/>
    <url>/2021/12/17/OS/Kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-kernel">Linux Kernel</h1><h2 id="c-相关知识">C 相关知识</h2><h3 id="链接link">链接(Link)</h3><p>C语言代码经过编译以后，并没有生成最终的可执行文件（.exe文件），而是生成了一种叫做目标文件（ObjectFile）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的</p><p>对于 Visual C++，目标文件的后缀是<code>.obj</code>；对于GCC，目标文件的后缀是<code>.o</code></p><p>目标文件并不能直接执行，首先需要载入到链接器中，链接器确认main函数为初始进入点，把符号引用绑定到内存地址，把所有的目标文件集中在一起，在加上库文件，从而产生可执行文件</p><h4 id="静态链接">静态链接</h4><p>函数库的一份拷贝是可执行文件的物理组成部分</p><p>静态链接的模块被<strong>链接-编辑</strong>并<strong>载入</strong>以便运行</p><h4 id="动态链接">动态链接</h4><p>可执行文件只是包含了文件名，载入器在运行时寻找程序所需的函数库</p><p>动态链接的模块被<strong>链接-编辑</strong>后<strong>载入</strong>，并在<strong>运行时链接</strong>以便运行</p><h3 id="回调函数">回调函数</h3><p>回调函数的好处和作用就是<strong>解耦</strong></p><blockquote><p><strong>来自维基百科的对回调（Callback）的解析：</strong>In computerprogramming, a callback is any executable code that is passed as anargument to other code, which is expected to call back (execute) theargument at a given time. This execution may be immediate as in asynchronous callback, or it might happen at a later time as in anasynchronous callback.也就是说，把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。</p><p><strong>来自Stack Overflow某位大神简洁明了的表述：</strong>A"callback" is any function that is called by another function whichtakes the first function as a parameter。 也就是说，函数 F1 调用函数 F2的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数F2 执行的过程中，函数F2 调用了函数F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数F3 就是回调函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;softwareLib.h&gt;</span> <span class="hljs-comment">// 包含Library Function所在读得Software library库的头文件</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Callback</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// Main program</span><br>&#123;<br>    <span class="hljs-comment">// TODO</span><br>    Library(Callback);<br>    <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要我们改变传进库函数的参数，就可以实现不同的功能，这样是很灵活的，并且丝毫不需要修改库函数的实现，这就是解耦。</p><h4 id="带参的回调函数">带参的回调函数</h4><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Callback_1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// Callback Function 1</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_1: x = %d &quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Callback_2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// Callback Function 2</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_2: x = %d &quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Callback_3</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// Callback Function 3</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_3: x = %d &quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Handle</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> (*Callback)(<span class="hljs-type">int</span>))</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Entering Handle Function. &quot;</span>);<br>    Callback(y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Leaving Handle Function. &quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Entering Main Function. &quot;</span>);<br>    Handle(a, Callback_1);<br>    Handle(b, Callback_2);<br>    Handle(c, Callback_3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Leaving Main Function. &quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出是通过增加一个参数来保存回调函数的参数值。</p><h3 id="预处理指令">预处理指令</h3><p>常见的预处理指令：</p><ul><li><code>#define</code> 宏定义</li><li><code>#undef</code> 未定义宏</li><li><code>#include</code> 文本包含</li><li><code>#ifdef</code> 如果宏被定义就进行编译</li><li><code>#ifndef</code> 如果宏未被定义就进行编译</li><li><code>#endif</code> 结束编译块的控制</li><li><code>#if</code> 表达式非零就对代码进行编译</li><li><code>#else</code> 作为其他预处理的剩余选项进行编译</li><li><code>#elif</code> 这是一种#else和#if的组合选项</li><li><code>#line</code> 改变当前的行数和文件名称</li><li><code>#error</code> 输出一个错误信息</li><li><code>#pragma</code> 为编译程序提供非常规的控制流信息</li></ul><h4 id="include">#include</h4><p>对于<code>#include &lt;io.h&gt;</code> ，编译器从标准库路径开始搜索对于<code>#include "io.h"</code>，编译器从用户的工作路径开始搜索</p><h4 id="error">#error</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNIX</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> This software requires the UNIX OS.</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="progma">#progma</h4><p><code>#progma</code>主要功能是为编译程序提供非常规的控制流信息</p><h4 id="预定义标识符">预定义标识符</h4><p>为了处理一些有用的信息，预处理定义了一些预处理标识符，虽然各种编译器的预处理标识符不尽相同，但是他们都会处理下面这4种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">__FILE__ 正在编译的文件的名字<br><br>__LINE__ 正在编译的文件的行号<br><br>__DATE__ 编译时刻的日期字符串，例如： <span class="hljs-string">&quot;25 Dec 2000&quot;</span><br><br>__TIME__ 编译时刻的时间字符串，例如： <span class="hljs-string">&quot;12:30:55&quot;</span><br>    <br> eg. <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The file is :&quot;</span>&lt;&lt;__FILE__<span class="hljs-string">&quot;&lt;&lt;&quot;</span>! The lines is:<span class="hljs-string">&quot;&lt;&lt;__LINE__&lt;&lt;endl;</span><br></code></pre></td></tr></table></figure><h2 id="posix标准">POSIX标准</h2><ul><li><p>POSIX，Portable Operating SystemInterface，是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux</p></li><li><p>POSIX是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称</p></li><li><p>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证</p></li><li><p>当前的POSIX主要分为四个部分：Base Definitions、SystemInterfaces、Shell and Utilities和Rationale</p></li></ul><p>POSIX大约有100个过程调用，其中最主要的过程调用如下被分为四类：</p><ul><li>进程管理<ul><li><code>pid = fork</code>：创建与父进程相同的子进程</li><li><code>pid = waitpid(pid, &amp;statloc, options)</code>：等待一个子进程终止</li><li><code>s = execve(name, argv, environp)</code>：替换一个进程的核心映像</li><li><code>exit(status)</code>：终止进程执行并返回状态</li></ul></li><li>文件管理<ul><li><code>fd = open(file, how, ...)</code>：打开一个文件供读、写或两者</li><li><code>s = close(fd)</code>：关闭一个打开的文件</li><li><code>n = read(fd, buffer, nbytes)</code>：把数据从一个文件读到缓冲区中</li><li><code>n = write(fd, buffer, nbytes)</code>：把数据从缓冲区写到一个文件中</li><li><code>position = lseek(fd, offset, whence)</code>：移动文件指针</li><li><code>s = stat(name, &amp;buf)</code>：取得文件的状态信息</li></ul></li><li>目录和文件系统管理<ul><li><code>s = mkdir(name, mode)</code>：创建一个新目录</li><li><code>s = rmdir(name)</code>：删除一个空目录</li><li><code>s = link(name1, name2)</code>：创建一个新目录项name2，并指向name1</li><li><code>s = unlink(name)</code>：删去一个目录项</li><li><code>s = mount(special, name, flag)</code>：安装一个文件系统</li><li><code>s = umount(special)</code>：卸载一个文件系统</li></ul></li><li>杂项<ul><li><code>s = chdir(dirname)</code>：改变工作目录</li><li><code>s = chmod(name, mode)</code>：修改一个文件的保护位</li><li><code>s = kill(pid, signal)</code>：发送信号给一个进程</li><li><code>seconds = time(&amp;seconds)</code>：自1970年1月1日起的流逝时间</li></ul></li></ul><h2 id="头文件">头文件</h2><ul><li>unistd.h<ul><li>Linux/Unix系统内置的头文件，包含了许多系统服务的函数原型，例如read函数、write函数和getpid函数等</li><li>其作用相当于windows操作系统的"windows.h"，是操作系统为用户提供的统一API接口，方便调用系统提供的一些服务</li></ul></li></ul><h2 id="makefile-grammar">Makefile Grammar</h2><p>Makefile文件里描述的是编译的时候依赖关系，宏定义，编译参数，链接生成的程序名字等等</p><h3 id="文件包含">文件包含</h3><ul><li>include 文件名<ul><li>将其他makefile文件包含进来，形成更大的makefile文件</li></ul></li></ul><h3 id="变量定义">变量定义</h3><ul><li>变量名 := 变量值<ul><li>变量定义</li></ul></li><li>变量名 += 变量值1 [变量值2] [...]<ul><li>追加新的变量值</li></ul></li><li>自动变量<ul><li>自动变量的值会依据规则中的target 和prerequisites自动计算其值，以$开始</li><li>**$<span class="citation" data-cites="*">@*</span>*为规则中的target名称</li><li><strong>$&lt;</strong> 为规则中第一个prerequisite名称</li></ul></li></ul><h3 id="内置命令">内置命令</h3><ul><li><p>字符串处理函数：subst、patsubst、strip、findstring、filter、filter-out、sort、word、wordlist、words、firstword、lastword</p></li><li><p>文件名处理函数：dir、notdir、suffix、basename、addsuffix、addprefix、join、wildcard、realpath、abspath</p><ul><li><p>dir</p><ul><li><p>$(dir name1 [name2] […])</p></li><li><p>获取name中文件对应的路径</p></li><li><p><strong>E.g.</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> src/foo.c hacks)</span> <span class="hljs-comment"># 获取src/ ./两个路径</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>nodir</p><ul><li><p>$(dir name1 [name2] […])</p></li><li><p>获取name中除去路径的信息</p></li><li><p><strong>E.g.</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> src/foo.c hacks)</span> <span class="hljs-comment"># 获取foo.c hacks两个文件信息</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>basename</p><ul><li><p>$(basename name1 [name2] […])</p></li><li><p>获取names中除去后缀信息</p></li><li><p><strong>E.g.</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> src/foo.c src/bar.b hacks.c)</span> <span class="hljs-comment"># 获得信息src/foo src/bar hacks</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>addsuffix</p><ul><li>$(addsuffix suffix,name1 [name2] […])</li></ul></li><li><p>wildcard</p><ul><li><p>$(wildcard pattern)</p></li><li><p>pattern为匹配的模式</p></li><li><p><strong>E.g.</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> %.c)</span> 查找当前目录下文件名以.c结尾的文件<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>条件循环函数：if</p></li><li><p>循环处理函数：foreach</p><ul><li><p>foreach</p><ul><li><p>$(foreach var, list, text)</p></li><li><p>每循环一次var从list中按顺序取值一个</p></li><li><p><strong>E.g.</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">dirs := C_DIR S_DIR<br>file := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(dirs)</span>,$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*)</span>) <span class="hljs-comment"># 将C_DIR和S_DIR文件夹下面的所有文件添加到file变量中</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="源码编译">源码编译</h2><p>源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(makeinstall)、卸载(make uninstall)</p><h3 id="configure">configure</h3><p><code>configure</code>通常检查环境，配置编译条件，一般是一个可执行脚本，有很多选项，在待安装的源码路径下使用命令./configure–help输出详细的选项列表。一般用来生成Makefile，为下一步的编译做准备。</p><ol type="1"><li><p>./configure --prefix</p><p>它的作用是配置安装路径，如：<code>./configure --prefix=/usr</code>，意思是将该软件安装在/usr下面，执行文件就会安装在/usr/bin，资源文件就会安装在/usr/share，--prefix选项还有一个好处：卸载的时候，直接删除一个文件夹(安装目录)即可；移植软件也只需拷贝整个目录到另外一个机器即可(相同的操作系统)。</p></li><li><p>./configure</p><p>不配置--prefix选项，安装后可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr/local/share</p></li></ol><h3 id="make">make</h3><p><code>make</code>命令从Makefile中读取指令，然后进行编译。</p><p>大多数的源代码包都经过这一步进行编译(当然有些<strong>perl</strong>或<strong>python</strong>编写的软件需要调用perl或python来进行编译)。如果在make过程中出现error,你就要记下错误代码(注意不仅仅是最后一行),然后你可以向开发者提交,bugreport(一般install里有提交地址)，或者你的系统少了一些依赖库等,这些需要自己仔细研究错误代码。</p><h3 id="make-install">make install</h3><p><code>make install</code>指令用来安装，从Makefile中读取指令，安装到指定的位置。<strong>安装的时候一般都需要root权限。</strong></p><p>在<code>make install</code>之前有些软件需要先运行<code>make check</code>或<code>make test</code>来进行一些测试。</p><h3 id="make-uninstall">make uninstall</h3><p><code>make uninstall</code>指令用来卸载，在原先make的目录下运行，但前提是makefile文件指定过uninstall，如果没有指定则需要手动删除。</p><h3 id="其他">其他</h3><p>当我们在使用make命令时，常常会在make后面加上其他单词，比如check，install，installcheck…这些单词都是make的参数，我们称之为“目标（targets）”。</p><p>最常见的几个target：</p><ul><li>make all：编译程序、库、文档等（等同于make）</li><li>makeinstall：安装已经编译好的程序。复制文件树中到文件到指定的位置</li><li>make unistall：卸载已经安装的程序。</li><li>make clean：删除由make命令产生的文件</li><li>make distclean：同时删除./configure和make产生的临时文件</li><li>make check/make test：测试刚刚编译的软件（某些程序可能不支持）</li><li>make installcheck：检查安装的库和程序（某些程序可能不支持）</li><li>make dist：重新打包成packname-version.tar.gz</li></ul><h2 id="gcc">GCC</h2><h3 id="几种常见的gcc参数">几种常见的gcc参数</h3><ul><li><code>gcc -I /home/hello/include</code><ul><li>表示将/home/hello/include作为第一个寻找头文件的目录</li><li>寻找顺序依次是：/home/hello/include --&gt; /usr/include --&gt;/usr/local/include</li></ul></li><li><code>gcc -L /home/hello/lib</code><ul><li>表示将/home/hello/lib作为第一个寻找库文件的目录</li><li>寻找顺序依次是：/home/hello/lib --&gt; /usr/lib --&gt;/usr/local/lib</li></ul></li><li><code>gcc -lworld</code><ul><li>在上面的lib的路径中寻找libworld.so动态库文件，如果gcc编译选项中加入了“-static”表示寻找libworld.a静态库文件，程序链接的库名是world</li></ul></li><li><code>gcc -shared hello.c -o libhello.so</code><ul><li>将hello.c编译成动态链接库</li></ul></li><li><code>gcc -E hello.c -o test.i</code><ul><li>将test.c预处理输出test.i文件</li></ul></li><li><code>gcc -S test.i</code><ul><li>将预处理输出文件test.i汇编成test.s文件</li></ul></li><li><code>gcc -c hello.c</code><ul><li>仅执行编译操作，不进行连接操作。将hello.c编译成hello.o</li></ul></li><li><code>gcc hello.c</code><ul><li>将hello.c编译成一个a.out的可执行文件</li></ul></li><li><code>gcc hello.c -o hello</code><ul><li>将hello.c编译出一个名为test的可执行文件，-o用作指定输出文件的文件名</li></ul></li><li><code>gcc hello.c -O2</code><ul><li>默认进行O0优化，-O1进行O1优化，-O2进行O2优化，-O3进行O3优化</li></ul></li></ul><h3 id="常见的错误">常见的错误</h3><ul><li><code>xxxx.h: No such file or directory</code>：引用出错，使用参数<code>-I</code><ul><li><code>-I</code>参数可以用相对路径，比如头文件在当前目录，可以用<code>-I.</code>来指定</li></ul></li><li><code>undefined reference to 'xxxxx'</code>：链接错误，应该指定链接程序要用到的库，使用参数<code>-l</code>指定</li><li><code>/usr/bin/ld: cannot find -lxxx</code>：表明链接程序ld在那3个库文件目录里找不到libxxx.so，使用参数<code>-L</code>指定<ul><li>大部分libxxxx.so只是一个链接，以RH9为例，比如libm.so它链接到/lib/libm.so.x，/lib/libm.so.6又链接到/lib/libm<strong>-</strong>2.3.2.so，如果没有这样的链接，还是会出错，因为ld只会找libxxxx.so，所以如果你要用到xxxx库，而只有libxxxx.so.x或者libxxxx-x.x.x.so，做一个链接就可以了<code>ln -s libxxxx-x.x.x.so libxxxx.so</code></li></ul></li></ul><h2 id="pthread--lpthread">-pthread &amp; -lpthread</h2><p>一般情况下我们在链接一个（文件名为libxxx.so或libxxx.a等）库时，会使用<code>-lxxx</code>的方式；在Linux中要用到多线程时，需要链接pthread库，按照惯例，我们应该使用<code>-lpthread</code>的方式来进行链接；但很多开源代码都是使用了<code>-pthread</code>参数，而非使用<code>-lpthread</code>，这是因为：</p><ol type="1"><li><strong>为了可移植性：</strong>在Linux中，pthread是作为一个单独的库存在的（libpthread.so），但是在其他Unix变种中却不一定，比如在FreeBSD中是没有单独的pthread库的，因此在FreeBSD中不能使用<code>-lpthread</code>来链接pthread，而使用<code>-pthread</code>则不会出现这个问题，因为FreeBSD的编译器能正确地将<code>-pthread</code>展开为该系统下的依赖参数。同样的，其他不同的变种也会存在差异。为了保持较高的可移植性，我们最好使用<code>-pthread</code>，即使它目前不是C标准，但基本上是事实标准</li><li><strong>添加额外的标志：</strong>在多数系统中，<code>-pthread</code>会被展开为<code>-D_REENTRANT -lpthread</code>，即除了链接pthread库外，还先定义了宏_REENTRANT。定义这个宏的目的，是为了打开系统头文件中的各种多线程支持分支。比如我们常常使用的错误码标志errno，如果没有定义_REENTRANT，则实现为一个全局变量；反之则会为每个线程所独有，从而避免线程竞争错误</li></ol><p>目前gcc 4.5.2中已经没有了关于-lpthread的介绍了。所以以后的多线程编译应该用<code>-pthread</code>，而不是<code>-lpthread</code>。</p><h2 id="linux-操作">Linux 操作</h2><h3 id="下载文件-wget">下载文件 wget</h3><ul><li>wget -O-<ul><li>-O 会把url中获取的数据统一写入 '-O' 指定的file中，这里是写到 '-'中，即打印到标准输出，通常为控制台，进而可以通过管道传输给其他命令</li></ul></li></ul><h3 id="添加环境变量">添加环境变量</h3><h4 id="暂时添加">暂时添加</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=./:$PATH #（将当前路径加入PATH，运行执行文件的时候不必再采用./file的形式，二是直接file即可）<br></code></pre></td></tr></table></figure><h4 id="为当前用户永久添加环境变量">为当前用户永久添加环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim ~/.bashrc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加以下文本</span><br>export PATH=&quot;新增的环境变量:$PATH&quot;<br></code></pre></td></tr></table></figure><p>退出 vim 后需要 <code>source ~/.bashrc</code>，让环境立即生效。</p><h4id="为所有用户永久添加某一环境变量">为所有用户永久添加某一环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/profile</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加以下文本</span><br>export PATH=&quot;新增的环境变量:$PATH&quot;<br></code></pre></td></tr></table></figure><p>退出 vim 后需要<code>source /etc/profile</code>，让环境立即生效。</p><h4 id="etcenvironment-下面添加">/etc/environment 下面添加</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/environment</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加环境变量</span><br></code></pre></td></tr></table></figure><p>退出 vim 后需要<code>source /etc/environment</code>，让环境立即生效。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++相关基础知识</title>
    <link href="/2021/03/15/C++/C++%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/03/15/C++/C++%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="c与c的区别">C与C++的区别</h2><h3 id="const与指针">Const与指针</h3><table><thead><tr class="header"><th></th><th>指向常量的指针</th><th>常指针</th><th>指向常量的常指针</th></tr></thead><tbody><tr class="odd"><td>格式</td><td>const 类型名* 指针名</td><td>类型名* const 指针名</td><td>const 类型名* const 指针名</td></tr><tr class="even"><td>示例</td><td>const int* p = &amp;x;</td><td>int* const p = &amp;x;</td><td>const int* const p = &amp;x;</td></tr><tr class="odd"><td>可修改的值</td><td>p, x</td><td>*p, x</td><td>x</td></tr><tr class="even"><td>不可修改的值</td><td>*p</td><td>p</td><td>p, *p</td></tr></tbody></table><h3 id="名字空间与域解析符">名字空间与域解析符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> one &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">namespace</span> two &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> one;<br><span class="hljs-comment">// using namespace two;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> two::a;<br>    a = <span class="hljs-number">-100</span>;<br>    <span class="hljs-comment">// cout&lt;&lt;b&lt;&lt;endl; error: reference to &#x27;b&#x27; is ambiguous</span><br>    cout&lt;&lt;a&lt;&lt;endl; <span class="hljs-comment">// -100</span><br>    cout&lt;&lt;one::a&lt;&lt;endl; <span class="hljs-comment">// 0</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当两个同时使用两个命名空间时，若命名空间中含有相同变量名时直接使用会提示错误<code>error: reference to 'b' is ambiguous</code></li><li>在C++语言中，通过在同名变量前加上域解析符<code>::</code>对被隐藏的同名全局变量进行访问</li></ul><h3 id="内联函数">内联函数</h3><ul><li><p>内联函数的出现是为了代替宏定义，以一种更为安全的方式进行<strong>代码替换</strong></p></li><li><p>工作原理：在程序<strong>编译</strong>时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换</p></li><li><p>内联函数进行的是代码的替换，所以会在编译后增加代码的体量，但节省了调用函数的时间</p></li><li><p>由于内联函数的特性，所以在内联函数中不允许使用循环语句和开关语句；若内联函数中存在这些语句，则编译器优化其为普通函数，对其进行调用和返回</p></li><li><p>类中的成员函数可以理解为内联函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> defineMutiply(x, y) x*y</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">inlindeMutiply</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x*y;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> define = <span class="hljs-built_in">defineMutiply</span>(<span class="hljs-number">3</span>+<span class="hljs-number">4</span>, <span class="hljs-number">2</span>+<span class="hljs-number">3</span>); <span class="hljs-comment">// 3+4*2+3 = 14</span><br>    <span class="hljs-type">int</span> Inline = <span class="hljs-built_in">inlindeMutiply</span>(<span class="hljs-number">3</span>+<span class="hljs-number">4</span>, <span class="hljs-number">2</span>+<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;define = &quot;</span>&lt;&lt;define&lt;&lt;endl; <span class="hljs-comment">// define = 14</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Inline = &quot;</span>&lt;&lt;Inline&lt;&lt;endl; <span class="hljs-comment">// Inline = 35</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用">引用</h3><p><strong>“变量一样的用法，指针一样的功能”</strong></p><p>格式：</p><ol type="1"><li><p>数据类型 &amp;引用名 = 已定义的变量名;</p></li><li><p>类型名&amp; 函数名(形式参数表);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> &amp;y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    z++;<br>    y = x + y + z;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-built_in">Fun</span>(a, b, c);<br>d = <span class="hljs-built_in">Fun</span>(a, b, c);<br><span class="hljs-built_in">Fun</span>(a, b, c) = <span class="hljs-number">20</span>; <span class="hljs-comment">//相当于b = 20;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><p>声明引用时&amp;表示引用的一个声明，不代表取地址</p></li><li><p>声明引用时必须对它进行初始化，以明确该引用是哪个对象的别名，而且之后引用的别名关系不可改</p></li><li><p>引用只是某个变量的一个别名，所以系统不会为引用分配内存空间</p></li><li><p>引用作为返回值的函数存在特殊要求</p><ul><li><p>return 后面只能是变量，而不能是常量或表达式</p></li><li><p>return后面变量的内存空间再本次函数调用结束后应当仍然存在</p></li><li><p>return 后面不能是常引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//常引用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> &amp;b = a;<br><span class="hljs-comment">// b++; // error: increment of read-only reference &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>不能建立空引用、引用的引用、指向引用的指针、引用数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误示范</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>, a[<span class="hljs-number">10</span>];<br><span class="hljs-type">void</span> &amp;r = x;<br><span class="hljs-type">int</span> &amp;&amp;r = x;<br><span class="hljs-type">int</span> &amp;*p = x;<br><span class="hljs-type">int</span> &amp;arr[<span class="hljs-number">10</span>] = a;<br></code></pre></td></tr></table></figure></li></ul><p>引用与指针的比较：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">引用</th><th style="text-align: center;">指针</th></tr></thead><tbody><tr class="odd"><td>实质</td><td style="text-align: center;">变量（对象）的别名</td><td style="text-align: center;">指向变量（对象）的地址</td></tr><tr class="even"><td>初始化</td><td style="text-align: center;">必须进行初始化</td><td style="text-align: center;">非必须，事后可以赋值</td></tr><tr class="odd"><td>可变性</td><td style="text-align: center;">一旦成为某个变量的别名，则不可更改</td><td style="text-align: center;">可以更改指针的指向</td></tr><tr class="even"><td>是否有空值</td><td style="text-align: center;">不可为空，一旦声明必须初始化</td><tdstyle="text-align: center;">可以置为空指针NULL，表示不指向任何变量</td></tr><tr class="odd"><td>占用内存情况</td><td style="text-align: center;">不额外占用空间，只是所指对象</td><tdstyle="text-align: center;">另外占用4字节空间，用来存储变量的地址</td></tr><tr class="even"><td>访问方式</td><td style="text-align: center;">直接使用引用名访问</td><td style="text-align: center;">使用<code>*指针名</code>访问</td></tr><tr class="odd"><td>安全有效性</td><td style="text-align: center;">安全，始终为某个变量的别名</td><td style="text-align: center;">安全，不一定有效，可能成为野指针</td></tr></tbody></table><h3 id="内存申请管理">内存申请管理</h3><p>使用new申请内存，使用delete释放内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ptr, *ptrArray;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">// 申请1个int大小的空间</span><br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 申请1个int大小的空间，并赋值为10</span><br>ptrArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 申请10个int大小的空间，并将数组地址返回给ptr</span><br><br><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放指针ptr所指向的空间</span><br><span class="hljs-comment">// delete ptrArray; // 释放ptrArray所指向的数组的第一个地址，即释放了int大小的空间，不推荐</span><br><span class="hljs-keyword">delete</span> []ptrArray; <span class="hljs-comment">// 释放ptrArray所指向的数组的全部空间</span><br></code></pre></td></tr></table></figure><ul><li><strong>建议不要将C++的new、delete和存储管理函数malloc、calloc、free混合使用</strong></li></ul><p><strong>内存泄露：用new申请的内存必须要用delete来加以释放，否则会导致动态分配的内存无法回收，使得程序占据的内存越来越大</strong></p><p>内存申请的区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">当用户自定义默认构造函数时，以下两种写法都是调用默认构造函数</span><br><span class="hljs-comment">当用户没有自定义默认构造函数时，结果不同</span><br><span class="hljs-comment">*/</span><br>T* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 除了调用系统生成的隐含的默认构造函数外，还会为基本数据类型和指针类型的成员用0赋初值</span><br>T* p = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">// 调用系统生成的隐含的默认构造函数</span><br></code></pre></td></tr></table></figure><p>创建多维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建方式</span><br><span class="hljs-built_in">float</span> (*cp)[<span class="hljs-number">9</span>][<span class="hljs-number">8</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[<span class="hljs-number">8</span>][<span class="hljs-number">9</span>][<span class="hljs-number">8</span>];<br><span class="hljs-comment">// 访问方式</span><br>*(*(*(cp+i)+j))<br></code></pre></td></tr></table></figure><h3 id="void类型指针">void类型指针</h3><p>void类型指针表示不确定类型的指针，即一种通用类型的指针，任何指针都可以直接赋值给void类型的指针</p><p>注意事项：</p><ul><li><p>可以定义void类型的指针，但是不能定义void类型的引用和变量</p></li><li><p>void类型的指针只是可以接受任何类型指针变量的赋值，但是不可以直接使用void类型指针访问内存中的内容，需要做一个显示类型转换。</p><p>例如C中的malloc函数的返回是一个void*类型，当进行赋值时需要根据申请空间的变量类型进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 申请一个大小为10的int数组</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="异常处理">异常处理</h3><p>C++语言中异常处理通过以下3步实现：</p><ol type="1"><li>检查异常（try）</li><li>抛出异常（throw）</li><li>捕捉异常（catch）</li></ol><p>其中抛出异常再可能出现异常的<strong>当前函数</strong>处理，检查异常和捕捉异常在<strong>上级函数</strong>中处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">divide</span>(a, b);<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">int</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;except of divide zero&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;finished&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>throw语句格式：<code>throw &lt;表达式&gt;; 或 throw ;</code></p><p>try-catch语句格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//&lt;被进行异常检查的语句&gt;</span><br>&#125;<br><span class="hljs-built_in">catch</span>(<span class="hljs-comment">/*&lt;异常信息类型&gt;或&lt;变量&gt;*/</span>) &#123;<br>    <span class="hljs-comment">//&lt;异常处理语句&gt;</span><br>&#125;<br>&lt;<span class="hljs-built_in">catch</span>(<span class="hljs-comment">/*..*/</span>)&#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>try块一定要在catch块前面，try和catch块之间不能有任何其他语句</li><li>可以只有try块，没有catch块，即捕捉到异常后不做处理</li><li>只能有一个try块，而对应可以有多个catch块，即针对throw出的不同异常来进行分情况处理</li></ul><h2 id="类与对象">类与对象</h2><h3 id="类的定义">类的定义</h3><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 类名 &#123;<br>[<span class="hljs-keyword">private</span>: ]<br>    <span class="hljs-comment">// 私有成员变量或成员函数</span><br>[<span class="hljs-keyword">protected</span>: ]<br>    <span class="hljs-comment">// 保护成员变量或成员函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公有成员变量或成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>private为类默认的访问类型</li><li>public、protected和private书写顺序无严格限制</li></ul><table><thead><tr class="header"><th>访问属性</th><th>含义</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>private</td><td>私有成员</td><td>只允许该类的成员函数及友元访问，不能被其他函数访问</td></tr><tr class="even"><td>protected</td><td>保护成员</td><td>既允许该类的成员函数及友元访问，也允许其派生类的成员函数访问</td></tr><tr class="odd"><td>public</td><td>公有成员</td><td>既允许该类的成员函数访问，也允许类外部的其他函数访问</td></tr></tbody></table><ul><li>在C++中，结构体类型也可以有数据成员和成员函数两大组成部分，其<strong>定义方式与类的定义基本一致</strong>，只是将关键字class替换成struct即可。二者最大的区别就是：<strong>class定义中类成员的默认访问属性为private，而struct定义中结构成员的默认访问属性为public</strong>，因此类的封装和信息隐藏特性要好于结构体</li></ul><h3 id="类的访问">类的访问</h3><p>通过对象来访问类中的成员，方式分为两种：</p><ul><li><p>圆点访问形式</p><p><code>对象名.成员 或 (*指向对象的指针).成员</code></p></li><li><p>指针访问形式</p><p><code>对象指针变量名-&gt;成员 或 (&amp;对象名)-&gt;成员</code></p></li></ul><p><strong>this</strong>指针指向存放当前对象的地址，每个成员函数都存在一个隐含的this指针</p><h3 id="构造函数与析构函数">构造函数与析构函数</h3><p>构造函数格式：<code>类名 ([形式参数列表]) 或 类名::类名 ([形式参数列表])</code></p><ul><li><p>当在类外实现成员函数时，需要加限定符：<code>类名::</code></p></li><li><p><strong>构造函数在对象创建时由系统调用，所以在程序中就不能调用对象的构造函数</strong></p></li><li><p>构造函数没有返回类型，构造函数名必须与类名相同</p></li><li><p>构造函数为public类型，否则定义对象时无法自动调用构造函数，编译时也会出现错误提示</p></li><li><p>对于一个用户自定义的类，若用户定义时未定义构造函数，则编译器自动生成一个<strong>默认的无参构造函数</strong>，定义对象时会自动调用该构造函数；若用户定义了构造函数，则编译器不会生成无参构造函数。当定义对象时没有提供实际的参数，编译器就会查找无参的构造函数；如果类中已定义了其他有参构造函数而没有定义无参的构造函数，C++编译器就会给出一个错误提示</p></li></ul><p>析构函数格式：<code>~类名() 或 类名::~类名()</code></p><ul><li><p><strong>析构函数在对象创建时由系统调用，所以在程序中就不能调用对象的析构函数</strong></p></li><li><p>析构函数没有返回类型，同时应当声明为public类型，否则编译器会报错</p></li><li><p><strong>每个类中只有一个析构函数，析构函数因为其特点所以不能重载</strong></p></li><li><p>系统提供一个默认的析构函数，即使不定义析构函数也可以使用，但是当成员变量中含有指针类型的成员时，需要在析构函数中进行内存释放，保证对象生存期结束时释放所有的内存空间</p></li></ul><h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3><p>系统为每一个类提供了默认拷贝构造函数，可以实现将源对象所有数据成员的值逐一赋值给目标对象相应的数据成员。但是该拷贝为<strong>浅拷贝</strong>，不能拷贝成员变量中的指针数据类型，只能进行指针的指向，当源对象销毁后指针内存释放，此时目标对象成员变量的指针变为了<strong>悬挂指针</strong>，其所指内存不属于当前程序，析构时报错</p><p>当类中没有定义拷贝构造函数时，系统使用默认的拷贝构造函数，当对象作为参数传递时，依然为浅拷贝，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a, b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b):<span class="hljs-built_in">a</span>(a), <span class="hljs-built_in">b</span>(b) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Test test)</span> </span>&#123;<br>    test.<span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    test.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 2, b = 3</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    t1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 1, b = 2</span><br>    <span class="hljs-built_in">fun</span>(t1);<br>    t1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 1, b = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象数组">对象数组</h3><p>初始化：<code>Date dt[2] = &#123;Date(2011, 5, 1), Date(2020, 6, 1)&#125;</code></p><h3 id="对象指针">对象指针</h3><p>格式：<code>类名 *对象指针名</code></p><p>用指针引用对象成员的方法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">指针变量名-&gt;成员名 或 (*指针变量名).成员名<br>(对象数组名+下标)-&gt;成员名 或 *(对象数组名+下标).成员名<br></code></pre></td></tr></table></figure><h3 id="对象引用">对象引用</h3><ul><li>对象引用与一般变量的引用一样，是一个已经定义对象的别名，引用本身不再另外占用内存空间。</li><li>对象引用只是某对象的别名、引用与它代表的对象共享同一个单元。</li><li>引用必须在定义时初始化，并且在程序运行过程中不能让引用成为另一个对象的别名</li></ul><h3 id="友元">友元</h3><p>友元的三种形式：</p><ul><li>一个不属于其他任何类的普通函数声明为当前类的友元，称为当前类的<strong>友元函数</strong></li><li>一个其他类的成员函数声明为当前类的友元，称为当前类的<strong>友元成员</strong></li><li>另一个类声明为当前类的友元，称为当前类的<strong>友元类</strong></li></ul><p>使用友元可以避免频繁调用类的接口函数，提高程序的运行速度，从而提高程序的运行效率</p><h4 id="友元函数">友元函数</h4><p>形式：<code>friend 函数返回类型 函数名(形式参数表);</code></p><p><strong>注意事项：</strong></p><ol type="1"><li>通常友元函数时在类的定义中给出原型声明，声明的位置任意，不受访问属性的限制，声明之后的友元函数在类外面给出完整定义，此时前面不能再加关键字friend</li><li>友元函数也可以在类内部直接给出定义，定义的首部相当于原型声明</li><li>友元函数的定义和调用方式与普通函数相同</li><li>友元函数提供了不同类成员函数之间、类的成员函数与普通函数之间进行数据共享的机制，尤其是一个函数需要访问多个类时，友元函数非常有用</li><li>友元毕竟是打破了封装和信息隐藏机制，因此在安全性和效率之间需做折中处理</li></ol><h4 id="友元成员">友元成员</h4><p>形式：<code>friend 函数返回类型 友元类名::函数名(形式参数表);</code></p><p><strong>注意事项：</strong></p><ol type="1"><li>一个类的成员函数作为另一个类的友元成员时，必须先定义这个类</li><li><strong>对于先使用后定义的标识符都应当给出向前引用声明</strong></li></ol><h4 id="友元类">友元类</h4><p>形式：<code>friend 类名;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>友元类的声明是单向的，不具有交换性，即声明友元的类未必是被声明类的友元</p></li><li><p>友元关系不具备传递性，即A类将B类声明为友元，B类将C类声明为友元，此时C类还不是A类的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> year, month, day;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">friend</span> Person;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Date &amp;date)</span> </span>&#123;<br>        date.<span class="hljs-built_in">getDate</span>();<br>        date.year = <span class="hljs-number">2001</span>;<br>        date.month = <span class="hljs-number">12</span>;<br>        date.day = <span class="hljs-number">30</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类中数据的共享与保护">类中数据的共享与保护</h2><h3 id="静态成员">静态成员</h3><p>静态成员包括<strong>静态数据成员</strong>和<strong>静态成员函数</strong></p><h4 id="静态数据成员">静态数据成员</h4><p>静态数据成员声明形式：<code>static 类型名 静态数据成员名</code></p><p>静态数据成员访问形式：<code>类名::公有静态成员变量名; 或 对象名.公有静态成员变量名</code></p><p>静态数据成员是同类对象共享的，事实上，它在<strong>该类的任何对象被创建前就已经存在</strong>，因此其初始化工作<strong>不能通过类的构造函数</strong>完成，而必须在类定义结束之后进行，默认值为0，静态数据成员是在编译时创建并初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> total;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::total = <span class="hljs-number">1</span>;<span class="hljs-comment">// 类定义结束之后初始化</span><br></code></pre></td></tr></table></figure><h4 id="静态成员函数">静态成员函数</h4><p>静态成员函数声明形式：<code>static 返回值类型 静态成员函数名(形式参数表)</code></p><p>静态成员函数访问形式：<code>类名::静态成员函数名(实际参数表); 或 对象名.静态成员函数名(实际参数表);</code></p><h3 id="共享数据的保护">共享数据的保护</h3><h4 id="常数据成员">常数据成员</h4><p>定义形式：<code>const 类型名 常数据成员名</code></p><p>常数据成员的初始化<strong>只能在构造函数的初始化列表</strong>中进行，不能在构造函数的函数体中用赋值等语句实现，而普通数据成员两种方式均可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> sex;<br>    <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">bool</span> sex, <span class="hljs-type">int</span> age):<span class="hljs-built_in">sex</span>(sex)&#123;<span class="hljs-comment">// 不可以放到函数体中</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态常数据成员：</strong>在常数据成员定义<strong>之前</strong>增加一个关键字static</p><p>静态常数据成员的初始化不可以放在初始化列表中完成了，与静态数据成员类似，要在类定义结束后单独初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> PI;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Person::PI = <span class="hljs-number">3.14</span>;<span class="hljs-comment">// 类定义结束之后初始化</span><br></code></pre></td></tr></table></figure><h4 id="常成员函数">常成员函数</h4><p>声明形式：<code>类型 函数名(形式参数表) const;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>关键字const可以作为与其他成员函数重载的标志，即以下写法正确</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 非常对象t.print()默认情况下调用不带const的函数 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>常成员函数不能修改本类的数据成员，因此也不能调用该类中未经关键字const修饰的普通成员函数。但是反过来，普通成员函数可以调用常成员函数。</p></li></ol><h4 id="常对象">常对象</h4><p>定义形式：<code>类名 const 对象名;</code> 或<code>const 类名 对象名;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>常对象类比基本数据类型中的常量，在定义常对象时<strong>必须进行初始化</strong>，而且其对象的数据成员值不能修改</p></li><li><p>常对象只能调用它的常成员函数而不能调用普通的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;general print.&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;const print.&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> Test t1;<br>    Test t2;<br>    t1.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// const print.</span><br>    t2.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// general print.</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类与类之间的关系">类与类之间的关系</h2><p>类与类之间存在3种关系：组合(Composition)、依赖(Dependency)和继承(Inheritance)</p><p>组合(Composition)：C类中包含了A类和B类的对象作为成员变量，即<strong>对象成员</strong></p><p>依赖(Dependency)：C类的某个函数实现需要B类的对象作为参数</p><p>继承(Inheritance)：C类为B类的<strong>派生类</strong>，B类为C类的<strong>基类</strong></p><p><strong>UML中类与类之间关系：</strong></p><ul><li>依赖关系（实心箭头虚线）</li><li>作用关系——关联（实线 重数）</li><li>包含关系——聚集和组合<ul><li>聚集（部分消失整体存在）（空心菱形 重数）</li><li>组合（部分消失则整体消失）（实心菱形 重数）</li></ul></li><li>继承关系——泛化（空心三角实线）</li></ul><h3 id="对象成员">对象成员</h3><ul><li><p>对象成员在创建时需要调用构造函数，在退出时需要调用析构函数</p></li><li><p><strong>对象与它内部的对象成员具有相同的生命周期</strong></p></li><li><p>创建一个对象时，构造函数的调用次序是：<strong>首先调用对象成员的构造函数，再调用对象自身的构造函数</strong>，析构时相反</p></li><li><p>对象成员构造函数的调用次序与初始化表中出现的次序无关，它始终<strong>与对象成员在类中定义的次序一致</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123;<br>        x = a;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A: x = &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    A a1, a2;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c):<span class="hljs-built_in">a2</span>(b), <span class="hljs-built_in">a1</span>(a) &#123; <span class="hljs-comment">//当初始化对象成员时，需要写到初始化列表里</span><br>        y = c;<br>        cout&lt;&lt;<span class="hljs-string">&quot;B: y = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-comment">// 执行结果为：</span><br>    <span class="hljs-comment">// A: x = 10</span><br>    <span class="hljs-comment">// A: x = 20</span><br>    <span class="hljs-comment">// B: y = 30</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="基类与派生类">基类与派生类</h3><p>在面向对象程序设计的语境中，旧类称为<strong>基类</strong>，也称作<strong>父类</strong>，新类称为<strong>派生类</strong>，也称为<strong>子类</strong></p><p>在C++中，一个基类可以派生出多个派生类，一个派生类也可以有多个基类，派生类可作为新的基类，继续派生出新的派生类</p><p><strong>继承</strong>通常分为<strong>单一继承</strong>和<strong>多重继承</strong>两大类。单一继承是指一个派生类只有一个基类，多重继承是指派生类有多个基类。<strong>C++支持多重继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object1</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object2</span><br><span class="hljs-comment">// 继承Object1，为Object1的派生类，Student的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-keyword">public</span> Object1 &#123;&#125;;<br><span class="hljs-comment">// 继承People，为People的派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">public</span> People &#123;&#125;;<br><span class="hljs-comment">// 多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object3</span>: <span class="hljs-keyword">public</span> Object1, <span class="hljs-keyword">public</span> Object2 &#123;&#125;;<br></code></pre></td></tr></table></figure><p><strong>继承方式</strong>共有3种：public（公有）、protected（保护）和private（私有），<strong>如果缺省，则默认为私有继承方式</strong></p><table><thead><tr class="header"><th></th><th>公有成员</th><th>保护成员</th><th>私有成员</th></tr></thead><tbody><tr class="odd"><td>公有继承public</td><td>公有成员</td><td>保护成员</td><td>不继承</td></tr><tr class="even"><td>保护继承protected</td><td>保护成员</td><td>保护成员</td><td>不继承</td></tr><tr class="odd"><td>私有继承private</td><td>私有成员</td><td>私有成员</td><td>不继承</td></tr></tbody></table><p><strong>定义一个派生类对象时，构造函数的调用顺序为：</strong></p><ul><li>基类的构造函数</li><li>派生类对象成员的构造函数（按照定义顺序）</li><li>派生类的构造函数</li></ul><p>大部分构造函数需要传入一定的参数来初始化成员，此时需要在派生类构造函数的初始化列表中对基类构造函数进行调用，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;派生类名&gt; (总形式参数表):&lt;基类名1&gt;(&lt;参数表1&gt;), </span><br><span class="hljs-comment">  &lt;基类名2&gt;(&lt;参数表2&gt;)[, ...&lt;基类名n&gt;(&lt;参数表n&gt;)],</span><br><span class="hljs-comment">  [&lt;对象成员名1&gt;(&lt;参数表1&gt;), ...],</span><br><span class="hljs-comment">  [&lt;其他初始化项&gt;]&#123;</span><br><span class="hljs-comment">    [&lt;派生类自身数据成员的初始化&gt;]                          </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    Base b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Drived</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">Base</span>(x), <span class="hljs-built_in">b</span>(x) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>构造派生类对象时，就要对基类的成员对象和新增成员对象进行初始化</li><li>如果对基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数</li></ul><h3 id="同名冲突">同名冲突</h3><h4 id="派生类与基类同名冲突">派生类与基类同名冲突</h4><p>派生类在定义新成员时，新成员的名称与基类中的某个成员同名，此时同名覆盖原则将发挥作用，即无论是派生类内部成员函数还是派生类对象访问同名成员，如果未加任何特殊标识，则访问的都是派生类中新定义的同名成员</p><p>如果派生类内部成员或派生类对象需要访问基类的同名成员，则必须在同名成员前面加上<strong>“基类名::”</strong>进行限定</p><p><strong>注意事项：</strong></p><ul><li>通过派生类的指针或引用，访问的是派生类的同名成员，此时同名覆盖原则依然发挥作用</li><li><strong>基类的指针指向派生类对象时，访问的依然是基类中的同名成员</strong></li><li>基类的引用成为派生类对象别名时，访问的也依然是基类中的同名成员</li></ul><h4 id="多个直接基类引发的同名冲突">多个直接基类引发的同名冲突</h4><p>多重继承中多个直接基类中有同名成员，此时派生类中访问这些成员时，将发生同名冲突问题</p><p>其解决方案与上种冲突类似，在成员前指明基类名即可</p><h4id="共同祖先基类多重拷贝引发的同名冲突">共同祖先基类多重拷贝引发的同名冲突</h4><p>派生类有多个直接或间接的基类，在这些基类中，有一个基类是其余某些基类的共同祖先，派生类访问这些成员时，将发生同名冲突问题</p><p>解决方法：引入<strong>虚基类</strong></p><h5id="虚基类从不同路径继承过来的同名数据成员在内存中只有一个副本同一个函数名也只有一个映射">虚基类：从不同路径继承过来的同名数据成员在内存中只有一个副本，同一个函数名也只有一个映射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var1;<br>    <span class="hljs-built_in">base1</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base2</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var2;<br>    <span class="hljs-built_in">base2</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span>: <span class="hljs-keyword">public</span> base1, <span class="hljs-keyword">public</span> base2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">derived</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base1</span>(var), <span class="hljs-built_in">base2</span>(var), <span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有派生类均调用虚基类的构造函数，<strong>但C++规定只有最后一层派生类对虚基类构造函数的调用发挥作用</strong>，即上述例子中，只有derived真正调用，其余均被忽略</p><p><strong>构造一个类的对象一般的顺序：</strong></p><ol type="1"><li>如果该类含有直接或间接虚基类，则先执行虚基类的构造函数</li><li>如果该类有其他基类，则按照他们在<strong>继承声明列表中出现的次序</strong>，分别执行它们的构造函数，但构造过程中，不再执行他们的虚基类的构造函数</li><li>按照定义中出出现的顺序，对派生类中新增的成员对象进行初始化。对类类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定的参数执行构造函数，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋值，否则什么也不做</li><li>执行构造函数的函数体</li></ol><h3 id="赋值兼容规则">赋值兼容规则</h3><p>赋值兼容就是指需要使用<strong>基类</strong>的地方可以使用其<strong>公有派生类</strong>来代替</p><p>理论依据：公有派生类继承了基类中除构造函数、析构函数以外的所有非私有成员，且访问权限也完全相同</p><p>常见情形：</p><ul><li><p>基类对象 = 公有派生类对象</p><p>赋值后的基类对象只能获得基类成员部分，派生类中新增加的成员不能被基类对象访问</p></li><li><p>指向基类对象的指针 = 公有派生类对象的地址</p><p>利用赋值后的指针可以间接访问派生类中的基类成员</p></li><li><p>指向基类对象的指针 = 指向公有派生类对象的指针</p><p>利用赋值后的指针可以间接访问原指针所指向对象的基类成员</p></li><li><p>基类的引用 =公有派生类对象，即派生类对象可以初始化基类的引用</p></li></ul><p><strong>共有派生类可以当基类使用，但是反过来不行</strong></p><h3 id="前向引用声明">前向引用声明</h3><p>在引用未定义的类之前，将该类的名字告诉编译器，使编译器知道该符号是一个类名</p><p>尽管使用了前向引用声明，但是在提供一个完整的类定义之前，不能定义该类的对象，也不能在内联成员函数中使用该类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>; <span class="hljs-comment">// 前向引用声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-comment">// A a;// 错误：类A的定义尚不完善</span><br>    A *ap;<br>    A &amp;ai;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    B b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="联合体">联合体</h3><p>格式：<code>union 联合体名称</code></p><p>特点：</p><ul><li>联合体的全部数据成员共享同一组内存单元</li><li>联合体变量中的成员同时至多只有一个是有意义的</li><li>联合体的各个对象成员不能有自定义的构造凹函数、自定义的析构函数和重载的复制赋值运算符，对象成员的对象成员也不能有</li><li>无名联合体没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问</li></ul><h2 id="多态">多态</h2><p><strong>多态</strong>是指同样的<strong>消息</strong>被不同类型的<strong>对象</strong>接受时导致不同的行为，最简单的例子就是运算符，使用运算符可以进行各种类型数的运算，不同类型的数得到不同类型的结果</p><p><strong>多态的类型：</strong></p><ul><li><p>重载多态</p><p>指普通函数及类的成员函数的重载都属于重载多态</p></li><li><p>强制多态</p><p>指将一个变元的类型加以变化，以符合一个函数或者操作的要求，例如加法运算符在进行浮点数与整型数相加时，首先进行类强制转换，把整型数变为浮点数再相加</p></li><li><p>包含多态</p><p>指在类族中定义于不同类中的同名成员函数的多态行为，主要通过虚函数来实现</p></li><li><p>参数多态</p><p>与模板类相关联，在使用时必须赋予实际的类型才可以实例化，由此由类模板实例化的各个类都具有相同的操作，而操作对象的类型却各不相同</p></li></ul><p>包含多态和参数多态称为<strong>通用多态</strong>；重载多态和强制多态称为<strong>专用多态</strong></p><p><strong>多态的实现：</strong></p><ul><li>编译时多态（静态联编）：在程序编译阶段就能实现的多态性，可以通过函数重载和运算符重载实现</li><li>运行时多态（动态联编）：在程序执行阶段实现的多态性，可以通过继承、虚函数、基类的指针或引用等技术来实现</li></ul><p><strong>绑定：</strong></p><p>绑定是指<strong>计算机程序自身彼此关联的过程</strong>，也就是把一个标识符名和一个存储地址联系在一起的过程；用面向对象的术语讲，<strong>就是把一条消息和一个对象的方法相结合的过程</strong>，分为<strong>动态绑定</strong>和<strong>静态绑定</strong></p><p>绑定工作在编译连接阶段完成的情况称为静态绑定，也称早期绑定或前绑定</p><p>绑定工作在程序云景阶段完成的情况称为动态绑定，也称晚期绑定或后绑定</p><h3 id="运算符重载">运算符重载</h3><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 运算符重载为类的成员函数</span><br>返回类型 <span class="hljs-keyword">operator</span> 运算符(形参表) &#123;<br>    函数体<br>&#125;<br>或<br><span class="hljs-comment">// 运算符重载为非成员函数</span><br>返回类型 <span class="hljs-keyword">operator</span> 运算符(形参表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>规则：</p><ul><li>C++中除了<code>. .* :: ?: sizeof</code>之外其他都可以重载，且只可以重载已经存在的运算符，不可以创造新的运算符</li><li><strong>重载之后运算符的优先级和结合性都不会改变</strong></li><li>运算符的重载应当与原有功能相似，不能改变原运算符的操作对象个数，同时至少有一个操作对象是自定义类型</li><li><strong>在可被重载的运算符中，除了赋值运算符“=”以及变形的赋值运算符（如&gt;&gt;=、+=等），其余在基类重载的运算符都能被派生类所继承</strong></li></ul><h4 id="运算符重载为成员函数">运算符重载为成员函数</h4><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;形式参数表&gt;) &#123;</span><br><span class="hljs-comment">    &lt;函数体&gt;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 前置单目运算符和后置单目运算符的重载最主要的区别就在于重载函数的形参</span><br>Object&amp; <span class="hljs-keyword">operator</span>++();<span class="hljs-comment">// 重载前置单目运算符</span><br>Object <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// 重载后置单目运算符</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>    &#125;<br>    Object&amp; <span class="hljs-keyword">operator</span> ++() &#123;<br>        (*<span class="hljs-keyword">this</span>).count++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Object <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) &#123;<br>        Object old = *<span class="hljs-keyword">this</span>;<br>        ++(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>    Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;c) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-function">Object <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;count + c.count)</span></span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    Object c = a+b;<br>    <span class="hljs-comment">// a = 1, b = 2</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a.<span class="hljs-built_in">getCount</span>()&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b.<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    a++;<br>    ++b;<br>    <span class="hljs-comment">// a = 2, b = 3</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a.<span class="hljs-built_in">getCount</span>()&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b.<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">// a + b = 5</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a + b = &quot;</span>&lt;&lt;(a+b).<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载为非成员函数">运算符重载为非成员函数</h4><p>Tips：不一定所有的非成员函数运算符重载都需要声明为类的友元函数，仅在需要访问类的私有成员或保护成员时再这样</p><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;形式参数表&gt;) &#123;</span><br><span class="hljs-comment">    &lt;函数体&gt;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 前置单目运算符和后置单目运算符的重载最主要的区别就在于重载函数的形参</span><br><span class="hljs-keyword">friend</span> Object&amp; <span class="hljs-keyword">operator</span>++(Object &amp;a);<span class="hljs-comment">// 重载前置单目运算符</span><br><span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span>++(Object &amp;a, <span class="hljs-type">int</span>); <span class="hljs-comment">// 重载后置单目运算符</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        count = value;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(istream &amp;in, Object&amp; a);<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream &amp;out, Object&amp; a);<br>    <span class="hljs-keyword">friend</span> Object&amp; <span class="hljs-keyword">operator</span> ++(Object &amp;a);<br>    <span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span> ++(Object &amp;a, <span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;a, <span class="hljs-type">const</span> Object &amp;b);<br>&#125;;<br><br>istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(istream &amp;in, Object&amp; a) &#123;<br>    in&gt;&gt;a.count;<br>    <span class="hljs-keyword">return</span> in;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream &amp;out, Object&amp; a) &#123;<br>    out&lt;&lt;a.count;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br>Object&amp; <span class="hljs-keyword">operator</span> ++(Object &amp;a) &#123;<br>    a.count++;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br>Object <span class="hljs-keyword">operator</span> ++(Object &amp;a, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-function">Object <span class="hljs-title">now</span><span class="hljs-params">(a.count)</span></span>;<br>    ++a;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br>Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;a, <span class="hljs-type">const</span> Object &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(a.count + b.count);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object a, b;<br>    <span class="hljs-comment">// input 1 2</span><br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-comment">// a = 1, b = 2</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    a++;<br>    ++b;<br>    <span class="hljs-comment">// a = 2, b = 3</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    Object c = a+b;<br>    <span class="hljs-comment">// a + b = 5</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a + b = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>前置单目运算符重载为成员函数时没有形参，而后置单目运算符重载为成员函数时需要有一个<code>int</code>型的形参</li><li>输入运算符“&gt;&gt;”和输出运算符“&lt;&lt;”的第一操作数必须是流类对象而非本类对象，所以只能以<strong>友元函数</strong>的形式重载运算符</li><li>赋值运算符“=”只能被重载为<strong>成员函数</strong>，而且是不能被继承的</li><li>函数调用运算符“()”可以是带一个或多个右操作数的运算符函数，函数调用运算符重载只能使用<strong>成员函数</strong></li></ul><h3 id="虚函数">虚函数</h3><p>虚函数是<strong>动态绑定</strong>的基础，虚函数必须是非静态的成员函数，虚函数经过派生之后，在类族中就可以实现运行过程中的多态</p><p>根据赋值兼容规则，可以使用派生类的对象代替基类对象。但是当使用基类指针指向派生类对象时，访问到的只是从基类继承过来的同名成员，派生类的出现解决了这个问题，当该同名函数被声明为虚函数时，通过基类指针访问派生类对象同名函数时，得到的是其派生类重写后的同名函数，使属于不同派生类的不同对象产生不同的行为，从而实现运行中的多态</p><p>格式：<code>virtual 函数类型 函数名(形参表)</code></p><p><strong>虚函数声明只能出现在类定义中的函数原型声明中，不能在成员函数实现的时候</strong></p><p><strong>运行过程中的多态</strong>需要满足的条件：</p><ul><li>类之间满足<strong>赋值兼容规则</strong></li><li>要声明<strong>虚函数</strong></li><li>由成员函数来调用或者是通过指针、引用来访问虚函数</li></ul><p>如果是通过对象名来访问虚函数，则绑定在编译过程中就可以进行（静态绑定），而无需在运行过程中进行</p><p>基类指针如何访问被覆盖的基类虚函数？<strong>通过域解析符<code>::</code>进行限定</strong></p><p><strong>几个常见问题：</strong></p><ul><li><p>当基类构造函数调用虚函数时，不会调用派生类的虚函数，因为基类的构造函数调用先于派生类的构造函数调用，当基类构造函数调用时，此时派生类还没有形成一个完整对象</p></li><li><p>当基类析构函数调用虚函数时，不会调用派生类的虚函数，因为基类的析构函数调用晚于派生类的构造函数调用，当基类析构函数调用时，此时派生类对象已经析构完毕</p></li><li><p>虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的，所以虚函数一般不能以内联函数处理。但将虚函数声明为内联函数也不会引起错误</p></li><li><p>同名虚函数在基类和派生类中其函数原型完全一致，即函数的返回值类型、函数名、形式参数表完全相同，否则无法通过虚函数实现动态多态性</p></li><li><p><strong>对象切片：使用派生类对象复制构造基类对象的行为</strong>。在这种情况下，派生类从基类中继承的成员会被复制，派生类中新增的成员将被忽略，当然，也没有空间给这些成员赋值</p></li></ul><h4 id="虚析构函数">虚析构函数</h4><p><strong>在C++中，不能声明虚构造函数，但是可以声明虚析构函数</strong></p><p>格式：<code>virtual ~类名()</code></p><p>如果一个类的析构函数是虚函数，那么由它派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数之后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作</p><h3 id="纯虚函数与抽象类">纯虚函数与抽象类</h3><p>抽象类是一个特殊的类，处于类层次的上层，一个抽象类自身无法实例化，也就是说我们无法定义一个抽象类的对象，只能通过继承机制，生成抽象类的非抽象派生类，然后进行实例化</p><h4 id="纯虚函数">纯虚函数</h4><p>纯虚函数是一个在基类中声明的虚函数，在基类中没有给出具体的操作，要求其派生类给出各自的定义</p><p><strong>格式：</strong><code>virtual 函数类型 函数名(参数表)=0</code></p><p><strong>细节：</strong>在基类中其实可以给出纯虚函数的实现，但是即使给出实现，其派生类也要进行覆盖重写，否则无法实例化，<strong>当基类的析构函数被声明为纯属函数时必须给出实现</strong></p><h4 id="抽象类">抽象类</h4><p>带有纯虚函数的类被称为抽象类，其主要作用是为它的类族定义一个公共的接口，使他们能够更加有效地发挥多态特性。<strong>抽象类不可以被实例化</strong></p><p>当其派生类给出基类中所有纯虚函数的实现之后，该派生类将不再是一个抽象类，此时可以被实例化；但是当没有实现所有纯虚函数时，其派生类依然为一个抽象类</p><h2 id="群体类和群体数据组织">群体类和群体数据组织</h2><p><strong>基本数据类型</strong>是C++编译系统预定义的，而自定义类型的数据是由多个基本类型或自定义类型的元素组成的，称为<strong>群体数据</strong></p><p>对于群体数据，仅有系统预定义的操作是不够的，在很多情况下，还需要设计与某些具体问题相关的特殊操作，并按照面向对象的方法将数据与操作封装起来，这就是<strong>群体类</strong></p><p>群体的两种类型：</p><ul><li><p><strong>线性群体</strong>：元素按顺序排列有序</p></li><li><p><strong>非线性群体</strong>：不用位置顺序来标识元素</p></li></ul><h3 id="函数模板与类模板">函数模板与类模板</h3><p>模板是C++支持参数化程序设计的工具，通过它可以实现<strong>参数化多态性</strong></p><p><strong>参数化多态性</strong>：指将程序所处理的对象的类型参数化，使得一段程序可以用于处理多种不同类型的对象</p><h4 id="函数模板">函数模板</h4><p>定义形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">template&lt;模块参数表&gt;     模块参数表：class(或typename) </span><br><span class="hljs-comment">类型名 函数名(参数表) &#123;</span><br><span class="hljs-comment">    函数体的定义</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">abs</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> ? -x:x;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数模板与重载是密切相关的，从函数模板产生的相关函数都是同名的，编译器用重载的方法调用相应的函数</p><p>函数模板与函数的区别：</p><ol type="1"><li>函数在编译时不会产生任何目标代码，只有模板生成的实例会生成目标代码</li><li>被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，而不能像普通函数那样只将声明放在头文件中</li><li>函数指针也只能指向模板的实例，不能指向模板本身</li></ol><h4 id="类模板">类模板</h4><p>使用类模板使用户可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、返回值或局部变量能取任何类型（包括系统预定义和用户自定义的）</p><p>定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;模板参数表&gt;<br><span class="hljs-keyword">class</span> 类名 &#123;<br>    类成员声明<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在类模板外定义其成员函数，则要采用以下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;模板参数表&gt;<br>类型名 类名&lt;模板参数标识符列表&gt;::函数名(参数表)<br></code></pre></td></tr></table></figure><p>类模板的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板名&lt;模板参数表&gt; 对象名1,...,对象名n;</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h3 id="线性群体">线性群体</h3><p>线性群体中的元素次序与其位置关系是对应的，在线性群体中，又可按照访问元素的不同方法分为<strong>直接访问</strong>、<strong>顺序访问</strong>和<strong>索引访问</strong></p><p>对可直接访问的线性群体，我们可以直接访问群体中的任何一个元素，而不必访问该元素之前的元素</p><p>对顺序访问的线性群体，只能按照元素的排列顺序从头开始依次访问各个元素</p><p>数组、链表、栈、队列</p><h2 id="泛型程序设计与c标准模板库">泛型程序设计与C++标准模板库</h2><p>泛型程序设计，就是编写不依赖于具体数据类型的程序，在C++中，模板是泛型程序设计的主要工具</p><p>泛型程序设计的思想是将算法从特定的数据结构中抽象出来，使算法成为通用的、可以作用于各种不同的数据结构</p><p>以函数模板形式实现的通用算法与各种通用<strong>容器</strong>结合，提高了软件的复用性</p><p>我们可以用<strong>概念</strong>来描述泛型程序设计中作为参数的数据类型所需具备的功能，这里的<strong>”概念“</strong>是泛型程序设计的一个术语，它的内涵是这些功能，它的外延是具备这些功能的所有数据类型</p><p>具备一个概念所需要功能的数据类型称为这一概念的一个<strong>模型</strong></p><p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能（即概念B的模型一定是概念A的模型），那么就说概念B是概念A的子模型</p><h4 id="stl的四种基本组件">STL的四种基本组件：</h4><ul><li>容器<ul><li>容器是容纳、包含一组元素的对象</li><li>容器类库中包括7种基本容器：vector、deque、list、set、mutiset、map和mutimap</li></ul></li><li>迭代器<ul><li>迭代器提供了顺序访问容器中每个元素的方法</li><li>对迭代器可以使用++运算符来获得指向下一个元素的迭代器，可以使用*运算符访问每一个迭代器所指向的元素，部分迭代器允许通过--运算符来获得上一个元素的迭代器</li><li>使用独立于STL容器的迭代器，需要包含头文件&lt;itertor&gt;</li></ul></li><li>函数对象<ul><li>函数对象是一个行为类似函数的对象，对它可以像调用函数一样调用</li><li>任何普通的函数和重载了”()“运算符的类的对象都可以作为函数对象使用，函数对象是泛化的函数</li><li>使用STL的函数对象，需要包含头文件&lt;functional&gt;</li></ul></li><li>算法<ul><li>STL包括70多个算法，包括查找、排序、消除、计数、比较、变换、置换和容器管理</li><li>这些算法的一个最重要的特性就是它们的统一性，并且可以广泛用于不同的对象和内置的数据类型</li><li>使用STL的算法，需要包含头文件&lt;algorithm&gt;</li></ul></li></ul><h2 id="流类库与输入输出">流类库与输入输出</h2><h3 id="流的概念">流的概念</h3><p>在C++中，将数据从一个对象到另一个对象的流动抽象为“流”，从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作，数据的输入与输出就是通过I/O流来实现的</p><p>当程序与外界环境进行信息交换时，存在着两种对象，一个是程序中的对象，另一个是文件对象</p><p><strong>流是一种抽象，它负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动</strong></p><p>流涉及的范围很广，凡是数据从一个地方传输到另一个地方的操作都是流的操作，像网络数据交换、进程数据交换等都是流操作，流操作也可以针对一个字符串进行，<strong>一般意义下的读操作在流数据抽象中被称为（从流中）提取，写操作被称为（向流中）插入</strong></p><h3 id="输出流">输出流</h3><p>一个输出流对象是信息流动的目标，最重要的3个输出流是ostream，ofstream和ostringstream</p><p>预先定义的ostream类对象用来完成向标准设备的输出：</p><ul><li>cout是标准输出流</li><li>cerr是标准错误输出流，没有缓冲，发送给它的内容立即被输出</li><li>clog类似于cerr，但是有缓冲，缓冲区满时被输出</li></ul><h3 id="输入流">输入流</h3><p>一个输入流对象是数据流出的源头，3个最重要的输入流类是istream，ifstream和istringstream</p><p>预先定义的istream对象cin用来挖成从标准输入设备的输入</p><p>ifstream支持磁盘文件输入，很多格式化选项和成员函数都可以应用于ifstream对象，基类ios和istream的所有功能都包括在ifstream中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//读取一行赋值给str</span><br><span class="hljs-built_in">getline</span>(cin, str);<br><span class="hljs-comment">//一个巧妙的重定向输入输出</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<span class="hljs-comment">//从in.in文件中读取输入</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<span class="hljs-comment">//向out.out文件中写入输出</span><br></code></pre></td></tr></table></figure><h3 id="输入输出流">输入输出流</h3><p>一个iostream对象可以是数据的源或目的，有两个重要的I/O流类都是从iostream派生的，它们是fstream和stringstream，这些类继承了前面描述的istream和ostream类的功能</p><p>fstream支持磁盘文件输入和输出，如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象，<strong>一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出</strong></p><p>stringstream类支持面向字符串的输入和输出，可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成</p><h2 id="异常处理-1">异常处理</h2><p>由于环境条件和用户操作的正确性是没有百分之百保证的，所以在设计程序时，就要充分考虑到各种意外情况，并给与恰当的处理</p><h3 id="异常处理的基本思想">异常处理的基本思想</h3><p>程序运行中的有些错误是可以预料但不可避免的，例如内存空间不足、硬盘上的文件被移动、打印机未连接好等由系统运行环境造成的错误。这时要力争做到允许用户排除环境错误，继续运行程序；至少要给出适当的提示信息，这就是异常处理程序的任务</p><p>C++的异常处理机制使得异常的引发和处理不必在同一函数中，这样底层的函数可以着重解决具体问题，而不必过多地考虑对异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理</p><h3 id="c异常处理的实现">C++异常处理的实现</h3><p>C++语言提供对处理异常情况的内部支持，<strong>try，throw和catch语句就是C++语言中用于实现异常处理的机制</strong></p><p>如果某段程序中发现了自己不能处理的异常，就可以使用throw表达式抛掷这个异常，将它抛掷给调用者</p><p>throw的操作数表示异常类型语法上与return语句的操作数相似，如果程序中有多种要抛掷的异常，应该用不同的操作数类型来相互区别</p><h3 id="异常处理的过程">异常处理的过程</h3><ol type="1"><li>程序通过正常的顺序执行到达try语句，然后执行try块内的保护段</li><li>如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行；程序从异常被抛掷的try块后跟随的最后一个catch子句后面的语句继续执行下去</li><li>程序执行到一个throw表达式时，<strong>一个异常对象会被创建</strong>；若异常的抛出点本身在一个try子句内，则该try语句后的catch子句会按顺序检查异常类型是否与声明的类型匹配；若异常抛出点本身不在任何try子句内，或抛出的异常与各个catch子句所声明的类型皆不匹配，则结束当前函数的执行，回到当前函数的调用点，把调用点作为异常的抛出点，然后重复这一过程。此处理继续下去，直到异常成功被一个catch语句捕获</li><li>如果始终未找到与被抛掷异常匹配的catch子句，最终main函数会结束执行，则运行库函数<strong>terminate</strong>将被自动调用，而函数terminate的默认功能是终止程序</li><li>如果找到了一个匹配的catch子句，则catch子句后的符合语句会被执行，复合语句执行完毕后，当前的try块（包括try子句和一系列catch子句）即执行完毕</li></ol><h3 id="异常处理的语法">异常处理的语法</h3><p>表达式语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// throw表达式语法</span><br><span class="hljs-keyword">throw</span> 表达式<br>    <br><span class="hljs-comment">// try块语法</span><br><span class="hljs-keyword">try</span> <br>    复合语句<br><span class="hljs-built_in">catch</span> (异常声明)<br>    复合语句<br><span class="hljs-built_in">catch</span> (异常声明)<br>    复合语句<br>    ...<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>catch语句可以有多个，分别对应不同返回类型的异常</p></li><li><p>如果异常类型声明是一个省略号(...)，catch子句便处理所有类型的异常，这段处理程序必须是try块的最后一段处理程序，否则会报错</p><p><code>error: '...' handler must be the last handler for its try block[-fpermissive]</code></p></li><li><p>catch子句的异常声明中也允许不给出异常参数名称</p></li><li><p>为了加强程序的可读性，使函数的用户能够方便地知道所使用的函数会抛掷哪些异常，可以在函数的声明中列出这个函数可能抛掷的所有异常类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//该函数能够而且只能抛掷出类型为A,B,C,D及其子类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(A, B, C, D)</span></span>;<br><span class="hljs-comment">//该函数能够抛掷出任何类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//该函数不抛掷任何类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果一个函数抛出了他的异常接口声明所不允许抛出的异常时，unexpected函数会被调用，该函数的默认行为是调用terminate函数中止程序，当然用户也可以定义自己的unexpected函数，替换默认函数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="异常处理中的构造与析构">异常处理中的构造与析构</h3><p>在程序中，找到一个匹配的catch异常处理后，如果catch子句的异常声明是一个<strong>值参数</strong>，则其初始化方式是<strong>复制被抛掷的异常对象</strong>；如果catch子句的异常声明是一个<strong>引用</strong>，则其初始化方式是<strong>使该引用指向异常对象</strong></p><p>C++异常处理的真正功能，不仅在于它能够<strong>处理各种不同类型的异常</strong>，还在于它<strong>具有为异常抛掷前构造的所有局部对象自动调用析构函数的能力</strong></p><p>异常被抛出后，从进入try块（与截获异常的catch子句相对应的那个try块）起，到异常被抛掷前，这期间在栈上构造（且尚未析构）的所有对象都会被<strong>自动析构</strong>，析构的顺序与构造的顺序相反，这一过程称为栈的<strong>解旋</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExpection</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyExpection</span>(<span class="hljs-type">const</span> string &amp;message):<span class="hljs-built_in">message</span>(message) &#123;&#125;<br>    ~<span class="hljs-built_in">MyExpection</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">getMessage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string message;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Constructor of Demo&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Demo</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Destructor of Demo&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(MyExpection)</span> </span>&#123;<br>    Demo d;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Throw MyExpection in func()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyExpection</span>(<span class="hljs-string">&quot;exception thrown by func()&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;In main function&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">func</span>();<br>    &#125; <span class="hljs-built_in">catch</span>(MyExpection &amp;e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught an exception:&quot;</span> &lt;&lt; e.<span class="hljs-built_in">getMessage</span>() &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Resume the exception of main()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">    In main function</span><br><span class="hljs-comment">    Constructor of Demo</span><br><span class="hljs-comment">    Throw MyExpection in func()</span><br><span class="hljs-comment">    Destructor of Demo</span><br><span class="hljs-comment">    // 先解旋，后处理异常</span><br><span class="hljs-comment">    Caught an exception:exception thrown by func()</span><br><span class="hljs-comment">    Resume the exception of main()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="标准程序库异常处理">标准程序库异常处理</h3><p>C++标准提供了一组标准异常类，这些类以基类Exception开始，标准程序库抛出的所有异常，都派生于该基类</p><p>该基类提供一个<code>what()</code>方法，用来返回错误信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><code>runtime_error</code>和<code>logic_error</code>是一些具体的异常类的基类，它们分别表示两大异常：</p><ul><li><code>logic_error</code>：可以在程序中被预先检测到的异常，能够被避免<ul><li>out_of_range</li><li>length_error</li><li>invalid_argument</li><li>domain_error</li></ul></li><li><code>runtime_error</code>：表示那些难以被预先检测的异常<ul><li>underflow_error</li><li>overflow_error</li><li>range_error</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
