<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式系统基础知识</title>
    <link href="/2023/03/17/DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/17/DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="理论知识">理论知识</h1><p>如果让你设计一个分布式系统，你预见到什么问题？</p><ul><li>保证节点高可用（节点故障）</li><li>数据的一致性</li><li>通讯异常</li><li>网络分区</li></ul><h2 id="cap-理论">CAP 理论</h2><ul><li><strong>可用性(Availability)</strong>，代表服务一直处于正常响应时间内的可用状态。</li><li><strong>一致性 (Consistency)</strong>，数据一致性分为三种<ul><li><strong>强一致性</strong>：更新后的数据需要被后续的访问都能请求到；</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态；</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ul></li><li><strong>分区容错性 (Partitiontolerance)</strong>，指在某分区宕机或网络原因请求不到情况下，仍然能保证系统的可用性和数据一致性。</li></ul><blockquote><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A的选择。也就是说分区容错性（Partitiontolerance）我们是必须要实现的。简而言之就是：CAP 理论中分区容错性 P是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><h2 id="base-理论">BASE 理论</h2><p>BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，可以理解为是对CAP 中 AP 方案的一个补充。</p><ul><li><strong>基本可用 (BasicAvailable)</strong>：当分布式系统处在一个不可预知的故障状态时，依然可以向外界提供服务，只是会损失一部分<strong>时间</strong>或<strong>系统功能</strong>上的可用性</li><li><strong>软状态(Soft-state)</strong>：允许存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li><li><strong>最终一致性 (EventuallyConsistent)</strong>：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性<ul><li>读时修复：在读取数据时，检测数据的不一致，进行修复。</li><li>写时修复：在写入数据，检测数据的不一致时，进行修复。<strong>（较为推荐）</strong></li><li>异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul></li></ul><h2 id="paxos-算法">Paxos 算法</h2><p>Paxos 算法分为两个部分，分别为 <strong>Basic Paxos 算法</strong>和<strong>Multi-Paxos 思想</strong>，是由兰伯特在 1990年提出了一种<strong>分布式系统共识算法</strong>。Raft 算法、ZAB 协议、Fast Paxos 算法都是基于 Paxos 算法改进而来。</p><h3 id="basic-paxos-算法">Basic Paxos 算法</h3><p>Basic Paxos 中存在 3 个重要的角色：</p><ol type="1"><li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号(Proposal ID) 和提议的值 (Value)。</li><li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li><li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li></ol><p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的Acceptor 接受。这样的话，Basic Paxos算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p><h3 id="multi-paxos-思想">Multi Paxos 思想</h3><p>Basic Paxos 算法的仅能就单个值达成共识， Multi-Paxos 通过多个 BasicPaxos 实例就一系列值达成共识。一种应用于工业界的 Multi-Paxos 变种——Raft协议，其简化了 Multi-Paxos的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft算法。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用OpenSSL生成TLS配置文件</title>
    <link href="/2023/03/17/OpenSSL/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90TLS%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2023/03/17/OpenSSL/%E4%BD%BF%E7%94%A8OpenSSL%E7%94%9F%E6%88%90TLS%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>最近在搭建SDP项目的通信模块时，需要建立控制器和客户端的双向TLS加密，这部分采用OpenSSL生成密钥和证书的方式实现。本篇文章用于记录OpenSSL的简易使用方法，通过本文可以快速地生成Netty可用的密钥证书。</p><h2 id="构建步骤">构建步骤</h2><p>本文的构建环境为 Ubuntu 22.04，其自带了OpenSSL，其他平台用户可能需要首先安装 OpenSSL，具体步骤如下：</p><ol type="1"><li>生成CA的私钥 <code>ca.key</code> 和自签名证书<code>ca.crt</code>，用于 SSL/TLS 通信的证书认证，当前自签名证书有效期为365 天，即一年 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout ca.key -out ca.crt<br></code></pre></td></tr></table></figure></li><li>生成服务器（即Controller）的私钥<code>server.key</code>，证书签名请求 <code>server.csr</code>以及签名证书 <code>server.crt</code> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">server.key 为密钥长度为 2048 位的 RSA 私钥，证书有效期为 365 天</span><br>openssl genrsa -out server.key 2048<br>openssl req -new -key server.key -out server.csr<br>openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -out server.crt<br></code></pre></td></tr></table></figure></li><li>生成客户端（即Client）的私钥 <code>client.key</code>，证书签名请求<code>client.csr</code> 以及签名证书 <code>client.crt</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">同上，证书有效期为 31 天</span><br>openssl genrsa -out client.key 2048<br>openssl req -new -key client.key -out client.csr<br>openssl x509 -req -days 31 -in client.csr -CA ca.crt -CAkey ca.key -out client.crt<br></code></pre></td></tr></table></figure></li><li>转换为 netty 可以识别的密钥格式 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl pkcs8 -topk8 -inform PEM -in server.key -outform PEM -nocrypt -out server_pkcs8.key<br>openssl pkcs8 -topk8 -inform PEM -in client.key -outform PEM -nocrypt -out client_pkcs8.key<br></code></pre></td></tr></table></figure></li><li>*CA可以通过以下指令去核实证书 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl verify -purpose sslserver -CAfile ca.crt server.crt<br>openssl verify -purpose sslclient -CAfile ca.crt client.crt<br></code></pre></td></tr></table></figure></li></ol><p>至此我们在当前目录下可以得到以下文件：</p><blockquote><p>ca.key ca.crt ca.srl client.crt client.key client.csrclient_pkcs8.key server.crt server.key server.csr server_pkcs8.key</p></blockquote><p>其中 <code>*_pkcs8.key</code> 文件就是 Netty 配置 TLS 时能够识别的PKCS8 密钥格式。</p><h2 id="可能遇到的问题">可能遇到的问题</h2><ul><li>CA签发证书时提示如下，是指我们在签发证书时需要指定一个生成证书的序列号，可以在签发前<code>echo "01" &gt; ca.srl</code> 避免提示 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -out server.crt</span><br>Signature ok<br>subject=C = CN, ST = JiangSu, L = Nanjing, O = SEU, OU = CyberScience, CN = 6209, emailAddress = ShijieQ@outlook.com<br>Getting CA Private Key<br>ca.srl: No such file or directory<br>139954133366592:error:06067099:digital envelope routines:EVP_PKEY_copy_parameters:different parameters:crypto/evp/p_lib.c:93:<br>139954133366592:error:02001002:system library:fopen:No such file or directory:crypto/bio/bss_file.c:69:fopen(&#x27;ca.srl&#x27;,&#x27;r&#x27;)<br>139954133366592:error:2006D080:BIO routines:BIO_new_file:no such file:crypto/bio/bss_file.c:76:<br></code></pre></td></tr></table></figure></li><li>使用 CA 的自签名证书签发密钥证书后，可能会出现无法 CA无法认证的情况，需要检查在签发时 Common Name 不能和 CA 相同<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout ca.key -out ca.crt</span><br>Generating a RSA private key<br>.++++<br>...................................................................++++<br>writing new private key to &#x27;ca.key&#x27;<br>-----<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter &#x27;.&#x27;, the field will be left blank.<br>-----<br>Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:JiangSu<br>Locality Name (eg, city) []:Nanjing<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:XXX<br>Organizational Unit Name (eg, section) []:XXXX<br>Common Name (e.g. server FQDN or YOUR name) []:XXXX # 这个不能和控制器以及客户端相同<br>Email Address []:ShijieQ@outlook.com<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenSSL</category>
      
      <category>TLS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenSSL</tag>
      
      <tag>TLS</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同注册中心之间的差异</title>
    <link href="/2023/03/07/DistributedSystem/MicroService/%E4%B8%8D%E5%90%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <url>/2023/03/07/DistributedSystem/MicroService/%E4%B8%8D%E5%90%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h2 id="nacos-eureka-zookeeper">Nacos &amp; Eureka &amp; Zookeeper</h2><p>Nacos、Eureka 和 Zookeeper都可以实现<strong>分布式注册中心框架</strong>。</p><p>Eureka 与 Nacos 底层通过 Raft 协议实现集群产生领导角色。</p><h3 id="差异">差异</h3><p>Zookeeper 采用 CP 保证数据的一致性的问题，原理是采用 ZAB原子广播协议。当我们 ZK领导者宕机或出现了故障，会自动重新实现选举新的领导角色，整个选举的过程中为了保证数据一致性的问题，整个微服务无法实现通讯（本地有缓存除外）。还有可运行的节点必须满足过半机制，整个ZK 才可以使用，要不然会奔溃。</p><p>Eureka 采用 AP设计理念架构注册中心，相互注册（你中有我，我中有你），完全去中心化，也就是没有主从之分，只要有一台Eureka 节点存在整个微服务就可以实现通讯。</p><p>Nacos 从1.0版本选择 AP 和 CP 混合形式实现注册中心，默认情况下采用 AP保证服务可用性，CP 形式底层采用 Raft协议保证数据的一致性问题。如果选择为 AP模式，注册服务的实例仅支持临时模式，在网络分区的的情况允许注册服务实例。选择CP模式可以支持注册服务的实例为持久模式，在网络分区的产生了抖动情况下不允许注册服务实例。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
      <category>MicroService</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见中间件</title>
    <link href="/2023/03/05/DistributedSystem/MicroService/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2023/03/05/DistributedSystem/MicroService/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="常见中间件">常见中间件</h2><h3 id="zookeeper">Zookeeper</h3><p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><h4 id="特点">特点</h4><ul><li><strong>顺序一致性</strong>：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper 中去；</li><li><strong>原子性</strong>：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用；</li><li><strong>单一系统映像</strong>：无论客户端连到哪一个 ZooKeeper服务器上，其看到的服务端数据模型都是一致的；</li><li><strong>可靠性</strong>：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li><li><strong>最终一致性</strong>：写操作最终（而非立即）会对客户端可见</li></ul><h4 id="常见功能">常见功能</h4><ol type="1"><li><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁；<ul><li>依托于临时节点会在 C/S 之间关闭 Session 后自动删除的功能</li></ul></li><li><strong>命名服务</strong>：可以通过 ZooKeeper 的顺序节点生成全局唯一ID；<ul><li>依托于 Zookeeper 的原子性与顺序性</li></ul></li><li><strong>数据发布/订阅</strong>：通过 Watcher 机制可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper被监听的节点上，其他机器可通过监听 ZooKeeper上节点的变化来实现配置的动态更新。<ul><li>依托于 Zookeeper 的 Watch 机制</li></ul></li></ol><blockquote><p>虽然以上功能主要依托于 ZooKeeper 可以保存数据和创建不同节点 (Znode)的功能，但 ZooKeeper 并不适合保存大量数据，每个节点数据量最大是1M。Zookeeper 主要功能是协调服务，不要存储大量数据在 Znode 上。</p></blockquote><h4 id="具体应用场景">具体应用场景</h4><ul><li><strong>Kafka</strong>: ZooKeeper 主要为 Kafka 提供 Broker 和 Topic的注册以及多个 Partition 的负载均衡等功能；</li><li><strong>Hbase</strong>: ZooKeeper 为 Hbase 提供确保整个集群只有一个Master 以及保存和提供 regionserver 状态信息（是否在线）等功能；</li><li><strong>Hadoop</strong>: ZooKeeper 为 Namenode 提供高可用支持。</li></ul><h4 id="使用">使用</h4><p><strong>Curator</strong> 是 Netflix 公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator的封装更加完善，各种 API 都可以比较方便地使用。</p><h3 id="kafka">Kafka</h3><p>Kafka是一个<strong>分布式流式处理平台</strong>，流平台一般具有三个关键功能：<strong>消息队列</strong>、<strong>容错的持久方式存储记录消息流</strong>、<strong>流式处理平台</strong>。</p><h4 id="特点-1">特点</h4><ul><li><strong>性能较强</strong>：基于 Scala 和 Java语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理<strong>千万级别</strong>的消息；</li><li><strong>兼容性较强</strong>：在大数据和流计算领域，与周边生态系统较为兼容。</li></ul><h4 id="常见功能-1">常见功能</h4><ol type="1"><li><strong>消息队列</strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据；</li><li><strong>数据处理</strong>：构建实时的流数据处理程序来转换或处理数据流。</li></ol><h3 id="rocketmq">RocketMQ</h3><p>RocketMQ是一个<strong>队列模型的消息中间件</strong>，具有高性能、高可靠、高实时、分布式的特点。它是一个采用Java 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给Apache，成为了 Apache 的一个顶级项目。</p>]]></content>
    
    
    <categories>
      
      <category>DistributedSystem</category>
      
      <category>MicroService</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DistributedSystem</tag>
      
      <tag>MicroService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习常用模板</title>
    <link href="/2023/01/01/Algorithm/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/01/01/Algorithm/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串">字符串</h2><h3 id="manacher-算法">Manacher 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string now = <span class="hljs-string">&quot;$#&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>            now += ch;<br>            now += <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(now.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> mi = <span class="hljs-number">0</span>, mr = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, len = now.<span class="hljs-built_in">size</span>();<br>        now += <span class="hljs-string">&#x27;!&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            f[i] = (i &lt;= mr ? <span class="hljs-built_in">min</span>(f[<span class="hljs-number">2</span>*mi - i], mr - i + <span class="hljs-number">1</span>):<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (now[i + f[i]] == now[i - f[i]]) &#123;<br>                f[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; mr) &#123;<br>                mi = i;<br>                mr = i + f[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += (f[i] - <span class="hljs-number">1</span>)%<span class="hljs-number">2</span> ? f[i]/<span class="hljs-number">2</span>:(f[i] - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kmp-算法">KMP 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix_function</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> j = pi[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>            j = pi[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            j++;<br>        &#125;<br>        pi[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pi;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图">图</h2><h3 id="dijkstra-算法">Dijkstra 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; &amp;graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(graph.size(), MAX_VALUE)</span></span>;<br>    dist[start] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, x] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (d &gt; dist[x]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [to, val] : graph[x]) &#123;<br>            <span class="hljs-type">int</span> cur_d = dist[x] + val;<br>            <span class="hljs-keyword">if</span> (cur_d &lt; dist[to]) &#123;<br>                dist[to] = cur_d;<br>                pq.<span class="hljs-built_in">push</span>(&#123;cur_d, to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据处理">数据处理</h2><h3 id="离散化">离散化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arrayRankTransform</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp = arr;<br>    <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 去重</span><br>    tmp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()), tmp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : arr) &#123;<br>        x = <span class="hljs-built_in">upper_bound</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), x) - tmp.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数位-dp">数位 DP</h3><blockquote><p>视频讲解，从 19:30 开始 https://www.bilibili.com/video/BV1rS4y1s721其他资料： https://zhuanlan.zhihu.com/p/348851463https://www.bilibili.com/video/BV1MT4y1376Chttps://www.bilibili.com/video/BV1yT4y1u7jW</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>(), dp[m][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt; f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">bool</span> is_limit, <span class="hljs-type">bool</span> is_num) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (i == m) <span class="hljs-keyword">return</span> is_num;<br>            <span class="hljs-keyword">if</span> (!is_limit &amp;&amp; is_num &amp;&amp; dp[i][mask] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i][mask];<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!is_num) res = <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 可以跳过当前数位</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span> - is_num, up = is_limit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>; d &lt;= up; ++d) <span class="hljs-comment">// 枚举要填入的数字 d</span><br>                <span class="hljs-keyword">if</span> ((mask &gt;&gt; d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">// d 不在 mask 中</span><br>                    res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, mask | (<span class="hljs-number">1</span> &lt;&lt; d), is_limit &amp;&amp; d == up, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">if</span> (!is_limit &amp;&amp; is_num) dp[i][mask] = res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二进制">二进制</h2><h3 id="highbit">HighBit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">highbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    i |= (i &gt;&gt;  <span class="hljs-number">1</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">2</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">4</span>);<br>    i |= (i &gt;&gt;  <span class="hljs-number">8</span>);<br>    i |= (i &gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> i - (i &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二进制压缩">二进制压缩</h3><blockquote><p>用于遍历数字 k 的二进制所有子集</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// version 1:</span><br><span class="hljs-type">int</span> sub = k;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// code...</span><br>    sub = (sub - <span class="hljs-number">1</span>) &amp; k;<br>&#125; <span class="hljs-keyword">while</span>(sub != k);<br><br><span class="hljs-comment">// version 2:</span><br><span class="hljs-type">int</span> sub = k;<br><span class="hljs-keyword">while</span> (sub &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">//code...</span><br>  sub = (sub - <span class="hljs-number">1</span>) &amp; k;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring相关基础知识</title>
    <link href="/2022/11/10/Java/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/11/10/Java/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="spring">Spring</h1><ul><li><p>解决的是编译时的依赖</p></li><li><p><code>Class.forname()</code>方法的作用，就是初始化给定的类。而我们给定的MySQL 的 Driver 类中，它在静态代码块中通过 JDBC 的 DriverManager注册了一下驱动。我们也可以直接使用 JDBC 的驱动管理器注册 mysql驱动，从而代替使用 <code>Class.forName</code></p></li></ul><h2 id="reference">Reference</h2><p>《Spring揭秘》 《Spring IN ACTION》</p><h2 id="约定大于配置">约定大于配置</h2><blockquote><p>约定大于配置，也可以叫做约定优于配置（convention overconfiguration），也称作按约定编程，是一种软件设计范式，指在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p></blockquote><h2 id="循环依赖">循环依赖</h2><blockquote><p>If you use predominantly constructor injection, it is possible tocreate an unresolvable circular dependency scenario.</p><p>For example: Class A requires an instance of class B throughconstructor injection, and class B requires an instance of class Athrough constructor injection. If you configure beans for classes A andB to be injected into each other, the Spring IoC container detects thiscircular reference at runtime, and throws a<code>BeanCurrentlyInCreationException</code>.</p><p>One possible solution is to edit the source code of some classes tobe configured by setters rather than constructors. Alternatively, avoidconstructor injection and use setter injection only. In other words,although it is not recommended, you can configure circular dependencieswith setter injection.</p><p>Unlike the typical case (with no circular dependencies), a circulardependency between bean A and bean B forces one of the beans to beinjected into the other prior to being fully initialized itself (aclassic chicken-and-egg scenario).</p><p>如果您主要使用构造函数注入，则可能会创建无法解决的循环依赖场景。</p><p>例如：A类通过构造函数注入需要B类的实例，B类通过构造函数注入需要A类的实例。如果为类A 和 B 配置 bean 以相互注入，Spring IoC容器会在运行时检测到此循环引用，并抛出BeanCurrentlyInCreationException。</p><p>一种可能的解决方案是编辑某些类的源代码以由设置器而不是构造器配置。或者，避免构造函数注入并仅使用setter注入。也就是说，虽然不推荐，但是可以通过setter注入来配置循环依赖。</p><p>与典型情况（没有循环依赖关系）不同，bean A 和 bean B之间的循环依赖关系强制其中一个 bean 在完全初始化之前注入另一个bean（典型的先有鸡还是先有蛋的场景）。</p></blockquote><h2 id="延迟加载lazy-init">延迟加载lazy-init</h2><blockquote><p>By default, <code>ApplicationContext</code> implementations eagerlycreate and configure all singleton beans as part of the initializationprocess.</p></blockquote><p>通过<code>lazy-init</code>属性，可以将部分单例bean延迟加载。</p><h2 id="method-inject方法注入">Method Inject方法注入</h2><p>在大多数应用场景中，容器中的大多数 bean 都是单例的。 当一个单例 bean需要与另一个单例 bean 协作或非单例 bean 需要与另一个非单例 bean协作时，您通常通过将一个 bean 定义为另一个 bean 的属性来处理依赖关系。当 bean 生命周期不同时，就会出现问题。 假设单例 bean A需要使用非单例（原型）bean B，可能在 A上的每个方法调用上。容器只创建一次单例 beanA，因此只有一次设置属性的机会。 容器无法在每次需要时为 bean A提供一个新的 bean B 实例。 一个解决方案是放弃一些控制反转。您可以通过实现 ApplicationContextAware 接口让 bean A 知道容器，并在每次bean A 需要时对容器进行 getBean("B") 调用来请求（通常是新的）bean B实例。</p><p>//TODO</p><h2 id="java中的getresourceasstream">Java中的getResourceAsStream</h2><p><strong>首先，Java中的getResourceAsStream有以下几种：</strong></p><ol type="1"><li><p>Class.getResourceAsStream(String path) ： path不以’/'开头时默认是从此类所在的包下取资源，以’/'开头则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。</p></li><li><p>Class.getClassLoader.getResourceAsStream(String path)：默认则是从ClassPath根下获取，path不能以’/'开头，最终是由ClassLoader获取资源。</p></li><li><p>ServletContext. getResourceAsStream(Stringpath)：默认从WebAPP根目录下取资源，Tomcat下path是否以’/'开头无所谓，当然这和具体的容器实现有关。</p></li><li><p>Jsp下的application内置对象就是上面的ServletContext的一种实现。</p></li></ol><p><strong>其次，getResourceAsStream 用法大致有以下几种：</strong></p><p>第一： 要加载的文件和.class文件在同一目录下，例如：com.x.y下有类me.class ,同时有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第二：在me.class目录的子目录下，例如：com.x.y 下有类me.class ,同时在com.x.y.file 目录下有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第三：不在me.class目录下，也不在子目录下，例如：com.x.y下有类me.class ,同时在 com.x.file 目录下有资源文件myfile.xml</p><p>那么，应该有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;/com/x/file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>总结一下，可能只是两种写法</p><p>第一：前面有 “ / ”</p><p>“ / ”代表了工程的根目录，例如工程名叫做myproject，“ /”代表了myproject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;/com/x/file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><p>第二：前面没有 “ / ”</p><p>代表当前类的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">me.class.getResourceAsStream(<span class="hljs-string">&quot;myfile.xml&quot;</span>); <br>me.class.getResourceAsStream(<span class="hljs-string">&quot;file/myfile.xml&quot;</span>); <br></code></pre></td></tr></table></figure><h2 id="spring中的ioc">Spring中的IOC</h2><p>通过工厂模式和单例模式可以实现解耦的作用，但是Spring框架简化了我们的开发过程。通过使用Spring的IOC可以解决程序耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shijieq.ui;<br><br><span class="hljs-keyword">import</span> com.shijieq.dao.IAccountDao;<br><span class="hljs-keyword">import</span> com.shijieq.service.IAccountService;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟一个表现层，用于调用业务层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取spring的Ioc核心容器，并根据id获取对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * ApplicationContext的三个常用实现类：</span><br><span class="hljs-comment">     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用)</span><br><span class="hljs-comment">     *      FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 核心容器的两个接口引发出的问题：</span><br><span class="hljs-comment">     *  ApplicationContext:     单例对象适用              采用此接口</span><br><span class="hljs-comment">     *      它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *  BeanFactory:            多例对象使用</span><br><span class="hljs-comment">     *      它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.获取核心容器对象</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br><span class="hljs-comment">//        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\Users\\zhy\\Desktop\\bean.xml&quot;);</span><br>        <span class="hljs-comment">//2.根据id获取Bean对象</span><br>        <span class="hljs-type">IAccountService</span> <span class="hljs-variable">as</span>  <span class="hljs-operator">=</span> (IAccountService)ac.getBean(<span class="hljs-string">&quot;accountService&quot;</span>);<br>        <span class="hljs-type">IAccountDao</span> <span class="hljs-variable">adao</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;accountDao&quot;</span>,IAccountDao.class);<br><br>        System.out.println(as);<br>        System.out.println(adao);<br>        as.saveAccount();<br><br><br>        <span class="hljs-comment">//--------BeanFactory----------</span><br><span class="hljs-comment">//        Resource resource = new ClassPathResource(&quot;bean.xml&quot;);</span><br><span class="hljs-comment">//        BeanFactory factory = new XmlBeanFactory(resource);</span><br><span class="hljs-comment">//        IAccountService as  = (IAccountService)factory.getBean(&quot;accountService&quot;);</span><br><span class="hljs-comment">//        System.out.println(as);</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基于xml的ioc配置">基于XML的IOC配置</h2><h3 id="模板">模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br>&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中<br> id 属性：对象的唯一标识。<br> class 属性：指定要创建对象的全限定类名<br>--&gt;<br>&lt;!-- 配置 service --&gt; <br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;<br>&lt;!-- 配置 dao --&gt;<br>&lt;bean id=&quot;accountDao&quot; class=&quot;com.shijieq.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="bean标签">bean标签</h3><ul><li><p>作用：</p><p>用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p></li><li><p>属性：</p><ul><li><code>id</code>：给对象在容器中提供一个唯一标识。用于获取对象。</li><li><code>class</code>：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</li><li><code>scope</code>：指定对象的作用范围。<ul><li><code>singleton</code>: 默认值，单例的.<ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。</li><li>生命周期：<ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul></li></ul></li><li><code>prototype</code>: 多例的.<ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期：<ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul></li></ul></li><li><code>request</code>: WEB 项目中, Spring 创建一个 Bean的对象,将对象存入到 request 域中.</li><li><code>session</code>: WEB 项目中, Spring 创建一个 Bean的对象,将对象存入到 session 域中.</li><li><code>global session</code>: WEB 项目中, 应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session.</li></ul></li><li><code>init-method</code>：指定类中的初始化方法名称。</li><li><code>destroy-method</code>：指定类中销毁方法名称。</li><li>...</li></ul></li></ul><h4 id="实例化bean的三种方式">实例化bean的三种方式</h4><h5 id="默认无参构造函数">默认无参构造函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!--在默认情况下：<br>它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;/&gt;<br></code></pre></td></tr></table></figure><h5 id="静态工厂创建对象">静态工厂创建对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">/**<br>* 模拟一个静态工厂，创建业务层实现类<br>*/<br>public class StaticFactory &#123;<br>public static IAccountService createAccountService()&#123;<br>return new AccountServiceImpl();<br>&#125;<br>&#125;<br>&lt;!-- 此种方式是:<br>使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器<br>id 属性：指定 bean 的 id，用于从容器中获取<br>class 属性：指定静态工厂的全限定类名<br>factory-method 属性：指定生产对象的静态方法<br>--&gt;<br>&lt;bean id=&quot;accountService&quot;<br>  class=&quot;com.shijieq.factory.StaticFactory&quot;<br>  factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="实例工厂创建对象">实例工厂创建对象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">/**<br>* 模拟一个实例工厂，创建业务层实现类<br>* 此工厂创建对象，必须现有工厂实例对象，再调用方法<br>*/<br>public class InstanceFactory &#123;<br>public IAccountService createAccountService()&#123;<br>return new AccountServiceImpl();<br>&#125;<br>&#125;<br>&lt;!-- 此种方式是：<br>先把工厂的创建交给 spring 来管理。<br>然后在使用工厂的 bean 来调用里面的方法<br>factory-bean 属性：用于指定实例工厂 bean 的 id。<br>factory-method 属性：用于指定实例工厂中创建对象的方法。<br>--&gt;<br>&lt;bean id=&quot;instancFactory&quot; class=&quot;com.shijieq.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;<br>&lt;bean id=&quot;accountService&quot;<br>  factory-bean=&quot;instancFactory&quot;<br>  factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h3 id="依赖注入">依赖注入</h3><h4 id="构造方法注入">构造方法注入</h4><p>采用构造函数的方式，给bean属性传值，要求<strong>类中存在一个对应参数列表的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAccountService</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountServiceImpl</span><span class="hljs-params">(String name, Integer age, Date birthday)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.birthday = birthday;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAccount</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;,&quot;</span>+age+<span class="hljs-string">&quot;,&quot;</span>+birthday);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 使用构造函数的方式，给 service 中的属性传值<br>要求：<br>类中需要提供一个对应参数列表的构造函数。<br>涉及的标签：<br>constructor-arg<br>属性：<br>index:指定参数在构造函数参数列表的索引位置<br>type:指定参数在构造函数中的数据类型<br>name:指定参数在构造函数中的名称 用这个找给谁赋值<br>=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============<br>value:它能赋的值是基本数据类型和 String 类型<br>ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;<br>&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="set方法注入">set方法注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAccountService</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBirthday</span><span class="hljs-params">(Date birthday)</span> &#123;<br>        <span class="hljs-built_in">this</span>.birthday = birthday;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAccount</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;,&quot;</span>+age+<span class="hljs-string">&quot;,&quot;</span>+birthday);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式<br>涉及的标签：<br>property<br>属性：<br>name：找的是类中 set 方法后面的部分<br>ref：给属性赋值是其他 bean 类型的<br>value：给属性赋值是基本数据类型和 string 类型的<br>实际开发中，此种方式用的较多。<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h4 id="p-名称空间注入数据">p 名称空间注入数据</h4><p>p 名称空间注入本质上还是调用set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br>    &lt;bean id=&quot;accountService&quot; <br>       class=&quot;com.shijieq.service.impl.AccountServiceImpl4&quot;<br>  p:name=&quot;test&quot; p:age=&quot;21&quot; p:birthday-ref=&quot;now&quot;/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="注入集合属性">注入集合属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 注入集合数据<br>List 结构的: array,list,set<br>Map 结构的: map,entry,props,prop<br>--&gt;<br>&lt;bean id=&quot;accountService&quot; class=&quot;com.shijieq.service.impl.AccountServiceImpl&quot;&gt;<br>&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;<br>&lt;!-- 给数组注入数据 --&gt;<br>&lt;property name=&quot;myStrs&quot;&gt;<br>&lt;set&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>&lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/set&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 list 集合数据 --&gt;<br>&lt;property name=&quot;myList&quot;&gt;<br>&lt;array&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>            &lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/array&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 set 集合数据 --&gt;<br>&lt;property name=&quot;mySet&quot;&gt;<br>&lt;list&gt;<br>&lt;value&gt;AAA&lt;/value&gt;<br>            &lt;value&gt;BBB&lt;/value&gt;<br>            &lt;value&gt;CCC&lt;/value&gt;<br>&lt;/list&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 Map 数据 --&gt;<br>&lt;property name=&quot;myMap&quot;&gt;<br>&lt;props&gt;<br>            &lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt;<br>            &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;<br>&lt;/props&gt;<br>&lt;/property&gt;<br>&lt;!-- 注入 properties 数据 --&gt;<br>&lt;property name=&quot;myProps&quot;&gt;<br>&lt;map&gt;<br>&lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;<br>&lt;entry key=&quot;testB&quot;&gt;<br>&lt;value&gt;bbb&lt;/value&gt;<br>&lt;/entry&gt;<br>&lt;/map&gt;<br>&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h2 id="基于注解的ioc配置">基于注解的IOC配置</h2><h3 id="模板-1">模板</h3><p>相较于”基于XML的IOC配置“模板，导入约束时需要多导入一个<strong>context</strong> 名称空间下的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>    http://www.springframework.org/schema/beans/spring-beans.xsd<br>       http://www.springframework.org/schema/context<br>   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br><br>&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;<br>&lt;context:component-scan base-package=&quot;com.shijieq&quot;&gt;&lt;/context:component-scan&gt;<br><br>&lt;!-- 配置 dbAssit --&gt;<br>&lt;bean id=&quot;dbAssit&quot; class=&quot;com.shijieq.dbassit.DBAssit&quot;&gt;<br>&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br><br>&lt;!-- 配置数据源 --&gt;<br>&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;<br>&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;<br>&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day02&quot;&gt;&lt;/property&gt;<br>        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;<br>        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="常用注解">常用注解</h3><p><strong>细节</strong>：如果注解中有且只有一个属性要赋值时，且名称是value，value 在赋值是可以不写</p><h4 id="创建对象">创建对象</h4><p>相当于：<code>&lt;bean id="" class=""&gt;</code></p><ul><li><code>@Component</code><ul><li>把资源让 spring 来管理。相当于在 xml 中配置一个 bean</li><li>属性：<ul><li><code>value</code>：指定 bean 的 id。如果不指定 value 属性，默认bean 的 id 是当前类的类名。<strong>首字母小写</strong></li></ul></li></ul></li><li><code>@Controller, @Service, @Repository</code>：<ul><li><code>@Controller</code>：一般用于<strong>表现层</strong>的注解</li><li><code>@Service</code>：一般用于<strong>业务层</strong>的注解</li><li><code>@Repository</code>：一般用于<strong>持久层</strong>的注解</li></ul></li></ul><h4 id="注入数据">注入数据</h4><p>相当于：<code>&lt;property name="" ref=""&gt;</code>、<code>&lt;property name="" value=""&gt;</code></p><ul><li><code>@Autowired</code><ul><li>自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在spring 容器查找，找到了也可以注入成功。找不到就报错。</li></ul></li><li><code>@Qualifier</code><ul><li>在自动按照类型注入的基础之上，再按照 Bean 的 id注入。它在给字段注入时不能独立使用，必须和 <span class="citation"data-cites="Autowire">@Autowire</span>一起使用；但是给方法参数注入时，可以独立使用。</li><li>属性：<ul><li><code>value</code>：指定 bean 的 id</li></ul></li></ul></li><li><code>@Resource</code><ul><li>直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。</li><li>属性：<ul><li><code>name</code>：指定 bean 的 id</li></ul></li></ul></li><li><code>@Value</code><ul><li>注入基本数据类型和 String 类型数据</li><li>属性：<ul><li><code>value</code>：用于指定值</li></ul></li></ul></li></ul><h4 id="改变作用范围">改变作用范围</h4><p>相当于： <code>&lt;bean id="" class="" scope=""&gt;</code></p><ul><li><code>@Scope</code><ul><li>指定 bean 的作用范围</li><li>属性：<ul><li><code>value</code>：指定范围的值，取值为：<code>singleton, prototype, request, session, global session</code></li></ul></li></ul></li></ul><h4 id="生命周期相关">生命周期相关*</h4><p>相当于：<code>&lt;bean id="" class="" init-method="" destroy-method="" /&gt;</code></p><ul><li><code>@PostConstruct</code>：用于指定初始化方法</li><li><code>@PreDestroy</code>：用于指定销毁方法</li></ul><h2 id="基于注解和xml的ioc对比">基于注解和XML的IOC对比</h2><p><img src=".\img\基于注解和XML的对比.png" alt="image-20220318235631736" style="zoom:67%;" /></p><h3 id="相关替代">相关替代</h3><h4 id="替代bean.xml">替代bean.xml</h4><p>如何用注解完全替代<code>bean.xml</code>？</p><ul><li><code>@Configuration</code><ul><li>用于<strong>指定当前类是一个 spring配置类</strong>，当创建容器时会从该类上加载注解。</li><li>获取容器时需要使用 AnnotationApplicationContext(有@Configuration注解的类.class)</li><li>属性：<ul><li><code>value</code>：用于指定配置类的字节码</li></ul></li></ul></li><li><code>@ComponentScan</code><ul><li>用于<strong>指定 spring 在初始化容器时要扫描的包</strong>。</li><li>作用和在 spring 的 xml配置文件中的：<code>&lt;context:component-scan base-package="com.shijieq"/&gt;</code>是一样的</li><li>属性：<ul><li><code>basePackages</code>：用于指定要扫描的包。和<strong>该注解中的value 属性作用一样</strong>。</li></ul></li></ul></li><li><code>@Bean</code><ul><li>该注解<strong>只能写在方法</strong>上，表明使用<strong>此方法创建一个对象</strong>，并且放入spring 容器</li><li>属性：<ul><li><code>name</code>：给当前@Bean注解方法创建的对象指定一个名称(<strong>即 bean 的 id</strong>）。</li></ul></li></ul></li></ul><h4 id="提取配置">提取配置</h4><p>此时<code>bean.xml</code>文件已经可以删除，对于一些数据源或者其他如何将他们配置出来？</p><ul><li><p><code>@PropertySource</code></p><ul><li><strong>用于加载<code>.properties</code>文件中的配置</strong>。</li><li>例如我们配置数据源时，可以把连接数据库的信息写到 properties配置文件中，就可以使用此注解指定 properties 配置文件的位置。</li><li>属性：<ul><li><code>value[]</code>：用于指定 properties 文件位置，如果是在<ahref="./Java.md">类路径</a>下，需要写上<code>classpath:</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 连接数据库的配置类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br><span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 创建一个数据源，并存入 spring 容器中</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@Bean(name=&quot;dataSource&quot;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">createDataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        ds.setDriverClass(driver);<br>            ds.setJdbcUrl(url);<br>            ds.setUser(username);<br>            ds.setPassword(password);<br>            <span class="hljs-keyword">return</span> ds;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">jdbc.properties 文件：</span><br><span class="hljs-comment">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="hljs-comment">jdbc.url=jdbc:mysql://localhost:3306/day44_ee247_spring</span><br><span class="hljs-comment">jdbc.username=root</span><br><span class="hljs-comment">jdbc.password=1234</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="导入其他配置">导入其他配置</h4><ul><li><p><code>@Import</code></p><ul><li>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解（写上也没事）。</li><li>属性：</li><li><code>value[]</code>：用于指定其他配置类的字节码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.shijieq.spring&quot;)</span><br><span class="hljs-meta">@Import(&#123; JdbcConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfiguration</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="获取容器">获取容器</h4><p>当配置文件被完全替代后，如何通过注解获取容器？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);<br></code></pre></td></tr></table></figure><h2 id="spring整合junit">Spring整合Junit</h2><p>以下主要介绍在Spring中如何整合单元测试，这部分在Springboot中有更好更为简洁的方式。</p><h3 id="配置步骤">配置步骤</h3><ol type="1"><li>拷贝整合 junit 的必备 jar 包到 lib 目录，或通过maven导入依赖</li><li>使用<code>@RunWith</code>注解替换原有运行器</li><li>使用<code>@ContextConfiguration</code>指定 spring配置文件的位置</li><li>使用<code>@Autowired</code>给测试类中的变量注入数据</li></ol><h3 id="举个例子">举个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 测试类</span><br><span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations= &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceTest</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> IAccountService as ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring中的aop">Spring中的AOP</h2><p>AOP全称是”面向切面编程“，简单来说就是<strong>把我们程序重复的代码抽取出来</strong>，在需要执行的时候，使用<strong>动态代理技术</strong>，在不修改源码的基础上，对我们的已有方法进行增强。</p><p>例如转账系统中对持久层的操作都是独立事务，导致无法实现事务控制，不符合事务的一致性。我们通过让业务层来控制事务的提交和回滚，而这个过程中存在一些重复的代码，此时就可以采用动态代理技术进行增强。</p><h3 id="动态代理与静态代理">动态代理与静态代理</h3><p><strong>动态代理的特点是字节码随用随创建，随用随加载</strong>。它与静态代理的区别也在于此。因为<strong>静态代理是字节码一上来就创建好，并完成加载。</strong></p><p>装饰者模式就是静态代理的一种体现。</p><p>动态代理常用的有两种方式：<strong>基于接口的动态代理</strong>和<strong>基于子类的动态代理</strong>。</p><h4 id="基于接口的动态代理">基于接口的动态代理</h4><p>使用JDK官方提供的Proxy类，<strong>要求被代理类最少实现一个接口</strong>。</p><h4 id="基于子类的动态代理">基于子类的动态代理</h4><p>使用第三方的CGLib，<strong>要求被代理类不能用final修饰，即不能为最终类</strong></p><h3 id="相关术语">相关术语</h3><ul><li><code>Joinpoint(连接点)</code>:所谓连接点是指那些被拦截到的点。<strong>在 spring中,这些点指的是方法</strong>，因为 spring 只支持方法类型的连接点。</li><li><code>Pointcut(切入点)</code>: 所谓切入点是指我们要对哪些 Joinpoint进行拦截的定义。</li><li><code>Advice(通知/增强)</code>:<ul><li>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。</li><li>通知类型<ul><li>前置通知</li><li>后置通知</li><li>异常通知</li><li>最终通知</li><li>环绕通知</li></ul></li></ul></li><li><code>Introduction(引介)</code>:引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或 Field。</li><li><code>Target(目标对象)</code>: 代理的目标对象。</li><li><code>Weaving(织入)</code>:<ul><li>是指把增强应用到目标对象来创建新的代理对象的过程。</li><li>spring 采用动态代理织入，而 AspectJ采用编译期织入和类装载期织入。</li></ul></li><li><code>Proxy（代理）</code>: 一个类被 AOP织入增强后，就产生一个结果代理类。</li><li><code>Aspect(切面)</code>: 是切入点和通知（引介）的结合。</li></ul><h3 id="要明确的事">要明确的事</h3><h4 id="开发阶段">开发阶段</h4><p>这部分工作由开发人员完成：</p><ol type="1"><li>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。</li><li>把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。</li><li>在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。</li></ol><h4 id="运行阶段">运行阶段</h4><p>这部分工作由Spring框架完成：</p><p>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><p><strong>在 spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</strong></p><h2 id="基于xml的aop配置">基于XML的AOP配置</h2><h3 id="模板-2">模板</h3><p>在IOC模板的基础上还需要导入aop的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="配置步骤-1">配置步骤</h3><ol type="1"><li><p>把通知类用 bean 标签配置起来</p></li><li><p>使用 <code>aop:config</code> 声明 aop 配置</p></li><li><p>使用 <code>aop:aspect</code> 配置切面</p></li><li><p>使用 <code>aop:pointcut</code>配置切入点表达式<code>expression</code></p></li><li><p>使用 <code>aop:xxx</code> 配置对应的通知类型</p><ul><li>aop:xxx都拥有的共同属性：<ul><li><code>method</code>: 用于指定通知类中的增强方法名称</li><li><code>pointcut</code>: 用于指定切入点表达式</li><li><code>pointcut-ref</code>: 用于指定切入点的表达式的引用</li></ul></li><li><code>aop:before</code><ul><li>用于配置<strong>前置通知</strong>。指定增强的方法在切入点方法之前执行。</li></ul></li><li><code>aop:after-returning</code><ul><li>用于配置<strong>后置通知</strong></li><li>执行时间点：<strong>切入点方法正常执行之后。它和异常通知只能有一个执行。</strong></li></ul></li><li><code>aop:after-throwing</code><ul><li>用于配置<strong>异常通知</strong></li><li>执行时间点：<strong>切入点方法执行产生异常后执行。它和后置通知只能执行一个。</strong></li></ul></li><li><code>aop:after</code><ul><li>用于配置<strong>最终通知</strong></li><li>执行时间点：<strong>无论切入点方法执行时是否有异常，它都会在其后面执行。</strong></li></ul></li><li><code>aop:around</code><ul><li>用于配置<strong>环绕通知</strong></li><li>它是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。</li><li><strong>通常情况下环绕通知都是单独使用的。</strong></li></ul></li></ul></li></ol><h3 id="切入点表达式expression">切入点表达式expression</h3><blockquote><p>execution(表达式)</p></blockquote><h4 id="语法">语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">execution([修饰符] 返回值类型 包名.类名.方法名(参数))<br></code></pre></td></tr></table></figure><h4 id="写法">写法</h4><h5 id="全匹配模式">全匹配模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="访问修饰符省略">访问修饰符省略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">void</span> com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="返回值用表示">返回值用*表示</h5><p>返回值*表示任意返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.shijieq.service.impl.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="包名用表示">包名用*表示</h5><p>包名*表示任意包名，但是有几级包，就要写几个*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* *.*.*.*.AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="用..表示当前包">用..表示当前包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..AccountServiceImpl.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="类名使用号">类名使用*号</h5><p>类名*表示任意类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.saveAccount(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="方法名使用号">方法名使用*号</h5><p>方法名*表示任意方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(com.shijieq.domain.Account))<br></code></pre></td></tr></table></figure><h5 id="参数列表使用号">参数列表使用*号</h5><p>参数列表*表示可以是任意数据类型，但是必须有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(*))<br></code></pre></td></tr></table></figure><h5 id="参数列表使用..号">参数列表使用..号</h5><p>参数列表..表示有无参数均可，如有参数可为任意数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com..*.*(..))<br></code></pre></td></tr></table></figure><h5 id="全通配模式">全通配模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* *..*.*(..))<br></code></pre></td></tr></table></figure><h3 id="举个例子-1">举个例子</h3><p>假设我们要对业务层代码切入事务控制，首先定义一个事务控制类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 事务控制类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><span class="hljs-comment">//定义一个 DBAssit</span><br>    <span class="hljs-keyword">private</span> DBAssit dbAssit ;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDbAssit</span><span class="hljs-params">(DBAssit dbAssit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dbAssit = dbAssit;<br>&#125;<br><span class="hljs-comment">//开启事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginTransaction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//提交事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().commit();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//回滚事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().rollback();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//释放资源</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置文件，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;<br>&lt;!-- 配置通知 --&gt;<br>&lt;bean id=&quot;txManager&quot; class=&quot;com.shijieq.utils.TransactionManager&quot;&gt;<br>&lt;property name=&quot;dbAssit&quot; ref=&quot;dbAssit&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br><br>&lt;!--配置AOP--&gt;<br>&lt;aop:config&gt;<br>&lt;!--配置切面--&gt;<br>&lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt;<br>&lt;!--声明一个切入点pt1--&gt;<br>&lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;/&gt;<br>&lt;!--配置前置通知--&gt;<br>&lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置后置通知--&gt;<br>&lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置异常通知--&gt;<br>&lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;!--配置最终通知--&gt;<br>&lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;/&gt;<br>&lt;/aop:aspect&gt;<br>&lt;/aop:config&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="环绕通知">环绕通知</h4><p>//TODO</p><h2 id="基于注解的aop配置">基于注解的AOP配置</h2><h3 id="模板-3">模板</h3><p>相较于”基于XML的AOP配置“模板，导入约束时需要多导入一个<strong>context</strong> 名称空间下的约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans.xsd<br>   http://www.springframework.org/schema/aop<br>   http://www.springframework.org/schema/aop/spring-aop.xsd<br>   http://www.springframework.org/schema/context<br>   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h3 id="配置步骤-2">配置步骤</h3><ol type="1"><li><p>把通知类也使用注解配置</p></li><li><p>在通知类上使用@Aspect 注解声明为切面</p></li><li><p>在增强的方法上使用注解配置通知</p></li><li><p>在 spring 配置文件中开启 spring 对注解 AOP 的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;<br>&lt;aop:aspectj-autoproxy/&gt;<br></code></pre></td></tr></table></figure><p>或者通过注解开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages=&quot;com.shijie&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="相关注解">相关注解</h3><ul><li><p><code>@Aspect</code>: 表明当前类是一个切面类</p></li><li><p><code>@Before</code>: 把当前方法看成是前置通知</p></li><li><p><code>@AfterReturning</code>: 把当前方法看成是后置通知</p></li><li><p><code>@AfterThrowing</code>: 把当前方法看成是异常通知</p></li><li><p><code>@After</code>: 把当前方法看成是最终通知</p></li><li><p><code>@Around</code>: 把当前方法看成是环绕通知</p></li><li><p><code>@Pointcut</code>: 指定切入点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt1</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@After(&quot;pt1()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="举个例子-2">举个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 事务控制类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component(&quot;txManager&quot;)</span><br><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//表明当前类是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><span class="hljs-comment">//定义一个 DBAssit</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DBAssit dbAssit;<br>    <br>    <span class="hljs-comment">//开启事务</span><br><span class="hljs-meta">@Before(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginTransaction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>    dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>    e.printStackTrace();<br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().commit();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().rollback();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.shijieq.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring中的事务控制">Spring中的事务控制</h2><p>//TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见决策算法汇总</title>
    <link href="/2022/11/01/Laboratory/TrustManagement/%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/01/Laboratory/TrustManagement/%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="topsis">TOPSIS</h1><p>TOPSIS法根据有限个评价对象与理想化目标的接近程度进行排序的方法，是在现有的对象中进行相对优劣的评价。TOPSIS法是一种逼近于理想解的排序法，该方法只要求各效用函数具有单调递增（或递减）性就行。TOPSIS法是多目标决策分析中一种常用的有效方法，又称为<strong>优劣解距离法</strong>。&gt; 1981年，C.L.Hwang和K.Yoon首次提出了Topsis，全称Technique for OrderPreference by Similarity to an IdealSolution，可翻译为逼近理想解排序法，国内常称为优劣解距离法。它是一种常用的综合评价方法。</p><h2 id="优点">优点</h2><p>TOPSIS可以弥补层次分析法的一些缺点: 1.优劣解距离法可以充分利用原始数据信息，且其结果能充分反应各评价方案与最优方案的接近程度。2.对样本容量没有严格限制，数据计算简单易行，无需数据检验。（topsis法适用于两个以上）</p><h2 id="基本过程">基本过程</h2><ol type="1"><li>原始矩阵正向化，得到正向化矩阵<ul><li>指标类型。指标类型一般分为四种，<strong>极大型指标</strong>、<strong>极小型指标</strong>、<strong>中间型指标</strong>、<strong>区间型指标</strong>。<ul><li>极大型指标越大越好；</li><li>极小型指标越小越好；</li><li>中间型指标越接近中间值越好；</li><li>区间型指标落在区间内最好。</li></ul></li><li>正向化公式。正向化就是将原始数据指标都转化为极大型指标<ul><li>极小型 -&gt; 极大型：<span class="math inline">\(x_i = max -x_i\)</span>，当指标值中没有"0"时也可以用 <spanclass="math inline">\(x_i = \frac{1}{x_i}\)</span></li><li>中间型 -&gt; 极大型：<span class="math inline">\(x_i = 1 -\frac{|x_i - max|}{mid}\)</span>，其中 <spanclass="math inline">\(mid\)</span> 为中间值</li><li>区间型 -&gt; 极大型：其中 <span class="math inline">\(M\)</span>表示为距离区间最远的距离，即 <span class="math inline">\(max(a -min(x_i), max(x_i) - b)\)</span> <span class="math display">\[\left\{\begin{array}{c}x_i=1-\frac{a-x_i}{M}\left(x^i \leqslant a\right) \\x_i=1\left(a \leqslant x_i \leqslant b\right) \\x_i=1-\frac{x_i-b}{M}\left(x^i \geqslant b\right)\end{array}\right.\]</span></li></ul></li></ul>假设有n个要评价的对象，m个已经正向化的评价指标，构成的正向化矩阵为：<span class="math display">\[X=\left[\begin{array}{cccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n 1} &amp; x_{n 2} &amp; \cdots &amp; x_{n m}\end{array}\right]\]</span></li><li>对正向化矩阵标准化 <span class="math display">\[Z_{i j}=\frac{x_{i j}}{\sqrt{\sum_1^n x_{i j}^2}}\]</span> 得到标准化矩阵为： <span class="math display">\[Z=\left[\begin{array}{cccc}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1 m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2 m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n 1} &amp; z_{n 2} &amp; \cdots &amp; z_{n m}\end{array}\right]\]</span></li><li>计算得分并归一化 构造评分公式：<span class="math inline">\(S =\frac{x - min}{max - min}\)</span>，变形可得 <spanclass="math inline">\(S = \frac{x - min}{(max - x) + (x - min)}\)</span>计算列最大值 <span class="math display">\[ Z^+ = (Z^+_1, Z^+_2, \cdots,Z^+_m) =\left(\max \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \max\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \max \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\]</span> 计算列最小值 <span class="math display">\[ Z^- = (Z^-_1,Z^-_2, \cdots, Z^-_m) =\left(\min \left\{z_{11}, z_{21}, \cdots, z_{n 1}\right\}, \min\left\{z_{12}, z_{22}, \cdots, z_{n 2}\right\}, \cdots, \min \left\{z_{1m}, z_{2 m}, \cdots, z_{n m}\right\}\right)\]</span> 定义第 <span class="math inline">\(i\)</span>个评价对象与最大值的距离 <spanclass="math inline">\(D_i^{+}=\sqrt{\sum_{j=1}^m\left(Z_j^{+}-z_{ij}\right)^2}\)</span> 定义第 <span class="math inline">\(i\)</span>个评价对象与最小值的距离 <spanclass="math inline">\(D_i^{-}=\sqrt{\sum_{j=1}^m\left(Z_j^{-}-z_{ij}\right)^2}\)</span> 那么可以计算出第 <spanclass="math inline">\(i\)</span> 个评价对象未归一化的得分为：<spanclass="math inline">\(S_i = \frac{D^-_i}{D^+_i + D^-_i}\)</span> 将<span class="math inline">\(S_i\)</span>归一化后进行数值排名，即可得到最佳方案</li></ol><h1 id="vikor">VIKOR</h1><h2 id="与topsis的对比">与TOPSIS的对比</h2><ul><li>TOPSIS和VIKOR的区别之一在于<strong>聚合函数</strong>。TOPSIS是基于距离理想解的距离的集合，VIKOR方法在TOPSIS方法的基础上提出了一个具有优势率的折衷方案。在TOPSIS方法中，不仅要考虑到与正理想解的最近距离，而且考虑到与负理想解的最长距离，从而确定最优解，以最大限度地提高效益。但TOPSIS中的这些距离只是简单地求和，没有考虑它们的相对重要性，而在VIKOR中决策者会根据自身需求确定其重要性。</li><li>VIKOR方法相比TOPSIS方法多了一个<strong>决策机制系数</strong>，它可以使决策者做出更激进或更保守的决策。TOPSIS方法的过程没有纳入任何主观因素，更适合要求结果完全客观的决策环境。</li><li>VIKOR方法的独特优势在于可以得到<strong>带有优先级的折衷方案</strong>，这使得通过VIKOR排序后的最佳方案可能不止一个。而TOPSIS方法只能得到唯一最优解，毕竟它的过程是完全客观的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Laboratory</category>
      
      <category>TrustManagement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Laboratory</tag>
      
      <tag>TrustManagement</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++相关基础知识</title>
    <link href="/2021/01/15/C++/C-%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/01/15/C++/C-%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="c与c的区别">C与C++的区别</h2><h3 id="const与指针">Const与指针</h3><table><thead><tr class="header"><th></th><th>指向常量的指针</th><th>常指针</th><th>指向常量的常指针</th></tr></thead><tbody><tr class="odd"><td>格式</td><td>const 类型名* 指针名</td><td>类型名* const 指针名</td><td>const 类型名* const 指针名</td></tr><tr class="even"><td>示例</td><td>const int* p = &amp;x;</td><td>int* const p = &amp;x;</td><td>const int* const p = &amp;x;</td></tr><tr class="odd"><td>可修改的值</td><td>p, x</td><td>*p, x</td><td>x</td></tr><tr class="even"><td>不可修改的值</td><td>*p</td><td>p</td><td>p, *p</td></tr></tbody></table><h3 id="名字空间与域解析符">名字空间与域解析符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> one &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">namespace</span> two &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> one;<br><span class="hljs-comment">// using namespace two;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> two::a;<br>    a = <span class="hljs-number">-100</span>;<br>    <span class="hljs-comment">// cout&lt;&lt;b&lt;&lt;endl; error: reference to &#x27;b&#x27; is ambiguous</span><br>    cout&lt;&lt;a&lt;&lt;endl; <span class="hljs-comment">// -100</span><br>    cout&lt;&lt;one::a&lt;&lt;endl; <span class="hljs-comment">// 0</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当两个同时使用两个命名空间时，若命名空间中含有相同变量名时直接使用会提示错误<code>error: reference to 'b' is ambiguous</code></li><li>在C++语言中，通过在同名变量前加上域解析符<code>::</code>对被隐藏的同名全局变量进行访问</li></ul><h3 id="内联函数">内联函数</h3><ul><li><p>内联函数的出现是为了代替宏定义，以一种更为安全的方式进行<strong>代码替换</strong></p></li><li><p>工作原理：在程序<strong>编译</strong>时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换</p></li><li><p>内联函数进行的是代码的替换，所以会在编译后增加代码的体量，但节省了调用函数的时间</p></li><li><p>由于内联函数的特性，所以在内联函数中不允许使用循环语句和开关语句；若内联函数中存在这些语句，则编译器优化其为普通函数，对其进行调用和返回</p></li><li><p>类中的成员函数可以理解为内联函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> defineMutiply(x, y) x*y</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">inlindeMutiply</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x*y;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> define = <span class="hljs-built_in">defineMutiply</span>(<span class="hljs-number">3</span>+<span class="hljs-number">4</span>, <span class="hljs-number">2</span>+<span class="hljs-number">3</span>); <span class="hljs-comment">// 3+4*2+3 = 14</span><br>    <span class="hljs-type">int</span> Inline = <span class="hljs-built_in">inlindeMutiply</span>(<span class="hljs-number">3</span>+<span class="hljs-number">4</span>, <span class="hljs-number">2</span>+<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;define = &quot;</span>&lt;&lt;define&lt;&lt;endl; <span class="hljs-comment">// define = 14</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Inline = &quot;</span>&lt;&lt;Inline&lt;&lt;endl; <span class="hljs-comment">// Inline = 35</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用">引用</h3><p><strong>“变量一样的用法，指针一样的功能”</strong></p><p>格式：</p><ol type="1"><li><p>数据类型 &amp;引用名 = 已定义的变量名;</p></li><li><p>类型名&amp; 函数名(形式参数表);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> &amp;y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    z++;<br>    y = x + y + z;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-built_in">Fun</span>(a, b, c);<br>d = <span class="hljs-built_in">Fun</span>(a, b, c);<br><span class="hljs-built_in">Fun</span>(a, b, c) = <span class="hljs-number">20</span>; <span class="hljs-comment">//相当于b = 20;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><p>声明引用时&amp;表示引用的一个声明，不代表取地址</p></li><li><p>声明引用时必须对它进行初始化，以明确该引用是哪个对象的别名，而且之后引用的别名关系不可改</p></li><li><p>引用只是某个变量的一个别名，所以系统不会为引用分配内存空间</p></li><li><p>引用作为返回值的函数存在特殊要求</p><ul><li><p>return 后面只能是变量，而不能是常量或表达式</p></li><li><p>return后面变量的内存空间再本次函数调用结束后应当仍然存在</p></li><li><p>return 后面不能是常引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//常引用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> &amp;b = a;<br><span class="hljs-comment">// b++; // error: increment of read-only reference &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>不能建立空引用、引用的引用、指向引用的指针、引用数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误示范</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>, a[<span class="hljs-number">10</span>];<br><span class="hljs-type">void</span> &amp;r = x;<br><span class="hljs-type">int</span> &amp;&amp;r = x;<br><span class="hljs-type">int</span> &amp;*p = x;<br><span class="hljs-type">int</span> &amp;arr[<span class="hljs-number">10</span>] = a;<br></code></pre></td></tr></table></figure></li></ul><p>引用与指针的比较：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">引用</th><th style="text-align: center;">指针</th></tr></thead><tbody><tr class="odd"><td>实质</td><td style="text-align: center;">变量（对象）的别名</td><td style="text-align: center;">指向变量（对象）的地址</td></tr><tr class="even"><td>初始化</td><td style="text-align: center;">必须进行初始化</td><td style="text-align: center;">非必须，事后可以赋值</td></tr><tr class="odd"><td>可变性</td><td style="text-align: center;">一旦成为某个变量的别名，则不可更改</td><td style="text-align: center;">可以更改指针的指向</td></tr><tr class="even"><td>是否有空值</td><td style="text-align: center;">不可为空，一旦声明必须初始化</td><tdstyle="text-align: center;">可以置为空指针NULL，表示不指向任何变量</td></tr><tr class="odd"><td>占用内存情况</td><td style="text-align: center;">不额外占用空间，只是所指对象</td><tdstyle="text-align: center;">另外占用4字节空间，用来存储变量的地址</td></tr><tr class="even"><td>访问方式</td><td style="text-align: center;">直接使用引用名访问</td><td style="text-align: center;">使用<code>*指针名</code>访问</td></tr><tr class="odd"><td>安全有效性</td><td style="text-align: center;">安全，始终为某个变量的别名</td><td style="text-align: center;">安全，不一定有效，可能成为野指针</td></tr></tbody></table><h3 id="内存申请管理">内存申请管理</h3><p>使用new申请内存，使用delete释放内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ptr, *ptrArray;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">// 申请1个int大小的空间</span><br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 申请1个int大小的空间，并赋值为10</span><br>ptrArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 申请10个int大小的空间，并将数组地址返回给ptr</span><br><br><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放指针ptr所指向的空间</span><br><span class="hljs-comment">// delete ptrArray; // 释放ptrArray所指向的数组的第一个地址，即释放了int大小的空间，不推荐</span><br><span class="hljs-keyword">delete</span> []ptrArray; <span class="hljs-comment">// 释放ptrArray所指向的数组的全部空间</span><br></code></pre></td></tr></table></figure><ul><li><strong>建议不要将C++的new、delete和存储管理函数malloc、calloc、free混合使用</strong></li></ul><p><strong>内存泄露：用new申请的内存必须要用delete来加以释放，否则会导致动态分配的内存无法回收，使得程序占据的内存越来越大</strong></p><p>内存申请的区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">当用户自定义默认构造函数时，以下两种写法都是调用默认构造函数</span><br><span class="hljs-comment">当用户没有自定义默认构造函数时，结果不同</span><br><span class="hljs-comment">*/</span><br>T* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 除了调用系统生成的隐含的默认构造函数外，还会为基本数据类型和指针类型的成员用0赋初值</span><br>T* p = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">// 调用系统生成的隐含的默认构造函数</span><br></code></pre></td></tr></table></figure><p>创建多维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建方式</span><br><span class="hljs-built_in">float</span> (*cp)[<span class="hljs-number">9</span>][<span class="hljs-number">8</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[<span class="hljs-number">8</span>][<span class="hljs-number">9</span>][<span class="hljs-number">8</span>];<br><span class="hljs-comment">// 访问方式</span><br>*(*(*(cp+i)+j))<br></code></pre></td></tr></table></figure><h3 id="void类型指针">void类型指针</h3><p>void类型指针表示不确定类型的指针，即一种通用类型的指针，任何指针都可以直接赋值给void类型的指针</p><p>注意事项：</p><ul><li><p>可以定义void类型的指针，但是不能定义void类型的引用和变量</p></li><li><p>void类型的指针只是可以接受任何类型指针变量的赋值，但是不可以直接使用void类型指针访问内存中的内容，需要做一个显示类型转换。</p><p>例如C中的malloc函数的返回是一个void*类型，当进行赋值时需要根据申请空间的变量类型进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 申请一个大小为10的int数组</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="异常处理">异常处理</h3><p>C++语言中异常处理通过以下3步实现：</p><ol type="1"><li>检查异常（try）</li><li>抛出异常（throw）</li><li>捕捉异常（catch）</li></ol><p>其中抛出异常再可能出现异常的<strong>当前函数</strong>处理，检查异常和捕捉异常在<strong>上级函数</strong>中处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">divide</span>(a, b);<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">int</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;except of divide zero&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;finished&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>throw语句格式：<code>throw &lt;表达式&gt;; 或 throw ;</code></p><p>try-catch语句格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//&lt;被进行异常检查的语句&gt;</span><br>&#125;<br><span class="hljs-built_in">catch</span>(<span class="hljs-comment">/*&lt;异常信息类型&gt;或&lt;变量&gt;*/</span>) &#123;<br>    <span class="hljs-comment">//&lt;异常处理语句&gt;</span><br>&#125;<br>&lt;<span class="hljs-built_in">catch</span>(<span class="hljs-comment">/*..*/</span>)&#123;<br>  <span class="hljs-comment">//...  </span><br>&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>try块一定要在catch块前面，try和catch块之间不能有任何其他语句</li><li>可以只有try块，没有catch块，即捕捉到异常后不做处理</li><li>只能有一个try块，而对应可以有多个catch块，即针对throw出的不同异常来进行分情况处理</li></ul><h2 id="类与对象">类与对象</h2><h3 id="类的定义">类的定义</h3><p>格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 类名 &#123;<br>[<span class="hljs-keyword">private</span>: ]<br>    <span class="hljs-comment">// 私有成员变量或成员函数</span><br>[<span class="hljs-keyword">protected</span>: ]<br>    <span class="hljs-comment">// 保护成员变量或成员函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公有成员变量或成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>private为类默认的访问类型</li><li>public、protected和private书写顺序无严格限制</li></ul><table><thead><tr class="header"><th>访问属性</th><th>含义</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>private</td><td>私有成员</td><td>只允许该类的成员函数及友元访问，不能被其他函数访问</td></tr><tr class="even"><td>protected</td><td>保护成员</td><td>既允许该类的成员函数及友元访问，也允许其派生类的成员函数访问</td></tr><tr class="odd"><td>public</td><td>公有成员</td><td>既允许该类的成员函数访问，也允许类外部的其他函数访问</td></tr></tbody></table><ul><li>在C++中，结构体类型也可以有数据成员和成员函数两大组成部分，其<strong>定义方式与类的定义基本一致</strong>，只是将关键字class替换成struct即可。二者最大的区别就是：<strong>class定义中类成员的默认访问属性为private，而struct定义中结构成员的默认访问属性为public</strong>，因此类的封装和信息隐藏特性要好于结构体</li></ul><h3 id="类的访问">类的访问</h3><p>通过对象来访问类中的成员，方式分为两种：</p><ul><li><p>圆点访问形式</p><p><code>对象名.成员 或 (*指向对象的指针).成员</code></p></li><li><p>指针访问形式</p><p><code>对象指针变量名-&gt;成员 或 (&amp;对象名)-&gt;成员</code></p></li></ul><p><strong>this</strong>指针指向存放当前对象的地址，每个成员函数都存在一个隐含的this指针</p><h3 id="构造函数与析构函数">构造函数与析构函数</h3><p>构造函数格式：<code>类名 ([形式参数列表]) 或 类名::类名 ([形式参数列表])</code></p><ul><li><p>当在类外实现成员函数时，需要加限定符：<code>类名::</code></p></li><li><p><strong>构造函数在对象创建时由系统调用，所以在程序中就不能调用对象的构造函数</strong></p></li><li><p>构造函数没有返回类型，构造函数名必须与类名相同</p></li><li><p>构造函数为public类型，否则定义对象时无法自动调用构造函数，编译时也会出现错误提示</p></li><li><p>对于一个用户自定义的类，若用户定义时未定义构造函数，则编译器自动生成一个<strong>默认的无参构造函数</strong>，定义对象时会自动调用该构造函数；若用户定义了构造函数，则编译器不会生成无参构造函数。当定义对象时没有提供实际的参数，编译器就会查找无参的构造函数；如果类中已定义了其他有参构造函数而没有定义无参的构造函数，C++编译器就会给出一个错误提示</p></li></ul><p>析构函数格式：<code>~类名() 或 类名::~类名()</code></p><ul><li><p><strong>析构函数在对象创建时由系统调用，所以在程序中就不能调用对象的析构函数</strong></p></li><li><p>析构函数没有返回类型，同时应当声明为public类型，否则编译器会报错</p></li><li><p><strong>每个类中只有一个析构函数，析构函数因为其特点所以不能重载</strong></p></li><li><p>系统提供一个默认的析构函数，即使不定义析构函数也可以使用，但是当成员变量中含有指针类型的成员时，需要在析构函数中进行内存释放，保证对象生存期结束时释放所有的内存空间</p></li></ul><h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3><p>系统为每一个类提供了默认拷贝构造函数，可以实现将源对象所有数据成员的值逐一赋值给目标对象相应的数据成员。但是该拷贝为<strong>浅拷贝</strong>，不能拷贝成员变量中的指针数据类型，只能进行指针的指向，当源对象销毁后指针内存释放，此时目标对象成员变量的指针变为了<strong>悬挂指针</strong>，其所指内存不属于当前程序，析构时报错</p><p>当类中没有定义拷贝构造函数时，系统使用默认的拷贝构造函数，当对象作为参数传递时，依然为浅拷贝，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a, b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b):<span class="hljs-built_in">a</span>(a), <span class="hljs-built_in">b</span>(b) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = a;<br>        <span class="hljs-keyword">this</span>-&gt;b = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Test test)</span> </span>&#123;<br>    test.<span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    test.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 2, b = 3</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    t1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 1, b = 2</span><br>    <span class="hljs-built_in">fun</span>(t1);<br>    t1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// a = 1, b = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象数组">对象数组</h3><p>初始化：<code>Date dt[2] = &#123;Date(2011, 5, 1), Date(2020, 6, 1)&#125;</code></p><h3 id="对象指针">对象指针</h3><p>格式：<code>类名 *对象指针名</code></p><p>用指针引用对象成员的方法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">指针变量名-&gt;成员名 或 (*指针变量名).成员名<br>(对象数组名+下标)-&gt;成员名 或 *(对象数组名+下标).成员名<br></code></pre></td></tr></table></figure><h3 id="对象引用">对象引用</h3><ul><li>对象引用与一般变量的引用一样，是一个已经定义对象的别名，引用本身不再另外占用内存空间。</li><li>对象引用只是某对象的别名、引用与它代表的对象共享同一个单元。</li><li>引用必须在定义时初始化，并且在程序运行过程中不能让引用成为另一个对象的别名</li></ul><h3 id="友元">友元</h3><p>友元的三种形式：</p><ul><li>一个不属于其他任何类的普通函数声明为当前类的友元，称为当前类的<strong>友元函数</strong></li><li>一个其他类的成员函数声明为当前类的友元，称为当前类的<strong>友元成员</strong></li><li>另一个类声明为当前类的友元，称为当前类的<strong>友元类</strong></li></ul><p>使用友元可以避免频繁调用类的接口函数，提高程序的运行速度，从而提高程序的运行效率</p><h4 id="友元函数">友元函数</h4><p>形式：<code>friend 函数返回类型 函数名(形式参数表);</code></p><p><strong>注意事项：</strong></p><ol type="1"><li>通常友元函数时在类的定义中给出原型声明，声明的位置任意，不受访问属性的限制，声明之后的友元函数在类外面给出完整定义，此时前面不能再加关键字friend</li><li>友元函数也可以在类内部直接给出定义，定义的首部相当于原型声明</li><li>友元函数的定义和调用方式与普通函数相同</li><li>友元函数提供了不同类成员函数之间、类的成员函数与普通函数之间进行数据共享的机制，尤其是一个函数需要访问多个类时，友元函数非常有用</li><li>友元毕竟是打破了封装和信息隐藏机制，因此在安全性和效率之间需做折中处理</li></ol><h4 id="友元成员">友元成员</h4><p>形式：<code>friend 函数返回类型 友元类名::函数名(形式参数表);</code></p><p><strong>注意事项：</strong></p><ol type="1"><li>一个类的成员函数作为另一个类的友元成员时，必须先定义这个类</li><li><strong>对于先使用后定义的标识符都应当给出向前引用声明</strong></li></ol><h4 id="友元类">友元类</h4><p>形式：<code>friend 类名;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>友元类的声明是单向的，不具有交换性，即声明友元的类未必是被声明类的友元</p></li><li><p>友元关系不具备传递性，即A类将B类声明为友元，B类将C类声明为友元，此时C类还不是A类的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> year, month, day;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDate</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">friend</span> Person;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(Date &amp;date)</span> </span>&#123;<br>        date.<span class="hljs-built_in">getDate</span>();<br>        date.year = <span class="hljs-number">2001</span>;<br>        date.month = <span class="hljs-number">12</span>;<br>        date.day = <span class="hljs-number">30</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类中数据的共享与保护">类中数据的共享与保护</h2><h3 id="静态成员">静态成员</h3><p>静态成员包括<strong>静态数据成员</strong>和<strong>静态成员函数</strong></p><h4 id="静态数据成员">静态数据成员</h4><p>静态数据成员声明形式：<code>static 类型名 静态数据成员名</code></p><p>静态数据成员访问形式：<code>类名::公有静态成员变量名; 或 对象名.公有静态成员变量名</code></p><p>静态数据成员是同类对象共享的，事实上，它在<strong>该类的任何对象被创建前就已经存在</strong>，因此其初始化工作<strong>不能通过类的构造函数</strong>完成，而必须在类定义结束之后进行，默认值为0，静态数据成员是在编译时创建并初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> total;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::total = <span class="hljs-number">1</span>;<span class="hljs-comment">// 类定义结束之后初始化</span><br></code></pre></td></tr></table></figure><h4 id="静态成员函数">静态成员函数</h4><p>静态成员函数声明形式：<code>static 返回值类型 静态成员函数名(形式参数表)</code></p><p>静态成员函数访问形式：<code>类名::静态成员函数名(实际参数表); 或 对象名.静态成员函数名(实际参数表);</code></p><h3 id="共享数据的保护">共享数据的保护</h3><h4 id="常数据成员">常数据成员</h4><p>定义形式：<code>const 类型名 常数据成员名</code></p><p>常数据成员的初始化<strong>只能在构造函数的初始化列表</strong>中进行，不能在构造函数的函数体中用赋值等语句实现，而普通数据成员两种方式均可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> sex;<br>    <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">bool</span> sex, <span class="hljs-type">int</span> age):<span class="hljs-built_in">sex</span>(sex)&#123;<span class="hljs-comment">// 不可以放到函数体中</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态常数据成员：</strong>在常数据成员定义<strong>之前</strong>增加一个关键字static</p><p>静态常数据成员的初始化不可以放在初始化列表中完成了，与静态数据成员类似，要在类定义结束后单独初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> PI;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Person::PI = <span class="hljs-number">3.14</span>;<span class="hljs-comment">// 类定义结束之后初始化</span><br></code></pre></td></tr></table></figure><h4 id="常成员函数">常成员函数</h4><p>声明形式：<code>类型 函数名(形式参数表) const;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>关键字const可以作为与其他成员函数重载的标志，即以下写法正确</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 非常对象t.print()默认情况下调用不带const的函数 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>常成员函数不能修改本类的数据成员，因此也不能调用该类中未经关键字const修饰的普通成员函数。但是反过来，普通成员函数可以调用常成员函数。</p></li></ol><h4 id="常对象">常对象</h4><p>定义形式：<code>类名 const 对象名;</code> 或<code>const 类名 对象名;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>常对象类比基本数据类型中的常量，在定义常对象时<strong>必须进行初始化</strong>，而且其对象的数据成员值不能修改</p></li><li><p>常对象只能调用它的常成员函数而不能调用普通的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;general print.&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;const print.&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> Test t1;<br>    Test t2;<br>    t1.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// const print.</span><br>    t2.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// general print.</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类与类之间的关系">类与类之间的关系</h2><p>类与类之间存在3种关系：组合(Composition)、依赖(Dependency)和继承(Inheritance)</p><p>组合(Composition)：C类中包含了A类和B类的对象作为成员变量，即<strong>对象成员</strong></p><p>依赖(Dependency)：C类的某个函数实现需要B类的对象作为参数</p><p>继承(Inheritance)：C类为B类的<strong>派生类</strong>，B类为C类的<strong>基类</strong></p><p><strong>UML中类与类之间关系：</strong></p><ul><li>依赖关系（实心箭头虚线）</li><li>作用关系——关联（实线 重数）</li><li>包含关系——聚集和组合<ul><li>聚集（部分消失整体存在）（空心菱形 重数）</li><li>组合（部分消失则整体消失）（实心菱形 重数）</li></ul></li><li>继承关系——泛化（空心三角实线）</li></ul><h3 id="对象成员">对象成员</h3><ul><li><p>对象成员在创建时需要调用构造函数，在退出时需要调用析构函数</p></li><li><p><strong>对象与它内部的对象成员具有相同的生命周期</strong></p></li><li><p>创建一个对象时，构造函数的调用次序是：<strong>首先调用对象成员的构造函数，再调用对象自身的构造函数</strong>，析构时相反</p></li><li><p>对象成员构造函数的调用次序与初始化表中出现的次序无关，它始终<strong>与对象成员在类中定义的次序一致</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123;<br>        x = a;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A: x = &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    A a1, a2;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c):<span class="hljs-built_in">a2</span>(b), <span class="hljs-built_in">a1</span>(a) &#123; <span class="hljs-comment">//当初始化对象成员时，需要写到初始化列表里</span><br>        y = c;<br>        cout&lt;&lt;<span class="hljs-string">&quot;B: y = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-comment">// 执行结果为：</span><br>    <span class="hljs-comment">// A: x = 10</span><br>    <span class="hljs-comment">// A: x = 20</span><br>    <span class="hljs-comment">// B: y = 30</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="基类与派生类">基类与派生类</h3><p>在面向对象程序设计的语境中，旧类称为<strong>基类</strong>，也称作<strong>父类</strong>，新类称为<strong>派生类</strong>，也称为<strong>子类</strong></p><p>在C++中，一个基类可以派生出多个派生类，一个派生类也可以有多个基类，派生类可作为新的基类，继续派生出新的派生类</p><p><strong>继承</strong>通常分为<strong>单一继承</strong>和<strong>多重继承</strong>两大类。单一继承是指一个派生类只有一个基类，多重继承是指派生类有多个基类。<strong>C++支持多重继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object1</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object2</span><br><span class="hljs-comment">// 继承Object1，为Object1的派生类，Student的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-keyword">public</span> Object1 &#123;&#125;;<br><span class="hljs-comment">// 继承People，为People的派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">public</span> People &#123;&#125;;<br><span class="hljs-comment">// 多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object3</span>: <span class="hljs-keyword">public</span> Object1, <span class="hljs-keyword">public</span> Object2 &#123;&#125;;<br></code></pre></td></tr></table></figure><p><strong>继承方式</strong>共有3种：public（公有）、protected（保护）和private（私有），<strong>如果缺省，则默认为私有继承方式</strong></p><table><thead><tr class="header"><th></th><th>公有成员</th><th>保护成员</th><th>私有成员</th></tr></thead><tbody><tr class="odd"><td>公有继承public</td><td>公有成员</td><td>保护成员</td><td>不继承</td></tr><tr class="even"><td>保护继承protected</td><td>保护成员</td><td>保护成员</td><td>不继承</td></tr><tr class="odd"><td>私有继承private</td><td>私有成员</td><td>私有成员</td><td>不继承</td></tr></tbody></table><p><strong>定义一个派生类对象时，构造函数的调用顺序为：</strong></p><ul><li>基类的构造函数</li><li>派生类对象成员的构造函数（按照定义顺序）</li><li>派生类的构造函数</li></ul><p>大部分构造函数需要传入一定的参数来初始化成员，此时需要在派生类构造函数的初始化列表中对基类构造函数进行调用，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;派生类名&gt; (总形式参数表):&lt;基类名1&gt;(&lt;参数表1&gt;), </span><br><span class="hljs-comment">  &lt;基类名2&gt;(&lt;参数表2&gt;)[, ...&lt;基类名n&gt;(&lt;参数表n&gt;)],</span><br><span class="hljs-comment">  [&lt;对象成员名1&gt;(&lt;参数表1&gt;), ...],</span><br><span class="hljs-comment">  [&lt;其他初始化项&gt;]&#123;</span><br><span class="hljs-comment">    [&lt;派生类自身数据成员的初始化&gt;]                          </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    Base b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Drived</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">Base</span>(x), <span class="hljs-built_in">b</span>(x) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>构造派生类对象时，就要对基类的成员对象和新增成员对象进行初始化</li><li>如果对基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数</li></ul><h3 id="同名冲突">同名冲突</h3><h4 id="派生类与基类同名冲突">派生类与基类同名冲突</h4><p>派生类在定义新成员时，新成员的名称与基类中的某个成员同名，此时同名覆盖原则将发挥作用，即无论是派生类内部成员函数还是派生类对象访问同名成员，如果未加任何特殊标识，则访问的都是派生类中新定义的同名成员</p><p>如果派生类内部成员或派生类对象需要访问基类的同名成员，则必须在同名成员前面加上<strong>“基类名::”</strong>进行限定</p><p><strong>注意事项：</strong></p><ul><li>通过派生类的指针或引用，访问的是派生类的同名成员，此时同名覆盖原则依然发挥作用</li><li><strong>基类的指针指向派生类对象时，访问的依然是基类中的同名成员</strong></li><li>基类的引用成为派生类对象别名时，访问的也依然是基类中的同名成员</li></ul><h4 id="多个直接基类引发的同名冲突">多个直接基类引发的同名冲突</h4><p>多重继承中多个直接基类中有同名成员，此时派生类中访问这些成员时，将发生同名冲突问题</p><p>其解决方案与上种冲突类似，在成员前指明基类名即可</p><h4id="共同祖先基类多重拷贝引发的同名冲突">共同祖先基类多重拷贝引发的同名冲突</h4><p>派生类有多个直接或间接的基类，在这些基类中，有一个基类是其余某些基类的共同祖先，派生类访问这些成员时，将发生同名冲突问题</p><p>解决方法：引入<strong>虚基类</strong></p><h5id="虚基类从不同路径继承过来的同名数据成员在内存中只有一个副本同一个函数名也只有一个映射">虚基类：从不同路径继承过来的同名数据成员在内存中只有一个副本，同一个函数名也只有一个映射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var1;<br>    <span class="hljs-built_in">base1</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base2</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> var2;<br>    <span class="hljs-built_in">base2</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span>: <span class="hljs-keyword">public</span> base1, <span class="hljs-keyword">public</span> base2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">derived</span>(<span class="hljs-type">int</span> var):<span class="hljs-built_in">base1</span>(var), <span class="hljs-built_in">base2</span>(var), <span class="hljs-built_in">base</span>(var)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有派生类均调用虚基类的构造函数，<strong>但C++规定只有最后一层派生类对虚基类构造函数的调用发挥作用</strong>，即上述例子中，只有derived真正调用，其余均被忽略</p><p><strong>构造一个类的对象一般的顺序：</strong></p><ol type="1"><li>如果该类含有直接或间接虚基类，则先执行虚基类的构造函数</li><li>如果该类有其他基类，则按照他们在<strong>继承声明列表中出现的次序</strong>，分别执行它们的构造函数，但构造过程中，不再执行他们的虚基类的构造函数</li><li>按照定义中出出现的顺序，对派生类中新增的成员对象进行初始化。对类类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定的参数执行构造函数，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋值，否则什么也不做</li><li>执行构造函数的函数体</li></ol><h3 id="赋值兼容规则">赋值兼容规则</h3><p>赋值兼容就是指需要使用<strong>基类</strong>的地方可以使用其<strong>公有派生类</strong>来代替</p><p>理论依据：公有派生类继承了基类中除构造函数、析构函数以外的所有非私有成员，且访问权限也完全相同</p><p>常见情形：</p><ul><li><p>基类对象 = 公有派生类对象</p><p>赋值后的基类对象只能获得基类成员部分，派生类中新增加的成员不能被基类对象访问</p></li><li><p>指向基类对象的指针 = 公有派生类对象的地址</p><p>利用赋值后的指针可以间接访问派生类中的基类成员</p></li><li><p>指向基类对象的指针 = 指向公有派生类对象的指针</p><p>利用赋值后的指针可以间接访问原指针所指向对象的基类成员</p></li><li><p>基类的引用 =公有派生类对象，即派生类对象可以初始化基类的引用</p></li></ul><p><strong>共有派生类可以当基类使用，但是反过来不行</strong></p><h3 id="前向引用声明">前向引用声明</h3><p>在引用未定义的类之前，将该类的名字告诉编译器，使编译器知道该符号是一个类名</p><p>尽管使用了前向引用声明，但是在提供一个完整的类定义之前，不能定义该类的对象，也不能在内联成员函数中使用该类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>; <span class="hljs-comment">// 前向引用声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-comment">// A a;// 错误：类A的定义尚不完善</span><br>    A *ap;<br>    A &amp;ai;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    B b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="联合体">联合体</h3><p>格式：<code>union 联合体名称</code></p><p>特点：</p><ul><li>联合体的全部数据成员共享同一组内存单元</li><li>联合体变量中的成员同时至多只有一个是有意义的</li><li>联合体的各个对象成员不能有自定义的构造凹函数、自定义的析构函数和重载的复制赋值运算符，对象成员的对象成员也不能有</li><li>无名联合体没有标记名，只是声明一个成员项的集合，这些成员项具有相同的内存地址，可以由成员项的名字直接访问</li></ul><h2 id="多态">多态</h2><p><strong>多态</strong>是指同样的<strong>消息</strong>被不同类型的<strong>对象</strong>接受时导致不同的行为，最简单的例子就是运算符，使用运算符可以进行各种类型数的运算，不同类型的数得到不同类型的结果</p><p><strong>多态的类型：</strong></p><ul><li><p>重载多态</p><p>指普通函数及类的成员函数的重载都属于重载多态</p></li><li><p>强制多态</p><p>指将一个变元的类型加以变化，以符合一个函数或者操作的要求，例如加法运算符在进行浮点数与整型数相加时，首先进行类强制转换，把整型数变为浮点数再相加</p></li><li><p>包含多态</p><p>指在类族中定义于不同类中的同名成员函数的多态行为，主要通过虚函数来实现</p></li><li><p>参数多态</p><p>与模板类相关联，在使用时必须赋予实际的类型才可以实例化，由此由类模板实例化的各个类都具有相同的操作，而操作对象的类型却各不相同</p></li></ul><p>包含多态和参数多态称为<strong>通用多态</strong>；重载多态和强制多态称为<strong>专用多态</strong></p><p><strong>多态的实现：</strong></p><ul><li>编译时多态（静态联编）：在程序编译阶段就能实现的多态性，可以通过函数重载和运算符重载实现</li><li>运行时多态（动态联编）：在程序执行阶段实现的多态性，可以通过继承、虚函数、基类的指针或引用等技术来实现</li></ul><p><strong>绑定：</strong></p><p>绑定是指<strong>计算机程序自身彼此关联的过程</strong>，也就是把一个标识符名和一个存储地址联系在一起的过程；用面向对象的术语讲，<strong>就是把一条消息和一个对象的方法相结合的过程</strong>，分为<strong>动态绑定</strong>和<strong>静态绑定</strong></p><p>绑定工作在编译连接阶段完成的情况称为静态绑定，也称早期绑定或前绑定</p><p>绑定工作在程序云景阶段完成的情况称为动态绑定，也称晚期绑定或后绑定</p><h3 id="运算符重载">运算符重载</h3><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 运算符重载为类的成员函数</span><br>返回类型 <span class="hljs-keyword">operator</span> 运算符(形参表) &#123;<br>    函数体<br>&#125;<br>或<br><span class="hljs-comment">// 运算符重载为非成员函数</span><br>返回类型 <span class="hljs-keyword">operator</span> 运算符(形参表) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>规则：</p><ul><li>C++中除了<code>. .* :: ?: sizeof</code>之外其他都可以重载，且只可以重载已经存在的运算符，不可以创造新的运算符</li><li><strong>重载之后运算符的优先级和结合性都不会改变</strong></li><li>运算符的重载应当与原有功能相似，不能改变原运算符的操作对象个数，同时至少有一个操作对象是自定义类型</li><li><strong>在可被重载的运算符中，除了赋值运算符“=”以及变形的赋值运算符（如&gt;&gt;=、+=等），其余在基类重载的运算符都能被派生类所继承</strong></li></ul><h4 id="运算符重载为成员函数">运算符重载为成员函数</h4><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;形式参数表&gt;) &#123;</span><br><span class="hljs-comment">    &lt;函数体&gt;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 前置单目运算符和后置单目运算符的重载最主要的区别就在于重载函数的形参</span><br>Object&amp; <span class="hljs-keyword">operator</span>++();<span class="hljs-comment">// 重载前置单目运算符</span><br>Object <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// 重载后置单目运算符</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>    &#125;<br>    Object&amp; <span class="hljs-keyword">operator</span> ++() &#123;<br>        (*<span class="hljs-keyword">this</span>).count++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Object <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) &#123;<br>        Object old = *<span class="hljs-keyword">this</span>;<br>        ++(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>    Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;c) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-function">Object <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;count + c.count)</span></span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    Object c = a+b;<br>    <span class="hljs-comment">// a = 1, b = 2</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a.<span class="hljs-built_in">getCount</span>()&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b.<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    a++;<br>    ++b;<br>    <span class="hljs-comment">// a = 2, b = 3</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a.<span class="hljs-built_in">getCount</span>()&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b.<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">// a + b = 5</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a + b = &quot;</span>&lt;&lt;(a+b).<span class="hljs-built_in">getCount</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载为非成员函数">运算符重载为非成员函数</h4><p>Tips：不一定所有的非成员函数运算符重载都需要声明为类的友元函数，仅在需要访问类的私有成员或保护成员时再这样</p><p>语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;形式参数表&gt;) &#123;</span><br><span class="hljs-comment">    &lt;函数体&gt;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 前置单目运算符和后置单目运算符的重载最主要的区别就在于重载函数的形参</span><br><span class="hljs-keyword">friend</span> Object&amp; <span class="hljs-keyword">operator</span>++(Object &amp;a);<span class="hljs-comment">// 重载前置单目运算符</span><br><span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span>++(Object &amp;a, <span class="hljs-type">int</span>); <span class="hljs-comment">// 重载后置单目运算符</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        count = value;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(istream &amp;in, Object&amp; a);<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream &amp;out, Object&amp; a);<br>    <span class="hljs-keyword">friend</span> Object&amp; <span class="hljs-keyword">operator</span> ++(Object &amp;a);<br>    <span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span> ++(Object &amp;a, <span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">friend</span> Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;a, <span class="hljs-type">const</span> Object &amp;b);<br>&#125;;<br><br>istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(istream &amp;in, Object&amp; a) &#123;<br>    in&gt;&gt;a.count;<br>    <span class="hljs-keyword">return</span> in;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream &amp;out, Object&amp; a) &#123;<br>    out&lt;&lt;a.count;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br>Object&amp; <span class="hljs-keyword">operator</span> ++(Object &amp;a) &#123;<br>    a.count++;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br>Object <span class="hljs-keyword">operator</span> ++(Object &amp;a, <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-function">Object <span class="hljs-title">now</span><span class="hljs-params">(a.count)</span></span>;<br>    ++a;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br>Object <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> Object &amp;a, <span class="hljs-type">const</span> Object &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(a.count + b.count);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object a, b;<br>    <span class="hljs-comment">// input 1 2</span><br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-comment">// a = 1, b = 2</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    a++;<br>    ++b;<br>    <span class="hljs-comment">// a = 2, b = 3</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;, b = &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    Object c = a+b;<br>    <span class="hljs-comment">// a + b = 5</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a + b = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>前置单目运算符重载为成员函数时没有形参，而后置单目运算符重载为成员函数时需要有一个<code>int</code>型的形参</li><li>输入运算符“&gt;&gt;”和输出运算符“&lt;&lt;”的第一操作数必须是流类对象而非本类对象，所以只能以<strong>友元函数</strong>的形式重载运算符</li><li>赋值运算符“=”只能被重载为<strong>成员函数</strong>，而且是不能被继承的</li><li>函数调用运算符“()”可以是带一个或多个右操作数的运算符函数，函数调用运算符重载只能使用<strong>成员函数</strong></li></ul><h3 id="虚函数">虚函数</h3><p>虚函数是<strong>动态绑定</strong>的基础，虚函数必须是非静态的成员函数，虚函数经过派生之后，在类族中就可以实现运行过程中的多态</p><p>根据赋值兼容规则，可以使用派生类的对象代替基类对象。但是当使用基类指针指向派生类对象时，访问到的只是从基类继承过来的同名成员，派生类的出现解决了这个问题，当该同名函数被声明为虚函数时，通过基类指针访问派生类对象同名函数时，得到的是其派生类重写后的同名函数，使属于不同派生类的不同对象产生不同的行为，从而实现运行中的多态</p><p>格式：<code>virtual 函数类型 函数名(形参表)</code></p><p><strong>虚函数声明只能出现在类定义中的函数原型声明中，不能在成员函数实现的时候</strong></p><p><strong>运行过程中的多态</strong>需要满足的条件：</p><ul><li>类之间满足<strong>赋值兼容规则</strong></li><li>要声明<strong>虚函数</strong></li><li>由成员函数来调用或者是通过指针、引用来访问虚函数</li></ul><p>如果是通过对象名来访问虚函数，则绑定在编译过程中就可以进行（静态绑定），而无需在运行过程中进行</p><p>基类指针如何访问被覆盖的基类虚函数？<strong>通过域解析符<code>::</code>进行限定</strong></p><p><strong>几个常见问题：</strong></p><ul><li><p>当基类构造函数调用虚函数时，不会调用派生类的虚函数，因为基类的构造函数调用先于派生类的构造函数调用，当基类构造函数调用时，此时派生类还没有形成一个完整对象</p></li><li><p>当基类析构函数调用虚函数时，不会调用派生类的虚函数，因为基类的析构函数调用晚于派生类的构造函数调用，当基类析构函数调用时，此时派生类对象已经析构完毕</p></li><li><p>虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的，所以虚函数一般不能以内联函数处理。但将虚函数声明为内联函数也不会引起错误</p></li><li><p>同名虚函数在基类和派生类中其函数原型完全一致，即函数的返回值类型、函数名、形式参数表完全相同，否则无法通过虚函数实现动态多态性</p></li><li><p><strong>对象切片：使用派生类对象复制构造基类对象的行为</strong>。在这种情况下，派生类从基类中继承的成员会被复制，派生类中新增的成员将被忽略，当然，也没有空间给这些成员赋值</p></li></ul><h4 id="虚析构函数">虚析构函数</h4><p><strong>在C++中，不能声明虚构造函数，但是可以声明虚析构函数</strong></p><p>格式：<code>virtual ~类名()</code></p><p>如果一个类的析构函数是虚函数，那么由它派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数之后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作</p><h3 id="纯虚函数与抽象类">纯虚函数与抽象类</h3><p>抽象类是一个特殊的类，处于类层次的上层，一个抽象类自身无法实例化，也就是说我们无法定义一个抽象类的对象，只能通过继承机制，生成抽象类的非抽象派生类，然后进行实例化</p><h4 id="纯虚函数">纯虚函数</h4><p>纯虚函数是一个在基类中声明的虚函数，在基类中没有给出具体的操作，要求其派生类给出各自的定义</p><p><strong>格式：</strong><code>virtual 函数类型 函数名(参数表)=0</code></p><p><strong>细节：</strong>在基类中其实可以给出纯虚函数的实现，但是即使给出实现，其派生类也要进行覆盖重写，否则无法实例化，<strong>当基类的析构函数被声明为纯属函数时必须给出实现</strong></p><h4 id="抽象类">抽象类</h4><p>带有纯虚函数的类被称为抽象类，其主要作用是为它的类族定义一个公共的接口，使他们能够更加有效地发挥多态特性。<strong>抽象类不可以被实例化</strong></p><p>当其派生类给出基类中所有纯虚函数的实现之后，该派生类将不再是一个抽象类，此时可以被实例化；但是当没有实现所有纯虚函数时，其派生类依然为一个抽象类</p><h2 id="群体类和群体数据组织">群体类和群体数据组织</h2><p><strong>基本数据类型</strong>是C++编译系统预定义的，而自定义类型的数据是由多个基本类型或自定义类型的元素组成的，称为<strong>群体数据</strong></p><p>对于群体数据，仅有系统预定义的操作是不够的，在很多情况下，还需要设计与某些具体问题相关的特殊操作，并按照面向对象的方法将数据与操作封装起来，这就是<strong>群体类</strong></p><p>群体的两种类型：</p><ul><li><p><strong>线性群体</strong>：元素按顺序排列有序</p></li><li><p><strong>非线性群体</strong>：不用位置顺序来标识元素</p></li></ul><h3 id="函数模板与类模板">函数模板与类模板</h3><p>模板是C++支持参数化程序设计的工具，通过它可以实现<strong>参数化多态性</strong></p><p><strong>参数化多态性</strong>：指将程序所处理的对象的类型参数化，使得一段程序可以用于处理多种不同类型的对象</p><h4 id="函数模板">函数模板</h4><p>定义形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">template&lt;模块参数表&gt;     模块参数表：class(或typename) </span><br><span class="hljs-comment">类型名 函数名(参数表) &#123;</span><br><span class="hljs-comment">    函数体的定义</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">abs</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> ? -x:x;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数模板与重载是密切相关的，从函数模板产生的相关函数都是同名的，编译器用重载的方法调用相应的函数</p><p>函数模板与函数的区别：</p><ol type="1"><li>函数在编译时不会产生任何目标代码，只有模板生成的实例会生成目标代码</li><li>被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，而不能像普通函数那样只将声明放在头文件中</li><li>函数指针也只能指向模板的实例，不能指向模板本身</li></ol><h4 id="类模板">类模板</h4><p>使用类模板使用户可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、返回值或局部变量能取任何类型（包括系统预定义和用户自定义的）</p><p>定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;模板参数表&gt;<br><span class="hljs-keyword">class</span> 类名 &#123;<br>    类成员声明<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在类模板外定义其成员函数，则要采用以下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;模板参数表&gt;<br>类型名 类名&lt;模板参数标识符列表&gt;::函数名(参数表)<br></code></pre></td></tr></table></figure><p>类模板的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板名&lt;模板参数表&gt; 对象名1,...,对象名n;</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h3 id="线性群体">线性群体</h3><p>线性群体中的元素次序与其位置关系是对应的，在线性群体中，又可按照访问元素的不同方法分为<strong>直接访问</strong>、<strong>顺序访问</strong>和<strong>索引访问</strong></p><p>对可直接访问的线性群体，我们可以直接访问群体中的任何一个元素，而不必访问该元素之前的元素</p><p>对顺序访问的线性群体，只能按照元素的排列顺序从头开始依次访问各个元素</p><p>数组、链表、栈、队列</p><h2 id="泛型程序设计与c标准模板库">泛型程序设计与C++标准模板库</h2><p>泛型程序设计，就是编写不依赖于具体数据类型的程序，在C++中，模板是泛型程序设计的主要工具</p><p>泛型程序设计的思想是将算法从特定的数据结构中抽象出来，使算法成为通用的、可以作用于各种不同的数据结构</p><p>以函数模板形式实现的通用算法与各种通用<strong>容器</strong>结合，提高了软件的复用性</p><p>我们可以用<strong>概念</strong>来描述泛型程序设计中作为参数的数据类型所需具备的功能，这里的<strong>”概念“</strong>是泛型程序设计的一个术语，它的内涵是这些功能，它的外延是具备这些功能的所有数据类型</p><p>具备一个概念所需要功能的数据类型称为这一概念的一个<strong>模型</strong></p><p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能（即概念B的模型一定是概念A的模型），那么就说概念B是概念A的子模型</p><h4 id="stl的四种基本组件">STL的四种基本组件：</h4><ul><li>容器<ul><li>容器是容纳、包含一组元素的对象</li><li>容器类库中包括7种基本容器：vector、deque、list、set、mutiset、map和mutimap</li></ul></li><li>迭代器<ul><li>迭代器提供了顺序访问容器中每个元素的方法</li><li>对迭代器可以使用++运算符来获得指向下一个元素的迭代器，可以使用*运算符访问每一个迭代器所指向的元素，部分迭代器允许通过--运算符来获得上一个元素的迭代器</li><li>使用独立于STL容器的迭代器，需要包含头文件&lt;itertor&gt;</li></ul></li><li>函数对象<ul><li>函数对象是一个行为类似函数的对象，对它可以像调用函数一样调用</li><li>任何普通的函数和重载了”()“运算符的类的对象都可以作为函数对象使用，函数对象是泛化的函数</li><li>使用STL的函数对象，需要包含头文件&lt;functional&gt;</li></ul></li><li>算法<ul><li>STL包括70多个算法，包括查找、排序、消除、计数、比较、变换、置换和容器管理</li><li>这些算法的一个最重要的特性就是它们的统一性，并且可以广泛用于不同的对象和内置的数据类型</li><li>使用STL的算法，需要包含头文件&lt;algorithm&gt;</li></ul></li></ul><h2 id="流类库与输入输出">流类库与输入输出</h2><h3 id="流的概念">流的概念</h3><p>在C++中，将数据从一个对象到另一个对象的流动抽象为“流”，从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作，数据的输入与输出就是通过I/O流来实现的</p><p>当程序与外界环境进行信息交换时，存在着两种对象，一个是程序中的对象，另一个是文件对象</p><p><strong>流是一种抽象，它负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动</strong></p><p>流涉及的范围很广，凡是数据从一个地方传输到另一个地方的操作都是流的操作，像网络数据交换、进程数据交换等都是流操作，流操作也可以针对一个字符串进行，<strong>一般意义下的读操作在流数据抽象中被称为（从流中）提取，写操作被称为（向流中）插入</strong></p><h3 id="输出流">输出流</h3><p>一个输出流对象是信息流动的目标，最重要的3个输出流是ostream，ofstream和ostringstream</p><p>预先定义的ostream类对象用来完成向标准设备的输出：</p><ul><li>cout是标准输出流</li><li>cerr是标准错误输出流，没有缓冲，发送给它的内容立即被输出</li><li>clog类似于cerr，但是有缓冲，缓冲区满时被输出</li></ul><h3 id="输入流">输入流</h3><p>一个输入流对象是数据流出的源头，3个最重要的输入流类是istream，ifstream和istringstream</p><p>预先定义的istream对象cin用来挖成从标准输入设备的输入</p><p>ifstream支持磁盘文件输入，很多格式化选项和成员函数都可以应用于ifstream对象，基类ios和istream的所有功能都包括在ifstream中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//读取一行赋值给str</span><br><span class="hljs-built_in">getline</span>(cin, str);<br><span class="hljs-comment">//一个巧妙的重定向输入输出</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<span class="hljs-comment">//从in.in文件中读取输入</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<span class="hljs-comment">//向out.out文件中写入输出</span><br></code></pre></td></tr></table></figure><h3 id="输入输出流">输入输出流</h3><p>一个iostream对象可以是数据的源或目的，有两个重要的I/O流类都是从iostream派生的，它们是fstream和stringstream，这些类继承了前面描述的istream和ostream类的功能</p><p>fstream支持磁盘文件输入和输出，如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象，<strong>一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出</strong></p><p>stringstream类支持面向字符串的输入和输出，可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成</p><h2 id="异常处理-1">异常处理</h2><p>由于环境条件和用户操作的正确性是没有百分之百保证的，所以在设计程序时，就要充分考虑到各种意外情况，并给与恰当的处理</p><h3 id="异常处理的基本思想">异常处理的基本思想</h3><p>程序运行中的有些错误是可以预料但不可避免的，例如内存空间不足、硬盘上的文件被移动、打印机未连接好等由系统运行环境造成的错误。这时要力争做到允许用户排除环境错误，继续运行程序；至少要给出适当的提示信息，这就是异常处理程序的任务</p><p>C++的异常处理机制使得异常的引发和处理不必在同一函数中，这样底层的函数可以着重解决具体问题，而不必过多地考虑对异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理</p><h3 id="c异常处理的实现">C++异常处理的实现</h3><p>C++语言提供对处理异常情况的内部支持，<strong>try，throw和catch语句就是C++语言中用于实现异常处理的机制</strong></p><p>如果某段程序中发现了自己不能处理的异常，就可以使用throw表达式抛掷这个异常，将它抛掷给调用者</p><p>throw的操作数表示异常类型语法上与return语句的操作数相似，如果程序中有多种要抛掷的异常，应该用不同的操作数类型来相互区别</p><h3 id="异常处理的过程">异常处理的过程</h3><ol type="1"><li>程序通过正常的顺序执行到达try语句，然后执行try块内的保护段</li><li>如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行；程序从异常被抛掷的try块后跟随的最后一个catch子句后面的语句继续执行下去</li><li>程序执行到一个throw表达式时，<strong>一个异常对象会被创建</strong>；若异常的抛出点本身在一个try子句内，则该try语句后的catch子句会按顺序检查异常类型是否与声明的类型匹配；若异常抛出点本身不在任何try子句内，或抛出的异常与各个catch子句所声明的类型皆不匹配，则结束当前函数的执行，回到当前函数的调用点，把调用点作为异常的抛出点，然后重复这一过程。此处理继续下去，直到异常成功被一个catch语句捕获</li><li>如果始终未找到与被抛掷异常匹配的catch子句，最终main函数会结束执行，则运行库函数<strong>terminate</strong>将被自动调用，而函数terminate的默认功能是终止程序</li><li>如果找到了一个匹配的catch子句，则catch子句后的符合语句会被执行，复合语句执行完毕后，当前的try块（包括try子句和一系列catch子句）即执行完毕</li></ol><h3 id="异常处理的语法">异常处理的语法</h3><p>表达式语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// throw表达式语法</span><br><span class="hljs-keyword">throw</span> 表达式<br>    <br><span class="hljs-comment">// try块语法</span><br><span class="hljs-keyword">try</span> <br>    复合语句<br><span class="hljs-built_in">catch</span> (异常声明)<br>    复合语句<br><span class="hljs-built_in">catch</span> (异常声明)<br>    复合语句<br>    ...<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p>catch语句可以有多个，分别对应不同返回类型的异常</p></li><li><p>如果异常类型声明是一个省略号(...)，catch子句便处理所有类型的异常，这段处理程序必须是try块的最后一段处理程序，否则会报错</p><p><code>error: '...' handler must be the last handler for its try block[-fpermissive]</code></p></li><li><p>catch子句的异常声明中也允许不给出异常参数名称</p></li><li><p>为了加强程序的可读性，使函数的用户能够方便地知道所使用的函数会抛掷哪些异常，可以在函数的声明中列出这个函数可能抛掷的所有异常类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//该函数能够而且只能抛掷出类型为A,B,C,D及其子类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(A, B, C, D)</span></span>;<br><span class="hljs-comment">//该函数能够抛掷出任何类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//该函数不抛掷任何类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果一个函数抛出了他的异常接口声明所不允许抛出的异常时，unexpected函数会被调用，该函数的默认行为是调用terminate函数中止程序，当然用户也可以定义自己的unexpected函数，替换默认函数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="异常处理中的构造与析构">异常处理中的构造与析构</h3><p>在程序中，找到一个匹配的catch异常处理后，如果catch子句的异常声明是一个<strong>值参数</strong>，则其初始化方式是<strong>复制被抛掷的异常对象</strong>；如果catch子句的异常声明是一个<strong>引用</strong>，则其初始化方式是<strong>使该引用指向异常对象</strong></p><p>C++异常处理的真正功能，不仅在于它能够<strong>处理各种不同类型的异常</strong>，还在于它<strong>具有为异常抛掷前构造的所有局部对象自动调用析构函数的能力</strong></p><p>异常被抛出后，从进入try块（与截获异常的catch子句相对应的那个try块）起，到异常被抛掷前，这期间在栈上构造（且尚未析构）的所有对象都会被<strong>自动析构</strong>，析构的顺序与构造的顺序相反，这一过程称为栈的<strong>解旋</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExpection</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyExpection</span>(<span class="hljs-type">const</span> string &amp;message):<span class="hljs-built_in">message</span>(message) &#123;&#125;<br>    ~<span class="hljs-built_in">MyExpection</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">getMessage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string message;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Constructor of Demo&quot;</span> &lt;&lt; endl;&#125;<br>    ~<span class="hljs-built_in">Demo</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;Destructor of Demo&quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(MyExpection)</span> </span>&#123;<br>    Demo d;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Throw MyExpection in func()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyExpection</span>(<span class="hljs-string">&quot;exception thrown by func()&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;In main function&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">func</span>();<br>    &#125; <span class="hljs-built_in">catch</span>(MyExpection &amp;e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught an exception:&quot;</span> &lt;&lt; e.<span class="hljs-built_in">getMessage</span>() &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Resume the exception of main()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">    In main function</span><br><span class="hljs-comment">    Constructor of Demo</span><br><span class="hljs-comment">    Throw MyExpection in func()</span><br><span class="hljs-comment">    Destructor of Demo</span><br><span class="hljs-comment">    // 先解旋，后处理异常</span><br><span class="hljs-comment">    Caught an exception:exception thrown by func()</span><br><span class="hljs-comment">    Resume the exception of main()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="标准程序库异常处理">标准程序库异常处理</h3><p>C++标准提供了一组标准异常类，这些类以基类Exception开始，标准程序库抛出的所有异常，都派生于该基类</p><p>该基类提供一个<code>what()</code>方法，用来返回错误信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><code>runtime_error</code>和<code>logic_error</code>是一些具体的异常类的基类，它们分别表示两大异常：</p><ul><li><code>logic_error</code>：可以在程序中被预先检测到的异常，能够被避免<ul><li>out_of_range</li><li>length_error</li><li>invalid_argument</li><li>domain_error</li></ul></li><li><code>runtime_error</code>：表示那些难以被预先检测的异常<ul><li>underflow_error</li><li>overflow_error</li><li>range_error</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
